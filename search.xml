<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>23 PR/AE 培训</title>
    <url>/2023/12/02/23-PR-AE-%E5%9F%B9%E8%AE%AD/</url>
    <content><![CDATA[<p>培训的主旨是如何用最少的精力完成好的作品</p>
<h1 id="PR一些好用的拓展"><a href="#PR一些好用的拓展" class="headerlink" title="PR一些好用的拓展"></a>PR一些好用的拓展</h1><h2 id="蓝宝石特效等"><a href="#蓝宝石特效等" class="headerlink" title="蓝宝石特效等"></a>蓝宝石特效等</h2><p>首先安装下面这个安装包<br>可以看到这个东西年代十分久远<br>有想法的可以自己去找<br><img src="/2023/12/02/23-PR-AE-%E5%9F%B9%E8%AE%AD/1.png"><br>安装的话就跟着里面说得来就行<br>如果提示路径选择记得别选到C盘</p>
<p>在PR里我们随便开一个项目<br>可以看到特效一栏多了很多东西<br>这些都可以自行选择，基本都是你拖到序列上试一下就知道怎么用的<br><img src="/2023/12/02/23-PR-AE-%E5%9F%B9%E8%AE%AD/2.png"><br>这里给你们演示一下蓝宝石特效<br><img src="/2023/12/02/23-PR-AE-%E5%9F%B9%E8%AE%AD/3.png"></p>
<h2 id="MOTION-FACTORY"><a href="#MOTION-FACTORY" class="headerlink" title="MOTION FACTORY"></a>MOTION FACTORY</h2><p>属于插件类型，类似的如下图<br><img src="/2023/12/02/23-PR-AE-%E5%9F%B9%E8%AE%AD/4.png"></p>
<p>这个是一个动态素材管理插件<br>可以从不同的来源下载动态素材<br>我这里的素材大都INS风格<br><img src="/2023/12/02/23-PR-AE-%E5%9F%B9%E8%AE%AD/5.png"><br>用的最频繁的还是这里的标题动态效果<br>字体可以自己更换，提醒大伙最好自己整一套觉得好用的字体库</p>
<h2 id="效果预设"><a href="#效果预设" class="headerlink" title="效果预设"></a>效果预设</h2><p>可以找到一些网友分享的好用的特效预设<br>将预设导入PR，可以在效果栏找到你导入的预设，一般会在Preset这个目录下<br>使用也是拖到序列上自己试一下就知道怎么用<br><img src="/2023/12/02/23-PR-AE-%E5%9F%B9%E8%AE%AD/6.png"></p>
<h1 id="AE模板使用"><a href="#AE模板使用" class="headerlink" title="AE模板使用"></a>AE模板使用</h1><p>直接百度去找就行<br>没有哪个AE模板网站可以完美解决所有需求和问题<br>总是需要在数个网站中去寻找你想要的预设</p>
<p>下载后先看文件内容<br>一些公司出品的模板一般都有类似long，short等版本的区分<br>所以在使用之前先看好你想要的是哪个<br>直接双击你需要的.aep文件就行<br><img src="/2023/12/02/23-PR-AE-%E5%9F%B9%E8%AE%AD/7.png"></p>
<p>目前来说AE模板中的编辑大概有两种形式</p>
<ol>
<li>自己替换素材</li>
<li>模板修改选项</li>
</ol>
<p>第一种的可操作性更强，如现在演示的，可以自己替换、加入、删除素材和效果<br><img src="/2023/12/02/23-PR-AE-%E5%9F%B9%E8%AE%AD/9.png"></p>
<p>第二种对于他封装好的效果可操作性不强，他给你提供了几个选项来修改效果<br><img src="/2023/12/02/23-PR-AE-%E5%9F%B9%E8%AE%AD/8.png"></p>
]]></content>
      <categories>
        <category>PR/AE</category>
      </categories>
  </entry>
  <entry>
    <title>CTF也要谈恋爱！</title>
    <url>/2022/11/23/CTF%E4%B9%9F%E8%A6%81%E8%B0%88%E6%81%8B%E7%88%B1%EF%BC%81/</url>
    <content><![CDATA[<h1 id="难点一：好感度判断"><a href="#难点一：好感度判断" class="headerlink" title="难点一：好感度判断"></a>难点一：好感度判断</h1><p>打开游戏正常进度，遇到第一个难点：好感度判断<br><img src="/2022/11/23/CTF%E4%B9%9F%E8%A6%81%E8%B0%88%E6%81%8B%E7%88%B1%EF%BC%81/11.23-1.png"><br>这里的对话是循环的，循环一次好感度加一，且此处快进快捷键被禁用了，只能一下一下点鼠标。<br>提示好感度需要权限来更改，此处循环的提示根据好感度的不同会变化</p>
<p>好感度小于100：<br>我的好感度可不会随便更改！</p>
<p>好感度大于100小于300：<br>我是renpy人，你应该知道怎么对付我<br>只有我的开发者才能更改我的好感度<br>或者你试着装成那个人？</p>
<p>好感度大于300小于700：<br>如果你是开发者的话就不用点这么久了<br>我的内核是renpy，让我认为你是开发者应该很简单</p>
<p>好感度大于700：<br>此时会说一些鼓励玩家继续点击的话</p>
<p>所有的提示都指向获取游戏引擎的开发权限<br>此时退出游戏，进行权限更改<br>（网上挺多获取权限的教程的）</p>
<p>打开.&#x2F;renpy&#x2F;common&#x2F;00console.rpy<br>找到如下行<br><img src="/2022/11/23/CTF%E4%B9%9F%E8%A6%81%E8%B0%88%E6%81%8B%E7%88%B1%EF%BC%81/11.23-2.png"></p>
<p>修改为True<br><img src="/2022/11/23/CTF%E4%B9%9F%E8%A6%81%E8%B0%88%E6%81%8B%E7%88%B1%EF%BC%81/11.23-3.png"></p>
<p>再次进入游戏：<br>使用快捷键shift+o打开变量控制台<br><img src="/2022/11/23/CTF%E4%B9%9F%E8%A6%81%E8%B0%88%E6%81%8B%E7%88%B1%EF%BC%81/11.23-4.png"></p>
<p>在页面的左上好感度界面有提示好感度的变量名是persistent.lovenum<br>将它改为999以上<br><img src="/2022/11/23/CTF%E4%B9%9F%E8%A6%81%E8%B0%88%E6%81%8B%E7%88%B1%EF%BC%81/11.23-5.png"></p>
<p><img src="/2022/11/23/CTF%E4%B9%9F%E8%A6%81%E8%B0%88%E6%81%8B%E7%88%B1%EF%BC%81/11.23-6.png"><br><img src="/2022/11/23/CTF%E4%B9%9F%E8%A6%81%E8%B0%88%E6%81%8B%E7%88%B1%EF%BC%81/11.23-7.png"><br>好感度判定成功！<br>第一阶段结束</p>
<h1 id="难点二：处理情书"><a href="#难点二：处理情书" class="headerlink" title="难点二：处理情书"></a>难点二：处理情书</h1><p>第二个难题是拿到情书之后的操作：<br><img src="/2022/11/23/CTF%E4%B9%9F%E8%A6%81%E8%B0%88%E6%81%8B%E7%88%B1%EF%BC%81/11.23-8.png"><br><img src="/2022/11/23/CTF%E4%B9%9F%E8%A6%81%E8%B0%88%E6%81%8B%E7%88%B1%EF%BC%81/11.23-9.png"></p>
<p>根据提示，发现情书放在了游戏源文件夹中，推测是文件隐写<br>使用binwalk工具发现确实存在两个文件<br>将文件后缀名改为rar解压得到存档文件<br><img src="/2022/11/23/CTF%E4%B9%9F%E8%A6%81%E8%B0%88%E6%81%8B%E7%88%B1%EF%BC%81/11.23-10.png"></p>
<p>将他放到.&#x2F;game&#x2F;saves文件夹下<br>进入游戏读取存档，得到flag<br><img src="/2022/11/23/CTF%E4%B9%9F%E8%A6%81%E8%B0%88%E6%81%8B%E7%88%B1%EF%BC%81/11.23-11.png"></p>
<p>此时游戏源代码被删除无法打开第二次</p>
<p>题目暂时放到github</p>
<p><a href="https://github.com/Nonbliss/CTF-is-also-going-to-be-in-love">https://github.com/Nonbliss/CTF-is-also-going-to-be-in-love</a></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
  </entry>
  <entry>
    <title>PR培训-12.4</title>
    <url>/2022/12/03/PR%E5%9F%B9%E8%AE%AD-12-4/</url>
    <content><![CDATA[<h1 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h1><p>位置选择自己的工作文件夹，右侧浏览可以选择保存位置</p>
<p>保存的是本视频的工程文件，工程文件就是整个视频剪辑内容的存档，在多人共同工作中需要使用</p>
<p>视频渲染和回放，选择“仅限软件”可以兼容大部分的特效</p>
<p>其他选项默认即可</p>
<p><img src="/2022/12/03/PR%E5%9F%B9%E8%AE%AD-12-4/1.png"></p>
<h1 id="剪辑界面"><a href="#剪辑界面" class="headerlink" title="剪辑界面"></a>剪辑界面</h1><p>工作栏下方的第一条是工作界面快速选择，一般常用的是编辑和图形两种界面</p>
<p>界面也可以自己调整，可以调整为自己喜欢的</p>
<h1 id="导入素材方式"><a href="#导入素材方式" class="headerlink" title="导入素材方式"></a>导入素材方式</h1><p>左下角可以双击导入</p>
<p>也可以推拽视频进入</p>
<p>可以新建素材文件夹，实现素材使用过和没有使用过的分区管理</p>
<h1 id="开始剪辑"><a href="#开始剪辑" class="headerlink" title="开始剪辑"></a>开始剪辑</h1><p>从素材库中拖拽素材到轨道上</p>
<p>右上角是预览，可以看到现在时间线一帧的内容</p>
<h2 id="序列设置"><a href="#序列设置" class="headerlink" title="序列设置"></a>序列设置</h2><p>调整画布大小</p>
<p>音频采样</p>
<p>方形像素，即每个像素长宽比１：１</p>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>首先保证大写锁定开启或者输入法关闭</p>
<p>C 剪辑工具</p>
<p>V 选择工具</p>
<p>Control + Z 撤回</p>
<p>L 加速</p>
<p>J 减速</p>
<h2 id="剪辑过程"><a href="#剪辑过程" class="headerlink" title="剪辑过程"></a>剪辑过程</h2><p>首先用剪辑工具将一个片段分开，分开之后一段素材变成了两段（我在说什么理所当然的东西）</p>
<p>这时本来属于一个素材的两个片段就变成了两个素材（对于你的剪辑来说，对于素材库依旧没有改变）</p>
<p>现在这个素材就可以随意拖拽</p>
<p>发现直接剪开的话是视频和音频一起剪开了，那么我们怎么只剪视频呢——取消链接</p>
<p>取消链接之后视频和音频也不会再一起拖动。</p>
<h1 id="特效"><a href="#特效" class="headerlink" title="特效"></a>特效</h1><p>特效大致分为两类，视频，转场</p>
<h2 id="视频类特效"><a href="#视频类特效" class="headerlink" title="视频类特效"></a>视频类特效</h2><h3 id="本体效果"><a href="#本体效果" class="headerlink" title="本体效果"></a>本体效果</h3><p>大小，位置，缩放等</p>
<h3 id="应用类效果"><a href="#应用类效果" class="headerlink" title="应用类效果"></a>应用类效果</h3><p>模糊／锐化</p>
<p>变形稳定器</p>
<p>嵌套：变形稳定器＋变速</p>
<p>调色</p>
<h3 id="关键帧"><a href="#关键帧" class="headerlink" title="关键帧"></a>关键帧</h3><p>关键帧的关键是对于一个对象说的，这个对象可以是视频本体，也可以是某种效果</p>
<p>大小和缩放的关键帧</p>
<p>模糊关键帧</p>
<h2 id="转场类特效"><a href="#转场类特效" class="headerlink" title="转场类特效"></a>转场类特效</h2><p>应用在两段素材拼接处</p>
<p>黑场过渡，叠加过渡，溢光过渡</p>
<h1 id="音频效果"><a href="#音频效果" class="headerlink" title="音频效果"></a>音频效果</h1><h2 id="本体效果-1"><a href="#本体效果-1" class="headerlink" title="本体效果"></a>本体效果</h2><p>音频增益，简单来说就是音量大小，０.０就是跟这个素材导入的时候一样声音大小</p>
<p>级别，也是音量大小，但是可以打关键帧</p>
<h2 id="应用类效果-1"><a href="#应用类效果-1" class="headerlink" title="应用类效果"></a>应用类效果</h2><p>降噪</p>
<h1 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h1><p>工具栏导出</p>
<p>格式选H.264，导出就是MP4视频</p>
<p>预设：最少匹配源高比特率</p>
<p>点击输出名称可以设置输出文件夹</p>
<h2 id="基本视频设置"><a href="#基本视频设置" class="headerlink" title="基本视频设置"></a>基本视频设置</h2><p>取消打勾可以进行更改</p>
<p>比特率设置：</p>
<p>一般设置：一次渲染，目标比特率１０</p>
<p>较好设置：两次渲染，目标比特率１０，最大比特率１２</p>
<p>时间插值帧采样即可</p>
<h1 id="进阶特效"><a href="#进阶特效" class="headerlink" title="进阶特效"></a>进阶特效</h1><h2 id="蓝宝石！"><a href="#蓝宝石！" class="headerlink" title="蓝宝石！"></a>蓝宝石！</h2><p>溢光效果</p>
<p>给你们打个包发群里，但是年代久远我也不知道能用不能</p>
<h2 id="预设特效"><a href="#预设特效" class="headerlink" title="预设特效"></a>预设特效</h2><p>转场</p>
<p>也打个包吧，然后外置预设特效怎么导入网上有教程的，随便搜搜就行</p>
<h2 id="Motion-Factory"><a href="#Motion-Factory" class="headerlink" title="Motion Factory"></a>Motion Factory</h2><p>很好用的效果都有</p>
<p>这个就Ｂ站找个视频就行，我推荐这个up分享的</p>
<p><a href="https://www.bilibili.com/video/BV1Sq4y1c7Go">链接在这里</a></p>
]]></content>
      <categories>
        <category>PR/AE</category>
      </categories>
  </entry>
  <entry>
    <title>信息内容安全-复习（仅重点内容）</title>
    <url>/2023/05/26/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%BB%85%E9%87%8D%E7%82%B9%E5%86%85%E5%AE%B9%EF%BC%89/</url>
    <content><![CDATA[<h2 id="标记类型"><a href="#标记类型" class="headerlink" title="标记类型"></a>标记类型</h2><ul>
<li>斜体：看看就行</li>
<li>正常：正常掌握</li>
<li>粗体&#x2F;emoji❗：重点掌握</li>
</ul>
<h1 id="此处仅罗列大纲，因为往年学长总结很好，这里就不重新总结了，仅个人复习使用大纲"><a href="#此处仅罗列大纲，因为往年学长总结很好，这里就不重新总结了，仅个人复习使用大纲" class="headerlink" title="此处仅罗列大纲，因为往年学长总结很好，这里就不重新总结了，仅个人复习使用大纲"></a>此处仅罗列大纲，因为往年学长总结很好，这里就不重新总结了，仅个人复习使用大纲</h1><h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h2 id="信息安全技术架构❗"><a href="#信息安全技术架构❗" class="headerlink" title="信息安全技术架构❗"></a>信息安全技术架构❗</h2><p>注意有一个图，四层，信息安全金三角：CIA架构</p>
<p>信息安全四要素：CACA</p>
<h2 id="信息安全层次划分❗❗❗"><a href="#信息安全层次划分❗❗❗" class="headerlink" title="信息安全层次划分❗❗❗"></a>信息安全层次划分❗❗❗</h2><ul>
<li>内容安全</li>
<li>数据安全</li>
<li>运行安全</li>
<li>物理安全</li>
</ul>
<p>存在一个三级框架，每个夹在两层中间</p>
<ul>
<li>信息对抗</li>
<li>信息安全</li>
<li>系统安全</li>
</ul>
<h2 id="信息安全的诱因与威胁❗❗"><a href="#信息安全的诱因与威胁❗❗" class="headerlink" title="信息安全的诱因与威胁❗❗"></a>信息安全的诱因与威胁❗❗</h2><p>根本原因：冯诺伊曼结构<br>直接原因：自身缺陷+开放性+黑客攻击<br>常见攻击：就是漏洞类型随便写几个</p>
<p>网络安全的任务<br>信息安全的任务<br>内容安全的任务<br>信息对抗的任务</p>
<h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><h2 id="整体框架❗❗"><a href="#整体框架❗❗" class="headerlink" title="整体框架❗❗"></a>整体框架❗❗</h2><p>5个问题，及问题的解决方法<br>互联网络信息内容安全识别引擎架构</p>
<h1 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h1><h2 id="搜索引擎架构❗❗❗"><a href="#搜索引擎架构❗❗❗" class="headerlink" title="搜索引擎架构❗❗❗"></a>搜索引擎架构❗❗❗</h2><p>那个图</p>
<p>七页逻辑图看一下不会考默写啥的❗</p>
<p>三个步骤</p>
<ol>
<li>爬行与抓取</li>
<li>预处理</li>
<li>排名</li>
</ol>
<h3 id="爬行与抓取"><a href="#爬行与抓取" class="headerlink" title="爬行与抓取"></a>爬行与抓取</h3><p>网页为节点，hyperlink为有向边，深度优先|广度优先<br>从种子url提取待抓取url，待抓取url进行预处理分析后放入网页库并将这些url放入已抓取url中，同时从这些url中可以得到下一步的待抓取url</p>
<p>问题</p>
<ul>
<li>网页爆炸性增长——需要高效率</li>
<li>服务器陷阱，法律问题，重复url，停电等</li>
</ul>
<p>服务器保护：<br>robot.txt是crawer需要遵守的文件，但是也可以不遵守，君子协定<br>服务器陷阱，64k的NULL或嵌套重复url，超深路径</p>
<p>解决：<br>没有完美的解决，需要经常分析历史数据<br>太长url不爬，只爬静态内容，清除非文本的url等</p>
<p>爬虫需要：❗</p>
<ul>
<li>快</li>
<li>可扩展性</li>
<li>友好性</li>
<li>健壮</li>
<li>持续搜集</li>
<li>时新性</li>
</ul>
<p>高性能爬虫</p>
<p>爬虫架构<br>那个大图抽象一下即可</p>
<p>典型的DNS请求是异步的，若不采取措施，DNS地址解析会是爬虫的一个瓶颈<br>解决：</p>
<ul>
<li>缓存服务器<br>大缓存容量，跨DNS系统的刷新保持内容，不同于普通DNS定期刷新，这里面向爬虫进行缓存的刷新</li>
<li>预取client<br>为了减少等待查找涉及新主机的地址的时间：尽早将主机名投给DNS系统<br>提前拿url并给DNS，解析完之后方cache中等待使用<br>通常用UDP实现，用不着等待解析的完成</li>
</ul>
<p>网页抓取慢<br>并发抓取——瓶颈在处理器和硬盘</p>
<ol>
<li>多线程&#x2F;进程<br>通常用阻塞的系统调用<br>问题：<br>内存地址空间不够<br>互斥<br>磁盘访问代价</li>
<li>异步非阻塞socket<br>更高效的存储管理，不需要等网络操作的完成，网页抓取的完成不相互影响</li>
</ol>
<p>Bloom filter——消除访问过的url❗<br>用来检测一个元素是不是集合中的一个成员。如果检测结果为是，该元素不一定在集合中；但如果检测结果为否，该元素一定不在集合中<br>牺牲了正确率和时间以节省空间</p>
<p>检测重复网页<br>完全重复网页可以md5<br>近似网页不能md5——Shingling</p>
<p>负载均衡：</p>
<ul>
<li>持续性负载<br>通过提高服务器能力解决</li>
<li>临时性负载<br>使用缓存代理技术</li>
</ul>
<p>分布式计算</p>
<ul>
<li>主从模式</li>
<li>p2p模式（一个圈）</li>
</ul>
<p>任务如何划分？——一致性哈希❗<br>简单划分，直接把buckets给机器<br>问题：机器数目变化<br>一致性哈希——无需集中目录，也无需担心节点失效的一种查找元素位置的方法<br>目标：将item均匀的分布在不同的BUCKET中——负载均衡<br>使用cache机制的规则——3个<br>哈希值组成一个圈，计算出来的哈希值可以放在圈上，cache服务器也放在圈上。对象使用哈希值增大方向遇到的第一个服务器，若服务器减少，则有关的请求直接搜寻下一个服务器，若服务器增加，则只需要在圈上增加一个节点，仅需变动部分对象，比简单划分的几乎变动所有对象简单很多</p>
<h2 id="网页排序"><a href="#网页排序" class="headerlink" title="网页排序"></a>网页排序</h2><h3 id="PageRank❗❗❗"><a href="#PageRank❗❗❗" class="headerlink" title="PageRank❗❗❗"></a>PageRank❗❗❗</h3><p>每个节点给一个1&#x2F;N的初始值（也可以是1）<br>排名泄露：存在节点没有出度，则最终所有PR趋向0<br>排名下沉：没有入度，PR趋于0<br>排名上升：形成圈，则成圈的几个网页PR只增不减</p>
<p>解决排名上升公式<br><img src="/2023/05/26/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%BB%85%E9%87%8D%E7%82%B9%E5%86%85%E5%AE%B9%EF%BC%89/2.png"><br>a&#x3D;0.85(一般)</p>
<p>Markov过程收敛，需要</p>
<ol>
<li>A为随机矩阵</li>
<li>A是不可约的</li>
<li>A是非周期的</li>
</ol>
<p><img src="/2023/05/26/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%BB%85%E9%87%8D%E7%82%B9%E5%86%85%E5%AE%B9%EF%BC%89/3.png"><br>先别急，我真忘了这玩意考不考，我十分希望不考，这明显就不是给大学生学的东西，应该是给高中生学的！</p>
<p>现象<br>链入链接从根本上决定PageRank大小<br>链入链接相同情况下，链出链接也影响PageRank的大小<br>评价：<br>总体：什么影响PR值<br>局部：链入相同时看链出，看最多，看最少</p>
<p>PR算法应用困难</p>
<ol>
<li>现实世界与假想模型不同</li>
<li>实际计算中需要计算80亿网页</li>
</ol>
<p>计算难点：</p>
<ol>
<li>计算机容量限制</li>
<li>收敛问题-硬计算会很慢</li>
</ol>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>一个搜索引擎需要做的几件事</p>
<ol>
<li>自动下载尽可能多的网页</li>
<li>建立快速有效的索引</li>
<li>根据相关性对网页进行公平准确的排序</li>
</ol>
<p>信息检索模型<br>四元组[D, Q, F, R(qi, dj)]<br>– D: 文档集的机内表示——关键词<br>– Q: 用户需求的机内表示——查询式<br>– F: 文档表示、查询表示和它们之间的关系的模型框架(Frame)</p>
<ul>
<li>R(qi, dj): 排序函数，给query qi 和document dj评分</li>
</ul>
<h3 id="布尔模型"><a href="#布尔模型" class="headerlink" title="布尔模型"></a>布尔模型</h3><p>Q：与或非<br>F：二值判断标准</p>
<p>正排索引<br>对于一个文档，所有的关键词排成一行，有的置1，没有的置0<br>目标文档所需关键词做一个类似的行，要的词置1不要的词置0，其他不管<br>然后这两行&amp;一下，如果等于目标文档的行，则通过</p>
<p>倒排索引<br>对每个关键词建一行，行对应是文档，文档中有的对应位置1，没有的置0<br>目标需要关键词的行做bool运算，最后得到一行，行中置1对应的文档是结果<br>过程</p>
<ol>
<li>找词</li>
<li>取地址列表</li>
<li>计算标识符</li>
</ol>
<p>索引储存</p>
<ul>
<li>动态语料库</li>
<li>静态收集<br>  -索引压缩<br>  &lt;前缀长度，后缀&gt;<br>  数字保存与上一数字的插值</li>
</ul>
<p>布尔模型优点</p>
<ol>
<li>查询简单易于理解</li>
<li>方便控制查询结果</li>
</ol>
<p>布尔模型问题</p>
<ol>
<li>不支持部分匹配</li>
<li>很难控制被检索的文档数量</li>
<li>很难对输出排序</li>
<li>很难自动反馈——提示用户如何更改查询式</li>
</ol>
<h3 id="向量空间模型"><a href="#向量空间模型" class="headerlink" title="向量空间模型"></a>向量空间模型</h3><p>文档D(Document)<br>索引项t（Term）——检索词<br>特征项权重Wk（Term Weight）<br>相似度S（Similarity）</p>
<p>根据相似度对输出结果进行排序<br>支持自动的相关反馈</p>
<p>tf-idf<br>– tfij &#x3D; 词项j在文档i中的频率——有除N和不除N两种<br>反应这个词对这篇文章是否更重要——越多越重要<br>– df j &#x3D; 词项j的文档频率&#x3D; 包含词项j的文档数量<br>– idfj &#x3D; 词项j的反文档频率&#x3D; log2 (N&#x2F; df j)——不一定2也可以是10<br>反映这个词在总体上是否重要——越多越不重要<br>TF-IDF &#x3D; TF x IDF</p>
<p>查询式的词项权重</p>
<p>相似度计算<br>最佳的相似度计算方法并不存在</p>
<p>作用</p>
<ol>
<li>排序</li>
<li>反馈</li>
<li>控制数量</li>
</ol>
<p>计算方式</p>
<ol>
<li>内积<br>内积值没有界限<br>对长文档有利</li>
<li>余弦<br><img src="/2023/05/26/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%BB%85%E9%87%8D%E7%82%B9%E5%86%85%E5%AE%B9%EF%BC%89/4.png"></li>
</ol>
<p>向量空间优点：</p>
<ol>
<li>提高搜索性能</li>
<li>输出更合理</li>
<li>可以排序</li>
</ol>
<p>缺点：</p>
<ol>
<li>标引词之间被认为是相互独立</li>
<li>随着Web页面信息量的增大，查询结果会逐渐偏离用户需求</li>
<li>隐含语义索引模型是向量空间模型的延申</li>
</ol>
<h3 id="扩展布尔模型"><a href="#扩展布尔模型" class="headerlink" title="扩展布尔模型"></a>扩展布尔模型</h3><p>先用布尔模型的出满足条件的文档，然后用向量空间法排序</p>
<p>如果“与”应用于布尔查询，结果集可能太窄，如果”或“应用于布尔查询时，就和纯向量查询没有区别——提出扩展布尔模型</p>
<p>扩展布尔模型的或关系<br>用到（0，0）的距离作为我的评价，越大越好<br>平方和除以二在开方</p>
<p>扩展布尔模型的与关系<br>用到（1，1）的距离作为我的评价，越小越好<br>用1减去与1的距离的平方和除以二再开方</p>
<p>忽略布尔关系的话，向量空间查询式和布尔查询式是相同的</p>
<p>p-norm模型</p>
<p>p&#x3D;1时和向量空间中的内积相似<br>p&#x3D;∞时模糊逻辑模型</p>
<h1 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h1><h2 id="网络流监控模式"><a href="#网络流监控模式" class="headerlink" title="网络流监控模式"></a>网络流监控模式</h2><ul>
<li>串联监控模式<br>  通过网关监控<ul>
<li>需要改变现有网络架构</li>
<li>有延时</li>
<li>故障直接断网</li>
</ul>
</li>
<li>旁路监控模式<br>  通过交换机的端口镜像实现监控<ul>
<li>部署方便，不影响现有网络架构</li>
<li>不会造成延时</li>
<li>故障不影响正常运行</li>
<li>局限性<ul>
<li>数据获取<br>  需要交换机支持端口镜像</li>
<li>数据管控<br>  采用发送RST来断开TCP，不能禁止UDP，UDP需要镜像设备通知防火墙管理</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="旁路检测技术"><a href="#旁路检测技术" class="headerlink" title="旁路检测技术"></a>旁路检测技术</h2><ul>
<li>数据分流<ul>
<li>分光器</li>
<li>路由交换</li>
<li>HUB</li>
</ul>
</li>
<li>数据汇聚</li>
<li>报文抓取<ul>
<li>这个图很重要</li>
<li>影响性能因素<ul>
<li>系统调用</li>
<li>数据拷贝</li>
<li>计算校验和</li>
<li>网卡中断</li>
</ul>
</li>
</ul>
</li>
<li>报文抓取过程优化<ul>
<li>报文捕获后直接给用户态专用协议栈抽取，而不是过机器的协议栈走系统调用再解码，这样做可以由原来的三次拷贝编程一次拷贝，并且只用了一个缓冲空间</li>
</ul>
</li>
<li>协议还原</li>
<li>内容抽取</li>
<li>数据耦合方法</li>
</ul>
<h2 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h2><p>他上课说没什么用，喜欢出原理性东西，代码啥的不用，进程通信是重点</p>
<h3 id="进程通信技术——UNIX"><a href="#进程通信技术——UNIX" class="headerlink" title="进程通信技术——UNIX"></a>进程通信技术——UNIX</h3><p>进程通信方法（IPC）<br>Unix IPC包括：管道、FIFO、信号<br>System V IPC包括：System V消息队列、System V信号灯、System V共享内存区<br>Posix IPC包括：Posix消息队列、Posix信号灯、Posix共享内存区</p>
<p>进程通信技术：<br>管道，命名管道，信号，报文队列，共享内存，信号量，套接口</p>
<p>linux进程要素：<br>一段可执行程序，专用系统堆栈空间，进程控制块，独立存储空间</p>
<p>内存映射技术<br>共享内存：最有效的进程间通信方式，也是最快的IPC方式<br>一块物理内存被映射到进程AB各自的进程地址空间<br>需要同步机制，互斥锁或信号量都可以</p>
<p>mmap()系统调用<br>将文件映射到进程地址空间</p>
<ol>
<li>page cache和swap cache<br>一个被访问文件的物理页面都驻留在这两个里面</li>
<li>文件与address_space的对应<br>address_space中一个偏移量能确定上面两个的一个页面</li>
<li>调用mmap<br>只是再进程空间中新增一块缓冲区，但没有建立进程空间到物理页面的映射。因此第一次访问这个空间时引发一次缺页异常</li>
<li>缺页异常处理<br>现在swapcache中找页面，要是没找到则看这个页面是不是在swaparea里，要是还没有就建立一个页面更新页表<br>对于普通文件映射情况则在pagecache里找页面</li>
<li>多进程映射同一个共享内存区域<br>建立线性地址与物理地址的映射后，进程实际访问的一定是同一个共享内存区域的物理页面</li>
</ol>
<p>使用mmap的两种共享内存方式</p>
<ol>
<li>使用普通文件提供的内存映射<ul>
<li>使用于任何进程</li>
<li>打开或创建一个文件，再调用mmap</li>
</ul>
</li>
<li>使用特殊文件创建匿名内存映射<ul>
<li>适用于有亲缘关系的进程</li>
<li>父进程先mmap再fork</li>
</ul>
</li>
</ol>
<p>Linux设备<br>字符设备，块设备，网络设备</p>
<p>设备文件与设备号<br>用户通过设备文件访问设备，每个设备用一个主设备号和次设备号标识</p>
<p>设备驱动的功能<br>管理IO设备<br>上层软件的抽象操作与设备操作的转换<br><img src="/2023/05/26/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%BB%85%E9%87%8D%E7%82%B9%E5%86%85%E5%AE%B9%EF%BC%89/5.png"><br>VFS是虚拟文件系统</p>
<p>内核模块<br>Linux内核运行时动态扩展的一种技术<br>Linux设备驱动以内核模块形式实现<br>一组可以加载&#x2F;卸载的代码</p>
<p>设备驱动的结构</p>
<ul>
<li>驱动与内核的接口<ul>
<li>注册&#x2F;卸载</li>
<li>VFS接口</li>
<li>数据交互</li>
<li>中断注册</li>
</ul>
</li>
<li>硬件设备接口<ul>
<li>硬件探测</li>
<li>初始化</li>
<li>读写访问</li>
<li>设备控制</li>
</ul>
</li>
</ul>
<p><img src="/2023/05/26/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%BB%85%E9%87%8D%E7%82%B9%E5%86%85%E5%AE%B9%EF%BC%89/6.png"></p>
<p>Linux数据包接受过程<br>物理层-&gt;链路层-&gt;网络层-&gt;传输层</p>
<p>TCP&#x2F;IP与以太网<br>以太网和TCP&#x2F;IP可以说是相辅相成的<br>以太网提供MAC地址连线<br>TCP&#x2F;IP提供32位IP地址</p>
<p>载波监听，冲突检测</p>
<p>以太网的广播通讯<br>在以太网中，所有的通讯都是广播的<br>通常在同一个网段的所有网络接口都可以访问在物理媒体上传输的所有数据</p>
<p>网卡的MAC地址是唯一的48位</p>
<p>网络接口应该响应的两种数据帧</p>
<ul>
<li>与自己MAC匹配的数据帧</li>
<li>广播数据帧</li>
</ul>
<p>数据接受过程</p>
<ol>
<li>网卡收到数据，单片程序判断自己是否该收</li>
<li>若该收则向CPU中断，然后把包给驱动程序分析，驱动程序分析完将数据交付操作系统</li>
<li>若不该收则直接丢弃，CPU根本不知道</li>
</ol>
<p>网卡的四种接收模式：</p>
<ol>
<li>广播模式：能接受网络中广播信息</li>
<li>组播模式：网卡能接收组播数据</li>
<li>直接模式：只有目的网卡能接受数据</li>
<li>混杂模式：能接受一切通过他的数据</li>
</ol>
<h3 id="Libpcap"><a href="#Libpcap" class="headerlink" title="Libpcap"></a>Libpcap</h3><p>不是很重点</p>
<p>Libpcap (Packet Capture library)，即数据包捕获函数库，可用于捕获经过网络接口(只要经过该接口，目标地址不一定为本机)的数据包，采用libpcap可以捕获本地网络数据链路层上的数据</p>
<p>基于BPF系统<br>BPF主要由两部分组成：Network tap和Packet Filter</p>
<h3 id="Libnet"><a href="#Libnet" class="headerlink" title="Libnet"></a>Libnet</h3><p>libnet提供的接口函数主要用于实现数据包的构造和发送<br>libpcap提供的接口函数主要用于实现数据包截获(接收)<br>libnids提供的接口函数主要实现了开发网络入侵监测系统(nids)所必须的一些结构框架<br>libicmp封装的是ICMP数据包的主要处理过程(构造、发送、接收等)</p>
<p>Libnet概述<br>功能:数据包构造和发送<br>可以不用程序员去整解析报文啥的，可以方便快速简单的完成报文组装工作</p>
<h3 id="Libnids"><a href="#Libnids" class="headerlink" title="Libnids"></a>Libnids</h3><p>在libnet和libpcap的基础上开发的，封装了开发NIDS所需的许多通用型函数<br>linids提供的接口函数监视流经本地的所有网络通 信，检查数据包等</p>
<p>Libnids原理，一个大图</p>
<p><img src="/2023/05/26/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%BB%85%E9%87%8D%E7%82%B9%E5%86%85%E5%AE%B9%EF%BC%89/7.png"></p>
<p>libnids的每级回调函数可以是多个<br>    可以有多个ip&#x2F;tcp&#x2F;udp_callback<br>libnids的IP回调函数已经进行分片重组<br>    ip_callback不会存在ip分片</p>
<p>数据结构<br>tuple4：用于描述一个地址端口对，它表示发送方IP和端口以及接收方IP和端口<br>half_stream：此数据结构用来描述在tcp连接中一端的所有信息，可以使客户端也可以是服务端<br>tcp_stream:描述的是一个TCP连接的所有信息</p>
<p><img src="/2023/05/26/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%BB%85%E9%87%8D%E7%82%B9%E5%86%85%E5%AE%B9%EF%BC%89/8.png"></p>
<p>开发示例<br>jflow，tcp.c</p>
<h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1><h2 id="串匹配概念"><a href="#串匹配概念" class="headerlink" title="串匹配概念"></a>串匹配概念</h2><p>尤其是信息检索和生物计算领域中的许多共同需求</p>
<ol>
<li>文本：由若干个字符组成的有限序列</li>
<li>模式：也称为关键字，由若干个字符组成的有限序列</li>
<li>模式集：指所有需要匹配的模式形成的集合</li>
<li>最小模式长度：假设模式集中各个模式长度分别为l1,l2,…lr,那么最小模式长度是指所有模式长度的最小值</li>
<li>前缀：两个字符串 p和x，若存在字符串v（v可为空串），使得p&#x3D;xv成立，称x为p的前缀</li>
<li>后缀：两个字符串p和x,若存在字符串u（u可为空串）,使得p&#x3D;ux成立，称x为p的后缀</li>
<li>子串：两个字符串p和x,若存在字符串u,v（u,v可以为空串），使得p&#x3D;uxv成立，称x为p的子串</li>
<li>字符集：在模式或文本中所有可能出现的字符形成的集合，记为Σ ，其大小记为|Σ|。</li>
</ol>
<p>单模匹配<br>在一个文本text(设长度为n)中查找某个特定的子串pattern(设长度为m)。如果在text中找到等于pattern的子串，则称匹配成功，函数返回pattern在text中出现的位置(或序号)，否则匹配失败</p>
<p>多模匹配<br>在一个文本text(设长度为n)中查找某些特定的子串patterns(设长度为m)。如果在text中找到等于patterns中的某些子串，则称匹配成功，函数返回pattern在text中出现的位置(或序号)，否则匹配失败</p>
<h3 id="BF算法"><a href="#BF算法" class="headerlink" title="BF算法"></a>BF算法</h3><p>简单，时间复杂度差</p>
<h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><p>KMP算法根据前缀模式可以使模式向前推进若干字符位置（依前缀模式长度而定），而不只是一个字符，避免了重复比较，同时也实现了文本指针的无回朔</p>
<p>“前缀”指除了最后一个字符以外，一个字符串的全部头部组合</p>
<p>移动位数 &#x3D; 已匹配的字符数 - 对应的部分匹配值</p>
<h4 id="next数组求解方法"><a href="#next数组求解方法" class="headerlink" title="next数组求解方法"></a>next数组求解方法</h4><p>第一位的next值为0，第二位的next值为1，后面求解每一位的next值时，根据前一位进行比较。<br>首先将前一位与其next值对应的内容进行比较，如果相等，则该位的next值就是前一位的next值加上1；如果不等，向前继续寻找next值对应的内容来与前一位进行比较，直到找到某个位上内容的next值对应的内容与前一位相等为止，则这个位对应的值加上1即为需求的next值；如果找到第一位都没有找到与前一位相等的内容，那么需求的位上的next值即为1</p>
<p>KMPnext可以把next中全部减一，如果当前位于首位相同还能再减一<br>每次不匹配时可以右移i-kmpNext[i]位</p>
<h3 id="BM"><a href="#BM" class="headerlink" title="BM"></a>BM</h3><p>速度最快算法<br>算法对模式从最右端自右向左扫描。在不匹配（或完全匹配）时，用两个预先计算的函数bad character和good suffix 来确定指针在正文中移动的距离</p>
<p>只要尾部不匹配，则在模式串中找一样的坏字符对齐，否则将整个匹配串移到坏字符后面<br>后移位数 &#x3D; 坏字符的位置 - 搜索词中的上一次出现位置<br>如果”坏字符”不包含在搜索词之中，则上一次出现位置为 -1<br>后移位数 &#x3D; 好后缀的位置 - 搜索词中的上一次出现位置<br>如果”好后缀”在搜索词中没有重复出现，则它的上一次出现位置为 -1</p>
<p>移动是坏字符和好后缀的最大值</p>
<p>计算出<strong>字符集</strong>中每个字符的偏移值bmBC[i],对于未在模式中出现的字符，偏移为m,否则取m-i-1,(其中i为字符在模式中的位置)</p>
<p>我是真没看懂那两个东西是咋算的</p>
<h3 id="AC算法"><a href="#AC算法" class="headerlink" title="AC算法"></a>AC算法</h3><p>多模式匹配问题在生物计算、信息检索及信号处理领域有着非常广泛的应用</p>
<p>自动机（Automata）：确定型有限自动机DFA(Deterministic finite automata)是一个五元组M &#x3D; {S,Σ,δ,s0,S1}</p>
<ol>
<li>拆分关键字，生成状态图</li>
<li>使用状态机</li>
</ol>
<p>时间复杂度为O(n)</p>
<h3 id="树形有限自动机"><a href="#树形有限自动机" class="headerlink" title="树形有限自动机"></a>树形有限自动机</h3><p><img src="/2023/05/26/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%BB%85%E9%87%8D%E7%82%B9%E5%86%85%E5%AE%B9%EF%BC%89/9.png"></p>
<h1 id="笔记-考点"><a href="#笔记-考点" class="headerlink" title="笔记-考点"></a>笔记-考点</h1><p><img src="/2023/05/26/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%BB%85%E9%87%8D%E7%82%B9%E5%86%85%E5%AE%B9%EF%BC%89/1.png"></p>
]]></content>
      <categories>
        <category>学习资料</category>
      </categories>
  </entry>
  <entry>
    <title>不断进化的弹幕游戏</title>
    <url>/2023/03/13/%E4%B8%8D%E6%96%AD%E8%BF%9B%E5%8C%96%E7%9A%84%E5%BC%B9%E5%B9%95%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h1 id="2021年春季版本"><a href="#2021年春季版本" class="headerlink" title="2021年春季版本"></a>2021年春季版本</h1><p>没啥新奇的主要就是一个队列结构，然后遍历输出在屏幕上，可以作为大作业？想要的话给我留个言拿走，或者你悄悄拿走别让我发现。</p>
<p>我中传hxd拿这玩意当c++作业交了，作业满分</p>
<p>我当年居然把这个类名叫做东方，都大学了才开始中二是吧byd</p>
<p>难度随时间增加，但不是线性的，15s，20s，25s有三个坎（好像是）</p>
<p>坚持30s胜利</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Bullets</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//光标移动到指定坐标处</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">gotoxy</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HANDLE h;<span class="comment">//句柄,对象的索引</span></span><br><span class="line">	COORD c;<span class="comment">//结构体,坐标值</span></span><br><span class="line">	c.X = x;</span><br><span class="line">	c.Y = y;</span><br><span class="line">	h = <span class="built_in">GetStdHandle</span>(STD_OUTPUT_HANDLE);</span><br><span class="line">	<span class="built_in">SetConsoleCursorPosition</span>(h, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//隐藏光标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hide_cursor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HANDLE	h_GAME = <span class="built_in">GetStdHandle</span>(STD_OUTPUT_HANDLE);</span><br><span class="line">	CONSOLE_CURSOR_INFO cursor_info;</span><br><span class="line">	<span class="built_in">GetConsoleCursorInfo</span>(h_GAME, &amp;cursor_info);</span><br><span class="line">	cursor_info.bVisible = <span class="literal">false</span>;					<span class="comment">//不显示光标</span></span><br><span class="line">	<span class="built_in">SetConsoleCursorInfo</span>(h_GAME, &amp;cursor_info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示光标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_cursor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HANDLE	h_GAME = <span class="built_in">GetStdHandle</span>(STD_OUTPUT_HANDLE);</span><br><span class="line">	CONSOLE_CURSOR_INFO cursor_info;</span><br><span class="line">	<span class="built_in">GetConsoleCursorInfo</span>(h_GAME, &amp;cursor_info);</span><br><span class="line">	cursor_info.bVisible = <span class="literal">true</span>;					<span class="comment">//显示光标</span></span><br><span class="line">	<span class="built_in">SetConsoleCursorInfo</span>(h_GAME, &amp;cursor_info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置文本颜色</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">color</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">SetConsoleTextAttribute</span>(<span class="built_in">GetStdHandle</span>(STD_OUTPUT_HANDLE), a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">touhou</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">clock_t</span> player_move, bullets_above_1, bullets_left_1, bullets_right_1, t1, RAM, <span class="type">create_t</span>;</span><br><span class="line">	<span class="type">int</span> player_x, player_y, level, ram;</span><br><span class="line">	<span class="type">double</span> n;</span><br><span class="line">	list&lt;Bullets&gt; above_1, left_1,right_1;</span><br><span class="line">	list&lt;Bullets&gt;::iterator p1, p2, p3;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">touhou</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		level=<span class="number">400</span>;</span><br><span class="line">		n = <span class="number">0</span>;</span><br><span class="line">		player_x = <span class="number">36</span>; player_y = <span class="number">10</span>;</span><br><span class="line">		player_move = <span class="built_in">clock</span>();</span><br><span class="line">		RAM = <span class="built_in">clock</span>();</span><br><span class="line">		bullets_above_1 = <span class="built_in">clock</span>();</span><br><span class="line">		bullets_left_1 = <span class="built_in">clock</span>();</span><br><span class="line">		t1 = <span class="built_in">clock</span>();</span><br><span class="line">		<span class="built_in">hide_cursor</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(<span class="type">int</span> erase_x, <span class="type">int</span> erase_y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">gotoxy</span>(erase_x, erase_y);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">player_draw</span><span class="params">(<span class="type">int</span> draw_x, <span class="type">int</span> draw_y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">gotoxy</span>(draw_x, draw_y);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;∧&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">bullets_draw_vertical</span><span class="params">(<span class="type">int</span> bullets_draw_x, <span class="type">int</span> bullets_draw_y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">gotoxy</span>(bullets_draw_x, bullets_draw_y);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;┇&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">bullets_draw_horizontal</span><span class="params">(<span class="type">int</span> bullets_draw_x, <span class="type">int</span> bullets_draw_y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">gotoxy</span>(bullets_draw_x, bullets_draw_y);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;┅&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">time</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">gotoxy</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">clock</span>() - t1 &gt; <span class="number">100</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			n += <span class="number">0.1</span>;</span><br><span class="line">			cout &lt;&lt; n;</span><br><span class="line">			t1 = <span class="built_in">clock</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(n&gt;<span class="number">10</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			level=<span class="number">200</span>;</span><br><span class="line">			<span class="keyword">if</span>(n&gt;<span class="number">20</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				level=<span class="number">100</span>;</span><br><span class="line">				<span class="keyword">if</span>(n&gt;<span class="number">25</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					level=<span class="number">50</span>;</span><br><span class="line">					<span class="keyword">if</span>(n&gt;<span class="number">30</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">						<span class="built_in">gotoxy</span>(<span class="number">20</span>,<span class="number">10</span>);</span><br><span class="line">						cout&lt;&lt;<span class="string">&quot;gameclear!&quot;</span>;</span><br><span class="line">						<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">						<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Player_move</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">clock</span>() - player_move &gt; <span class="number">50</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">erase</span>(player_x, player_y);</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">GetAsyncKeyState</span>(VK_ESCAPE))<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">GetAsyncKeyState</span>(VK_UP))--player_y;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">GetAsyncKeyState</span>(VK_DOWN))++player_y;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">GetAsyncKeyState</span>(VK_LEFT))--player_x;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">GetAsyncKeyState</span>(VK_RIGHT))++player_x;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">GetAsyncKeyState</span>(VK_LSHIFT))n=<span class="number">30</span>;</span><br><span class="line">			<span class="keyword">if</span> (player_x &gt; <span class="number">72</span>) player_x = <span class="number">72</span>;</span><br><span class="line">			<span class="keyword">if</span> (player_y &gt; <span class="number">24</span>) player_y = <span class="number">24</span>;</span><br><span class="line">			<span class="keyword">if</span> (player_x &lt; <span class="number">0</span>) player_x = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (player_y &lt; <span class="number">0</span>) player_y = <span class="number">0</span>;</span><br><span class="line">			<span class="built_in">player_draw</span>(player_x, player_y);</span><br><span class="line">			player_move = <span class="built_in">clock</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">RAM_t</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">clock</span>() - RAM &gt; <span class="number">200</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			ram = <span class="built_in">rand</span>() % <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">			RAM = <span class="built_in">clock</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">create</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">clock</span>() - <span class="type">create_t</span> &gt; level)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> ram_x = <span class="built_in">rand</span>() % <span class="number">75</span> + <span class="number">1</span>, ram_y = <span class="built_in">rand</span>() % <span class="number">24</span> + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (ram == <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				Bullets bullet;</span><br><span class="line">				bullet.x = ram_x;</span><br><span class="line">				bullet.y = <span class="number">0</span>;</span><br><span class="line">				above_1.<span class="built_in">push_back</span>(bullet);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (ram == <span class="number">2</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				Bullets bullet;</span><br><span class="line">				bullet.x = <span class="number">0</span>;</span><br><span class="line">				bullet.y = ram_y;</span><br><span class="line">				left_1.<span class="built_in">push_back</span>(bullet);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (ram == <span class="number">3</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				Bullets bullet;</span><br><span class="line">				bullet.x = <span class="number">72</span>;</span><br><span class="line">				bullet.y = ram_y;</span><br><span class="line">				right_1.<span class="built_in">push_back</span>(bullet);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">create_t</span> = <span class="built_in">clock</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">bullets_above_1_move</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">clock</span>() - bullets_above_1 &gt; <span class="number">50</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (p1 = above_1.<span class="built_in">begin</span>(); p1 != above_1.<span class="built_in">end</span>();)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">erase</span>(p1-&gt;x, p1-&gt;y);</span><br><span class="line">				++p1-&gt;y;</span><br><span class="line">				<span class="keyword">if</span> (p1-&gt;y &gt; <span class="number">24</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					p1 = above_1.<span class="built_in">erase</span>(p1);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">bullets_draw_vertical</span>(p1-&gt;x, p1-&gt;y);</span><br><span class="line">					<span class="keyword">if</span> (<span class="built_in">abs</span>(player_x - p1-&gt;x) &lt; <span class="number">1</span> &amp;&amp; player_y == p1-&gt;y)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">						<span class="built_in">gotoxy</span>(<span class="number">20</span>,<span class="number">10</span>);</span><br><span class="line">						cout &lt;&lt; <span class="string">&quot;gameover!&quot;</span>;</span><br><span class="line">						<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">						<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					++p1;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			bullets_above_1 = <span class="built_in">clock</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">bullets_left_1_move</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">clock</span>() - bullets_left_1 &gt; <span class="number">50</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (p2 = left_1.<span class="built_in">begin</span>(); p2 != left_1.<span class="built_in">end</span>();)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">erase</span>(p2-&gt;x, p2-&gt;y);</span><br><span class="line">				p2-&gt;x = p2-&gt;x + <span class="number">2</span>;</span><br><span class="line">				<span class="keyword">if</span> (p2-&gt;x &gt; <span class="number">72</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					p2 = left_1.<span class="built_in">erase</span>(p2);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">bullets_draw_horizontal</span>(p2-&gt;x, p2-&gt;y);</span><br><span class="line">					<span class="keyword">if</span> (player_x == p2-&gt;x&amp;&amp;<span class="built_in">abs</span>(player_y - p2-&gt;y) &lt; <span class="number">1</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">						<span class="built_in">gotoxy</span>(<span class="number">20</span>,<span class="number">10</span>);</span><br><span class="line">						cout &lt;&lt; <span class="string">&quot;gameover!&quot;</span>;</span><br><span class="line">						<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">						<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					++p2;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			bullets_left_1 = <span class="built_in">clock</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">bullets_right_1_move</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">clock</span>() - bullets_right_1 &gt; <span class="number">50</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (p3 = right_1.<span class="built_in">begin</span>(); p3 != right_1.<span class="built_in">end</span>();)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">erase</span>(p3-&gt;x, p3-&gt;y);</span><br><span class="line">				p3-&gt;x = p3-&gt;x - <span class="number">2</span>;</span><br><span class="line">				<span class="keyword">if</span> (p3-&gt;x &lt;<span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					p3 = right_1.<span class="built_in">erase</span>(p3);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">bullets_draw_horizontal</span>(p3-&gt;x, p3-&gt;y);</span><br><span class="line">					<span class="keyword">if</span> (player_x == p3-&gt;x&amp;&amp;<span class="built_in">abs</span>(player_y - p3-&gt;y) &lt; <span class="number">1</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">						<span class="built_in">gotoxy</span>(<span class="number">20</span>,<span class="number">10</span>);</span><br><span class="line">						cout &lt;&lt; <span class="string">&quot;gameover!&quot;</span>;</span><br><span class="line">						<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">						<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					++p3;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			bullets_right_1 = <span class="built_in">clock</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">main_control</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">Player_move</span>();</span><br><span class="line">			<span class="built_in">time</span>();</span><br><span class="line">			<span class="built_in">RAM_t</span>();</span><br><span class="line">			<span class="built_in">create</span>();</span><br><span class="line">			<span class="built_in">bullets_above_1_move</span>();</span><br><span class="line">			<span class="built_in">bullets_left_1_move</span>();</span><br><span class="line">			<span class="built_in">bullets_right_1_move</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">touhou</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">show_cursor</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">	touhou play;</span><br><span class="line">	play.<span class="built_in">main_control</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2021年秋季-VS版本弹幕游戏"><a href="#2021年秋季-VS版本弹幕游戏" class="headerlink" title="2021年秋季 VS版本弹幕游戏"></a>2021年秋季 VS版本弹幕游戏</h1><p>这个主要逻辑跟上面那个版本一样，但是这个我是真拿他当大作业交了</p>
<p>用了vs的一个MSF库好像叫，一个图形界面的库，但是让我强行高刷当游戏界面使了（悲）</p>
<p>下面是vs代码最主要的结构，资源啥的我不知道有没有，大概直接把代码拷过去再稍微调试一下就行</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 弹幕游戏View.cpp: C弹幕游戏View 类的实现</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;framework.h&quot;</span></span></span><br><span class="line"><span class="comment">// SHARED_HANDLERS 可以在实现预览、缩略图和搜索筛选器句柄的</span></span><br><span class="line"><span class="comment">// ATL 项目中进行定义，并允许与该项目共享文档代码。</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SHARED_HANDLERS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;弹幕游戏.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;弹幕游戏Doc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;弹幕游戏View.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> new DEBUG_NEW</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> tt = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C弹幕游戏View</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">IMPLEMENT_DYNCREATE</span>(C弹幕游戏View, CView)</span><br><span class="line"></span><br><span class="line"><span class="built_in">BEGIN_MESSAGE_MAP</span>(C弹幕游戏View, CView)</span><br><span class="line">	<span class="comment">// 标准打印命令</span></span><br><span class="line">	<span class="built_in">ON_COMMAND</span>(ID_FILE_PRINT, &amp;CView::OnFilePrint)</span><br><span class="line">	<span class="built_in">ON_COMMAND</span>(ID_FILE_PRINT_DIRECT, &amp;CView::OnFilePrint)</span><br><span class="line">	<span class="built_in">ON_COMMAND</span>(ID_FILE_PRINT_PREVIEW, &amp;CView::OnFilePrintPreview)</span><br><span class="line">	<span class="built_in">ON_WM_KEYDOWN</span>()</span><br><span class="line">	<span class="built_in">ON_WM_TIMER</span>()</span><br><span class="line">	<span class="built_in">ON_WM_KEYUP</span>()</span><br><span class="line">	<span class="built_in">ON_COMMAND</span>(ID_start, &amp;C弹幕游戏View::Onstart)</span><br><span class="line">	<span class="built_in">ON_WM_CREATE</span>()</span><br><span class="line">	<span class="built_in">ON_COMMAND</span>(ID_stop, &amp;C弹幕游戏View::Onstop)</span><br><span class="line"><span class="built_in">END_MESSAGE_MAP</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// C弹幕游戏View 构造/析构</span></span><br><span class="line"></span><br><span class="line">C弹幕游戏View::C弹幕游戏<span class="built_in">View</span>() <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> 在此处添加构造代码</span></span><br><span class="line">	level = <span class="number">150</span>;</span><br><span class="line">	n = <span class="number">0</span>;</span><br><span class="line">	player_x = <span class="number">300</span>; player_y = <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">C弹幕游戏View::~C弹幕游戏<span class="built_in">View</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL C弹幕游戏View::<span class="built_in">PreCreateWindow</span>(CREATESTRUCT&amp; cs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> 在此处通过修改</span></span><br><span class="line">	<span class="comment">//  CREATESTRUCT cs 来修改窗口类或样式</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> CView::<span class="built_in">PreCreateWindow</span>(cs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C弹幕游戏View 绘图</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> C弹幕游戏View::<span class="built_in">OnDraw</span>(CDC* <span class="comment">/*pDC*/</span>)</span><br><span class="line">&#123;</span><br><span class="line">	C弹幕游戏Doc* pDoc = <span class="built_in">GetDocument</span>();</span><br><span class="line">	<span class="built_in">ASSERT_VALID</span>(pDoc);</span><br><span class="line">	<span class="keyword">if</span> (!pDoc)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">player_draw</span>();</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> 在此处为本机数据添加绘制代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// C弹幕游戏View 打印</span></span><br><span class="line"></span><br><span class="line">BOOL C弹幕游戏View::<span class="built_in">OnPreparePrinting</span>(CPrintInfo* pInfo)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 默认准备</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">DoPreparePrinting</span>(pInfo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> C弹幕游戏View::<span class="built_in">OnBeginPrinting</span>(CDC* <span class="comment">/*pDC*/</span>, CPrintInfo* <span class="comment">/*pInfo*/</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> 添加额外的打印前进行的初始化过程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> C弹幕游戏View::<span class="built_in">OnEndPrinting</span>(CDC* <span class="comment">/*pDC*/</span>, CPrintInfo* <span class="comment">/*pInfo*/</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> 添加打印后进行的清理过程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// C弹幕游戏View 诊断</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG</span></span><br><span class="line"><span class="type">void</span> C弹幕游戏View::<span class="built_in">AssertValid</span>() <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	CView::<span class="built_in">AssertValid</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> C弹幕游戏View::<span class="built_in">Dump</span>(CDumpContext&amp; dc) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	CView::<span class="built_in">Dump</span>(dc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">C弹幕游戏Doc* C弹幕游戏View::<span class="built_in">GetDocument</span>() <span class="type">const</span> <span class="comment">// 非调试版本是内联的</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">ASSERT</span>(m_pDocument-&gt;<span class="built_in">IsKindOf</span>(<span class="built_in">RUNTIME_CLASS</span>(C弹幕游戏Doc)));</span><br><span class="line">	<span class="keyword">return</span> (C弹幕游戏Doc*)m_pDocument;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//_DEBUG</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// C弹幕游戏View 消息处理程序</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> C弹幕游戏View::<span class="built_in">player_draw</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">CClientDC <span class="title">dc</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">	CPen* pen = <span class="keyword">new</span> <span class="built_in">CPen</span>(PS_SOLID, <span class="number">0</span>, <span class="built_in">RGB</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>));</span><br><span class="line">	CBrush* brush = <span class="keyword">new</span> <span class="built_in">CBrush</span>(<span class="built_in">RGB</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">	dc.<span class="built_in">SelectObject</span>(pen);</span><br><span class="line">	dc.<span class="built_in">SelectObject</span>(brush);</span><br><span class="line">	dc.<span class="built_in">Ellipse</span>(player_x<span class="number">-5</span>, player_y<span class="number">-10</span>, player_x + <span class="number">5</span>, player_y + <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> C弹幕游戏View::<span class="built_in">OnKeyDown</span>(UINT nChar, UINT nRepCnt, UINT nFlags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">switch</span> (nChar)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> VK_ESCAPE:ESC = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> VK_UP:UP = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> VK_DOWN:DOWN = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> VK_LEFT:LEFT = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> VK_RIGHT:RIGHT = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> VK_SPACE :SPACE = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	CView::<span class="built_in">OnKeyDown</span>(nChar, nRepCnt, nFlags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> C弹幕游戏View::<span class="built_in">OnTimer</span>(UINT_PTR nIDEvent)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">CClientDC <span class="title">dc</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">	CPen* pen = <span class="keyword">new</span> <span class="built_in">CPen</span>(PS_SOLID, <span class="number">0</span>, <span class="built_in">RGB</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>));</span><br><span class="line">	CBrush* brush = <span class="keyword">new</span> <span class="built_in">CBrush</span>(<span class="built_in">RGB</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>));</span><br><span class="line">	dc.<span class="built_in">SelectObject</span>(pen);</span><br><span class="line">	dc.<span class="built_in">SelectObject</span>(brush);</span><br><span class="line">	CString c;</span><br><span class="line">	<span class="keyword">if</span> (nIDEvent == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (ESC == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (UP == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			player_y = player_y - <span class="number">5</span>; <span class="keyword">if</span> (player_y &lt; <span class="number">0</span>)player_y = <span class="number">0</span>; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (DOWN == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			player_y = player_y + <span class="number">5</span>; <span class="keyword">if</span> (player_y &gt; <span class="number">400</span>)player_y = <span class="number">400</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (LEFT == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			player_x = player_x - <span class="number">5</span>; <span class="keyword">if</span> (player_x &lt; <span class="number">0</span>)player_x = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (RIGHT == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			player_x = player_x + <span class="number">5</span>; <span class="keyword">if</span> (player_x &gt; <span class="number">600</span>)player_x = <span class="number">600</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (SPACE == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			dc.<span class="built_in">TextOutW</span>(<span class="number">700</span>, <span class="number">200</span>, _T(<span class="string">&quot;gameclear!&quot;</span>));</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (nIDEvent == <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> ram_x = <span class="built_in">rand</span>() % <span class="number">600</span> + <span class="number">1</span>, ram_y = <span class="built_in">rand</span>() % <span class="number">400</span> + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (ram == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			bullets bullet;</span><br><span class="line">			bullet.x = ram_x;</span><br><span class="line">			bullet.y = <span class="number">0</span>;</span><br><span class="line">			above_1.<span class="built_in">push_back</span>(bullet);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (ram == <span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			bullets bullet;</span><br><span class="line">			bullet.x = <span class="number">0</span>;</span><br><span class="line">			bullet.y = ram_y;</span><br><span class="line">			left_1.<span class="built_in">push_back</span>(bullet);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (ram == <span class="number">3</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			bullets bullet;</span><br><span class="line">			bullet.x = <span class="number">600</span>;</span><br><span class="line">			bullet.y = ram_y;</span><br><span class="line">			right_1.<span class="built_in">push_back</span>(bullet);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (nIDEvent == <span class="number">3</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (p1 = above_1.<span class="built_in">begin</span>(); p1 != above_1.<span class="built_in">end</span>();)</span><br><span class="line">		&#123;</span><br><span class="line">			p1-&gt;y = p1-&gt;y + <span class="number">5</span>;</span><br><span class="line">			dc.<span class="built_in">Ellipse</span>(p1-&gt;x - <span class="number">5</span>, p1-&gt;y - <span class="number">10</span>, p1-&gt;x + <span class="number">5</span>, p1-&gt;y + <span class="number">10</span>);</span><br><span class="line">			<span class="keyword">if</span> (p1-&gt;y &gt; <span class="number">400</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				p1 = above_1.<span class="built_in">erase</span>(p1);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">abs</span>(player_x - p1-&gt;x)&lt;<span class="number">5</span> &amp;&amp; <span class="built_in">abs</span>(player_y - p1-&gt;y)&lt;<span class="number">10</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					dc.<span class="built_in">TextOutW</span>(<span class="number">700</span>, <span class="number">200</span>, _T(<span class="string">&quot;gameover!&quot;</span>));</span><br><span class="line">					<span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line">					<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				++p1;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (nIDEvent == <span class="number">4</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (p2 = left_1.<span class="built_in">begin</span>(); p2 != left_1.<span class="built_in">end</span>();)</span><br><span class="line">		&#123;</span><br><span class="line">			p2-&gt;x = p2-&gt;x + <span class="number">7</span>;</span><br><span class="line">			dc.<span class="built_in">Ellipse</span>(p2-&gt;x - <span class="number">10</span>, p2-&gt;y - <span class="number">5</span>, p2-&gt;x + <span class="number">10</span>, p2-&gt;y + <span class="number">5</span>);</span><br><span class="line">			<span class="keyword">if</span> (p2-&gt;x &gt; <span class="number">600</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				p2 = left_1.<span class="built_in">erase</span>(p2);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">abs</span>(player_x - p2-&gt;x) &lt; <span class="number">10</span> &amp;&amp; <span class="built_in">abs</span>(player_y - p2-&gt;y) &lt; <span class="number">5</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					dc.<span class="built_in">TextOutW</span>(<span class="number">700</span>, <span class="number">200</span>, _T(<span class="string">&quot;gameover!&quot;</span>));</span><br><span class="line">					<span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line">					<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				++p2;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (nIDEvent == <span class="number">5</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (p3 = right_1.<span class="built_in">begin</span>(); p3 != right_1.<span class="built_in">end</span>();)</span><br><span class="line">		&#123;</span><br><span class="line">			p3-&gt;x = p3-&gt;x - <span class="number">7</span>;</span><br><span class="line">			dc.<span class="built_in">Ellipse</span>(p3-&gt;x - <span class="number">10</span>, p3-&gt;y - <span class="number">5</span>, p3-&gt;x + <span class="number">10</span>, p3-&gt;y + <span class="number">5</span>);</span><br><span class="line">			<span class="keyword">if</span> (p3-&gt;x &lt; <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				p3 = right_1.<span class="built_in">erase</span>(p3);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">abs</span>(player_x - p3-&gt;x) &lt; <span class="number">10</span> &amp;&amp; <span class="built_in">abs</span>(player_y - p3-&gt;y) &lt; <span class="number">5</span>)</span><br><span class="line">				&#123;</span><br><span class="line">						dc.<span class="built_in">TextOutW</span>(<span class="number">700</span>, <span class="number">200</span>, _T(<span class="string">&quot;gameover!&quot;</span>));</span><br><span class="line">						<span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line">						<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				++p3;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (nIDEvent == <span class="number">6</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		ram = <span class="built_in">rand</span>() % <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (nIDEvent == <span class="number">7</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		n += <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (nIDEvent == <span class="number">8</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">Invalidate</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (nIDEvent == <span class="number">9</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">CPen <span class="title">pen</span><span class="params">(PS_DOT, <span class="number">1</span>, RGB(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">		CPen *pOldPen = dc.<span class="built_in">SelectObject</span>(&amp;pen);</span><br><span class="line">		dc.<span class="built_in">MoveTo</span>(<span class="number">600</span>,<span class="number">0</span>);</span><br><span class="line">		dc.<span class="built_in">LineTo</span>(<span class="number">600</span>,<span class="number">400</span>);</span><br><span class="line">		dc.<span class="built_in">MoveTo</span>(<span class="number">600</span>, <span class="number">400</span>);</span><br><span class="line">		dc.<span class="built_in">LineTo</span>(<span class="number">0</span>, <span class="number">400</span>);</span><br><span class="line">		dc.<span class="built_in">SelectObject</span>(pOldPen);</span><br><span class="line">		n1 = n;</span><br><span class="line">		c.<span class="built_in">Format</span>(_T(<span class="string">&quot;%d&quot;</span>), n1);</span><br><span class="line">		dc.<span class="built_in">TextOutW</span>(<span class="number">700</span>, <span class="number">50</span>, c);</span><br><span class="line">		dc.<span class="built_in">TextOutW</span>(<span class="number">700</span>, <span class="number">100</span>, _T(<span class="string">&quot;坚持十秒即可胜利！&quot;</span>));</span><br><span class="line">		<span class="keyword">if</span> (n &gt;= <span class="number">9.9</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			dc.<span class="built_in">TextOutW</span>(<span class="number">700</span>, <span class="number">200</span>, _T(<span class="string">&quot;gameclear!&quot;</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (n &gt; <span class="number">10</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	CView::<span class="built_in">OnTimer</span>(nIDEvent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> C弹幕游戏View::<span class="built_in">OnKeyUp</span>(UINT nChar, UINT nRepCnt, UINT nFlags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">switch</span> (nChar)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> VK_UP:UP=<span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> VK_DOWN:DOWN=<span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> VK_LEFT:LEFT=<span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> VK_RIGHT:RIGHT=<span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	CView::<span class="built_in">OnKeyUp</span>(nChar, nRepCnt, nFlags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> C弹幕游戏View::<span class="built_in">Onstart</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">CClientDC <span class="title">dc</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">	dc.<span class="built_in">TextOutW</span>(<span class="number">700</span>, <span class="number">100</span>, _T(<span class="string">&quot;坚持十秒即可胜利！&quot;</span>));</span><br><span class="line">	<span class="built_in">SetTimer</span>(<span class="number">1</span>, tt, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">SetTimer</span>(<span class="number">2</span>, level, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">SetTimer</span>(<span class="number">3</span>, tt, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">SetTimer</span>(<span class="number">4</span>, tt, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">SetTimer</span>(<span class="number">5</span>, tt, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">SetTimer</span>(<span class="number">6</span>, <span class="number">200</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">SetTimer</span>(<span class="number">7</span>, <span class="number">1000</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">SetTimer</span>(<span class="number">8</span>, <span class="number">20</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">SetTimer</span>(<span class="number">9</span>, tt, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> C弹幕游戏View::<span class="built_in">gotoxy</span>(<span class="type">int</span> x, <span class="type">int</span> y)</span><br><span class="line">&#123;</span><br><span class="line">	HANDLE h;<span class="comment">//句柄,对象的索引</span></span><br><span class="line">	COORD c;<span class="comment">//结构体,坐标值</span></span><br><span class="line">	c.X = x;</span><br><span class="line">	c.Y = y;</span><br><span class="line">	h = <span class="built_in">GetStdHandle</span>(STD_OUTPUT_HANDLE);</span><br><span class="line">	<span class="built_in">SetConsoleCursorPosition</span>(h, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> C弹幕游戏View::<span class="built_in">OnCreate</span>(LPCREATESTRUCT lpCreateStruct)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (CView::<span class="built_in">OnCreate</span>(lpCreateStruct) == <span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="function">CClientDC <span class="title">dc</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> C弹幕游戏View::<span class="built_in">Onstop</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> 在此添加命令处理程序代码</span></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="3-2022最终版本-C-实现"><a href="#3-2022最终版本-C-实现" class="headerlink" title="3.2022最终版本 C++实现"></a>3.2022最终版本 C++实现</h1><p>这个版本有画面了，我称之为维度升级（但其实真实维度上并没有升级（悲））</p>
<p>直接上源码，但是没有资源，完事我再把exe给扔到github里，项目源码给我发消息可以给</p>
<p><img src="/2023/03/13/%E4%B8%8D%E6%96%AD%E8%BF%9B%E5%8C%96%E7%9A%84%E5%BC%B9%E5%B9%95%E6%B8%B8%E6%88%8F/1.png"></p>
<p><a href="https://github.com/Nonbliss/touhou-with-C-/tree/%E5%BC%B9%E5%B9%95%E6%B8%B8%E6%88%8F">https://github.com/Nonbliss/touhou-with-C-/tree/%E5%BC%B9%E5%B9%95%E6%B8%B8%E6%88%8F</a></p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">#include &lt;graphics.h&gt;</span><br><span class="line">#include &lt;conio.h&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;ctime&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line">#include <span class="string">&quot;resource.h&quot;</span></span><br><span class="line">#include &lt;mmsystem.h&gt;</span><br><span class="line"># pragma comment (lib, <span class="string">&quot;Winmm.lib&quot;</span>)</span><br><span class="line"></span><br><span class="line">#define Stagenumber <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象数据类型</span></span><br><span class="line">	<span class="comment">//队列</span></span><br><span class="line">typedef struct Qnode &#123;</span><br><span class="line">	int x;</span><br><span class="line">	int y;</span><br><span class="line">	int hit;</span><br><span class="line">	struct Qnode* next;</span><br><span class="line">&#125;*bullet;</span><br><span class="line"></span><br><span class="line">typedef struct Queue &#123;</span><br><span class="line">	bullet front;</span><br><span class="line">	bullet rear;</span><br><span class="line">&#125;bullets;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//栈</span></span><br><span class="line">typedef struct Snode &#123;</span><br><span class="line">	int health;</span><br><span class="line">	struct Snode* next;</span><br><span class="line">&#125;Snode,*Stack;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//图</span></span><br><span class="line">typedef struct arccell &#123;</span><br><span class="line">	int through;</span><br><span class="line">&#125;arc1,arcs[Stagenumber][Stagenumber];</span><br><span class="line"></span><br><span class="line">typedef struct vexs &#123;</span><br><span class="line">	int stage;</span><br><span class="line">	int boss_length, boss_width;</span><br><span class="line">	Stack boss_health;</span><br><span class="line">	int bullet_above_judge, bullet_left_judge, bullet_right_judge;</span><br><span class="line">	int boss_movement;</span><br><span class="line">&#125;Stage;</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">	Stage Stages[Stagenumber];</span><br><span class="line">	arcs Stage_through;</span><br><span class="line">&#125;Mgraph;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量</span></span><br><span class="line">int player_x=<span class="number">320</span>, player_y=<span class="number">280</span>,boss_x=<span class="number">320</span>,boss_y=<span class="number">100</span>,spawnlimit=<span class="number">1000</span>,bullet_above_speed=<span class="number">50</span>, </span><br><span class="line">	bullet_left_speed=<span class="number">50</span>, bullet_right_speed=<span class="number">50</span>, bullet_player_speed=<span class="number">50</span>,player_shoot_speed=<span class="number">400</span>,</span><br><span class="line">	way=<span class="number">0</span>,levelup_t=<span class="number">0</span>, levelup_s = <span class="number">0</span>,explode_s=<span class="number">0</span>,explode_t=<span class="number">0</span>,explode_x,explode_y;</span><br><span class="line">clock_t time1_t,player_move_t,draw_t,bullet_spawn1,bullet_spawn2,bullet_spawn3,</span><br><span class="line">	bullet_move1, bullet_move2, bullet_move3, bullet_move4, player_shoot_t,boss_move_s,boss_move_t,boss_move_q,stage_pass_t,time_draw_t,time_draw_s;</span><br><span class="line">IMAGE <span class="built_in">background</span>, plane, bullet_up, bullet_above, bullet_left, bullet_right, boss1, boss2, boss3, explode, explode_small, <span class="built_in">title</span>,start_button;</span><br><span class="line">bullets bullet_above_q, bullet_left_q, bullet_right_q,bullet_player_q;</span><br><span class="line">Mgraph map;</span><br><span class="line"><span class="comment">//用户可交互参数</span></span><br><span class="line">Stack player_health;</span><br><span class="line">int clear=<span class="number">0</span>,stagenum,difficulty,test1,score,level=<span class="number">0</span>;</span><br><span class="line">int clear_num=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">int InitQueue(bullets&amp; q)</span><br><span class="line">&#123;</span><br><span class="line">	q.front = q.rear = (bullet)malloc(sizeof(Qnode));</span><br><span class="line">	<span class="function"><span class="title">q</span>.front-&gt;</span>next = NULL;</span><br><span class="line">	<span class="keyword">if</span> (!q.front)</span><br><span class="line">		return <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		return <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void push(Stack&amp; s, int e)</span><br><span class="line">&#123;</span><br><span class="line">	Snode* p;</span><br><span class="line">	p = (Snode*)malloc(sizeof(Snode));</span><br><span class="line">	<span class="function"><span class="title">p</span>-&gt;</span>health = e;</span><br><span class="line">	<span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">next</span> = s-&gt;</span>next;</span><br><span class="line">	<span class="function"><span class="title">s</span>-&gt;</span>next = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int InitStack_boss(Stack&amp; s)</span><br><span class="line">&#123;</span><br><span class="line">	s = (Snode*)malloc(sizeof(Snode));</span><br><span class="line">	<span class="keyword">if</span> (!s)</span><br><span class="line">	&#123;</span><br><span class="line">		outtextxy(<span class="number">280</span>, <span class="number">280</span>, <span class="string">&quot;ERROR OCCURED!&quot;</span>);</span><br><span class="line">		Sleep(<span class="number">2000</span>);</span><br><span class="line">		exit(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="function"><span class="title">s</span>-&gt;</span>next = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void InitGraph(Mgraph&amp; m)</span><br><span class="line">&#123;</span><br><span class="line">	int i = rand() % <span class="number">2</span>,j=<span class="number">1</span>-i;</span><br><span class="line">	m.Stage_through[i][Stagenumber - <span class="number">1</span>].through = <span class="number">1</span>;</span><br><span class="line">	m.Stage_through[j][i].through = <span class="number">1</span>;</span><br><span class="line">	stagenum = j;</span><br><span class="line">	m.Stages[<span class="number">0</span>].stage = <span class="number">0</span>;</span><br><span class="line">	m.Stages[<span class="number">0</span>].boss_movement = <span class="number">0</span>;</span><br><span class="line">	m.Stages[<span class="number">0</span>].boss_length = <span class="number">90</span>;</span><br><span class="line">	m.Stages[<span class="number">0</span>].boss_width = <span class="number">30</span>;</span><br><span class="line">	m.Stages[<span class="number">0</span>].bullet_above_judge = <span class="number">1</span>;</span><br><span class="line">	m.Stages[<span class="number">0</span>].bullet_left_judge = <span class="number">0</span>;</span><br><span class="line">	m.Stages[<span class="number">0</span>].bullet_right_judge = <span class="number">0</span>;</span><br><span class="line">	InitStack_boss(m.Stages[<span class="number">0</span>].boss_health);</span><br><span class="line">	push(m.Stages[<span class="number">0</span>].boss_health, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i)</span><br><span class="line">		push(m.Stages[<span class="number">0</span>].boss_health, <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i)</span><br><span class="line">		push(m.Stages[<span class="number">0</span>].boss_health, <span class="number">1</span>);</span><br><span class="line">	m.Stages[<span class="number">1</span>].stage = <span class="number">1</span>;</span><br><span class="line">	m.Stages[<span class="number">1</span>].boss_movement = <span class="number">1</span>;</span><br><span class="line">	m.Stages[<span class="number">1</span>].boss_length = <span class="number">30</span>;</span><br><span class="line">	m.Stages[<span class="number">1</span>].boss_width = <span class="number">40</span>;</span><br><span class="line">	m.Stages[<span class="number">1</span>].bullet_above_judge = <span class="number">0</span>;</span><br><span class="line">	m.Stages[<span class="number">1</span>].bullet_left_judge = <span class="number">1</span>;</span><br><span class="line">	m.Stages[<span class="number">1</span>].bullet_right_judge = <span class="number">1</span>;</span><br><span class="line">	InitStack_boss(m.Stages[<span class="number">1</span>].boss_health);</span><br><span class="line">	push(m.Stages[<span class="number">1</span>].boss_health, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; ++i)</span><br><span class="line">		push(m.Stages[<span class="number">1</span>].boss_health, <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">		push(m.Stages[<span class="number">1</span>].boss_health, <span class="number">1</span>);</span><br><span class="line">	m.Stages[<span class="number">2</span>].stage = <span class="number">2</span>;</span><br><span class="line">	m.Stages[<span class="number">2</span>].boss_movement = <span class="number">3</span>;</span><br><span class="line">	m.Stages[<span class="number">2</span>].boss_length = <span class="number">50</span>;</span><br><span class="line">	m.Stages[<span class="number">2</span>].boss_width = <span class="number">50</span>;</span><br><span class="line">	m.Stages[<span class="number">2</span>].bullet_above_judge = <span class="number">1</span>;</span><br><span class="line">	m.Stages[<span class="number">2</span>].bullet_left_judge = <span class="number">1</span>;</span><br><span class="line">	m.Stages[<span class="number">2</span>].bullet_right_judge = <span class="number">1</span>;</span><br><span class="line">	InitStack_boss(m.Stages[<span class="number">2</span>].boss_health);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">15</span>; ++i)</span><br><span class="line">		push(m.Stages[<span class="number">2</span>].boss_health, <span class="number">3</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">15</span>; ++i)</span><br><span class="line">		push(m.Stages[<span class="number">2</span>].boss_health, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void push_player(Stack&amp; s)</span><br><span class="line">&#123;</span><br><span class="line">	Snode* p;</span><br><span class="line">	p = (Snode*)malloc(sizeof(Snode));</span><br><span class="line">	<span class="function"><span class="title">if</span> (s-&gt;</span>next == NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function"><span class="title">p</span>-&gt;</span>health = <span class="number">1</span>;</span><br><span class="line">		<span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">next</span> = s-&gt;</span>next;</span><br><span class="line">		<span class="function"><span class="title">s</span>-&gt;</span>next = p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">health</span> = s-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span>health+<span class="number">1</span>;</span><br><span class="line">		<span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">next</span> = s-&gt;</span>next;</span><br><span class="line">		<span class="function"><span class="title">s</span>-&gt;</span>next = p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void player_pop(Stack&amp; s)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="title">if</span> (s-&gt;</span>next != NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		Snode* p;</span><br><span class="line">		<span class="function"><span class="title">p</span> = s-&gt;</span>next;</span><br><span class="line">		<span class="function"><span class="title">s</span>-&gt;</span><span class="function"><span class="title">next</span> = p-&gt;</span>next;</span><br><span class="line">		free(p);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void gameover()</span><br><span class="line">&#123;</span><br><span class="line">	PlaySound(<span class="string">&quot;EXPLODE&quot;</span>, NULL, SND_FILENAME | SND_ASYNC);</span><br><span class="line">	putimage(<span class="number">0</span>, <span class="number">0</span>, &amp;<span class="built_in">background</span>);</span><br><span class="line">	putimage(player_x - <span class="number">50</span>, player_y - <span class="number">50</span>, &amp;explode);</span><br><span class="line">	outtextxy(<span class="number">270</span>, <span class="number">210</span>, <span class="string">&quot;GAMEOVER!&quot;</span>);</span><br><span class="line">	Sleep(<span class="number">3000</span>);</span><br><span class="line">	exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void gameclear()</span><br><span class="line">&#123;</span><br><span class="line">	putimage(<span class="number">0</span>, <span class="number">0</span>, &amp;<span class="built_in">background</span>);</span><br><span class="line">	outtextxy(<span class="number">270</span>, <span class="number">210</span>, <span class="string">&quot;GAMECLEAR!&quot;</span>);</span><br><span class="line">	outtextxy(<span class="number">250</span>, <span class="number">230</span>, <span class="string">&quot;CONGRATULATIONS!&quot;</span>);</span><br><span class="line">	Sleep(<span class="number">3000</span>);</span><br><span class="line">	exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void stage_pass()</span><br><span class="line">&#123;</span><br><span class="line">	stage_pass_t = clock();</span><br><span class="line">	<span class="keyword">while</span> (clock() - stage_pass_t &lt; <span class="number">2000</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		putimage(boss_x-<span class="number">50</span>, boss_y-<span class="number">50</span>, &amp;explode);</span><br><span class="line">		outtextxy(<span class="number">290</span>, <span class="number">210</span>, <span class="string">&quot;stage&quot;</span>);</span><br><span class="line">		char num[<span class="number">20</span>];</span><br><span class="line">		sprintf(num, <span class="string">&quot;%d&quot;</span>, clear_num);</span><br><span class="line">		outtextxy(<span class="number">300</span>, <span class="number">230</span>, num);</span><br><span class="line">		outtextxy(<span class="number">290</span>, <span class="number">250</span>, <span class="string">&quot;clear&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	stage_pass_t = clock();</span><br><span class="line">	clear_num++;</span><br><span class="line">	clearrectangle(<span class="number">290</span>, <span class="number">210</span>, <span class="number">330</span>, <span class="number">320</span>);</span><br><span class="line">	<span class="keyword">if</span> (clear_num == <span class="number">4</span>)</span><br><span class="line">		gameclear();</span><br><span class="line">	<span class="keyword">while</span> (clock() - stage_pass_t &lt; <span class="number">2000</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		outtextxy(<span class="number">280</span>, <span class="number">220</span>, <span class="string">&quot;stage&quot;</span>);</span><br><span class="line">		char num[<span class="number">20</span>];</span><br><span class="line">		sprintf(num, <span class="string">&quot;%d&quot;</span>, clear_num);</span><br><span class="line">		outtextxy(<span class="number">340</span>, <span class="number">220</span>, num);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void next_stage()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (clear == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		clear = <span class="number">0</span>;</span><br><span class="line">		stage_pass();</span><br><span class="line">		int i;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Stagenumber; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (map.Stage_through[stagenum][i].through == <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				stagenum = i;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void boss_pop(Stack&amp; s)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="title">if</span> (s-&gt;</span>next == NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		clear = <span class="number">1</span>;</span><br><span class="line">		next_stage();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		Snode* p;</span><br><span class="line">		<span class="function"><span class="title">p</span> = s-&gt;</span>next;</span><br><span class="line">		<span class="function"><span class="title">if</span> (p-&gt;</span>health == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			spawnlimit = <span class="number">1000</span>; bullet_above_speed = <span class="number">50</span>; bullet_left_speed = <span class="number">50</span>; bullet_right_speed = <span class="number">50</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="title">if</span> (p-&gt;</span>health == <span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			spawnlimit = <span class="number">500</span>; bullet_above_speed = <span class="number">40</span>; bullet_left_speed = <span class="number">40</span>; bullet_right_speed = <span class="number">40</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="title">if</span> (p-&gt;</span>health == <span class="number">3</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			spawnlimit = <span class="number">500</span>; bullet_above_speed = <span class="number">40</span>; bullet_left_speed = <span class="number">40</span>; bullet_right_speed = <span class="number">40</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="title">s</span>-&gt;</span><span class="function"><span class="title">next</span> = p-&gt;</span>next;</span><br><span class="line">		free(p);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bullet_explode()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (explode_s == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		putimage(explode_x - <span class="number">10</span>, explode_y - <span class="number">10</span>, &amp;explode_small);</span><br><span class="line">		explode_t++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (explode_t &gt; <span class="number">10</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		explode_s = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int boss_hit(int x,int y,int n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">abs</span>(x - boss_x) &lt; map.Stages[stagenum].boss_length / <span class="number">2</span> &amp;&amp; <span class="built_in">abs</span>(y - boss_y) &lt; map.Stages[stagenum].boss_width / <span class="number">2</span> &amp;&amp; n == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		PlaySound(<span class="string">&quot;EXPLODE&quot;</span>, NULL, SND_FILENAME | SND_ASYNC);</span><br><span class="line">		explode_x = x;</span><br><span class="line">		explode_y = y;</span><br><span class="line">		explode_s = <span class="number">1</span>;</span><br><span class="line">		boss_pop(map.Stages[stagenum].boss_health);</span><br><span class="line">		score += (score % <span class="number">3</span> + <span class="number">1</span>) * (rand() % <span class="number">50</span> + <span class="number">50</span>);</span><br><span class="line">		return <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		return <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		return <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int player_hit(int x, int y,int n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">abs</span>(x-player_x)&lt;<span class="number">8</span> &amp;&amp; <span class="built_in">abs</span>(y-player_y)&lt;<span class="number">8</span> &amp;&amp; n==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		PlaySound(<span class="string">&quot;EXPLODE&quot;</span>, NULL, SND_FILENAME | SND_ASYNC);</span><br><span class="line">		explode_x = x;</span><br><span class="line">		explode_y = y;</span><br><span class="line">		explode_s = <span class="number">1</span>;</span><br><span class="line">		player_pop(player_health);</span><br><span class="line">		return <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		return <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		return <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int InitStack_player(Stack&amp; s)</span><br><span class="line">&#123;</span><br><span class="line">	s = (Snode*)malloc(sizeof(Snode));</span><br><span class="line">	<span class="keyword">if</span> (!s)</span><br><span class="line">	&#123;</span><br><span class="line">		outtextxy(<span class="number">280</span>, <span class="number">280</span>, <span class="string">&quot;ERROR OCCURED!&quot;</span>);</span><br><span class="line">		Sleep(<span class="number">2000</span>);</span><br><span class="line">		exit(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function"><span class="title">s</span>-&gt;</span>next = NULL;</span><br><span class="line">		push_player(s);</span><br><span class="line">		push_player(s);</span><br><span class="line">		push_player(s);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void player_draw(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">	clearrectangle(x - <span class="number">10</span>, y - <span class="number">10</span>, x + <span class="number">10</span>, y + <span class="number">10</span>);</span><br><span class="line">	putimage(x-<span class="number">10</span>, y-<span class="number">10</span>, &amp;plane);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void boss_draw()</span><br><span class="line">&#123;</span><br><span class="line">	switch (stagenum)</span><br><span class="line">	&#123;</span><br><span class="line">	case <span class="number">0</span>:</span><br><span class="line">		putimage(boss_x - <span class="number">45</span>, boss_y - <span class="number">15</span>, &amp;boss1);</span><br><span class="line">		break;</span><br><span class="line">	case <span class="number">1</span>:</span><br><span class="line">		putimage(boss_x - <span class="number">15</span>, boss_y - <span class="number">20</span>, &amp;boss2);</span><br><span class="line">		break;</span><br><span class="line">	case <span class="number">2</span>:</span><br><span class="line">		putimage(boss_x - <span class="number">25</span>, boss_y - <span class="number">25</span>, &amp;boss3);</span><br><span class="line">		break;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void time_draw()</span><br><span class="line">&#123;</span><br><span class="line">	int time_ = <span class="number">180</span>-time_draw_t / <span class="number">1000</span>;</span><br><span class="line">	char num[<span class="number">20</span>];</span><br><span class="line">	sprintf(num, <span class="string">&quot;%d&quot;</span>, time_);</span><br><span class="line">	outtextxy(<span class="number">600</span>, <span class="number">5</span>, num);</span><br><span class="line">	outtextxy(<span class="number">520</span>, <span class="number">5</span>, <span class="string">&quot;TIME LEFT:&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (time_ == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		gameover();</span><br><span class="line">	&#125;</span><br><span class="line">	time_draw_t = clock()- time_draw_s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void health_draw()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="title">if</span> (player_health-&gt;</span>next != NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function"><span class="title">int</span> n = player_health-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span>health;</span><br><span class="line">		switch (n)</span><br><span class="line">		&#123;</span><br><span class="line">		case <span class="number">5</span>:</span><br><span class="line">			fillrectangle(<span class="number">10</span>, <span class="number">330</span>, <span class="number">30</span>, <span class="number">350</span>);</span><br><span class="line">		case <span class="number">4</span>:</span><br><span class="line">			fillrectangle(<span class="number">10</span>, <span class="number">360</span>, <span class="number">30</span>, <span class="number">380</span>);</span><br><span class="line">		case <span class="number">3</span>:</span><br><span class="line">			fillrectangle(<span class="number">10</span>, <span class="number">390</span>, <span class="number">30</span>, <span class="number">410</span>);</span><br><span class="line">		case <span class="number">2</span>:</span><br><span class="line">			fillrectangle(<span class="number">10</span>, <span class="number">420</span>, <span class="number">30</span>, <span class="number">440</span>);</span><br><span class="line">		case <span class="number">1</span>:</span><br><span class="line">			fillrectangle(<span class="number">10</span>, <span class="number">450</span>, <span class="number">30</span>, <span class="number">470</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void boss_move()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (clock() - boss_move_s &gt; <span class="number">2000</span> &amp;&amp; (map.Stages[stagenum].boss_movement == <span class="number">0</span>|| map.Stages[stagenum].boss_movement == <span class="number">3</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		way = rand() % <span class="number">4</span>;</span><br><span class="line">		boss_move_s = clock();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (clock() - boss_move_t &gt; <span class="number">50</span> &amp;&amp; (map.Stages[stagenum].boss_movement == <span class="number">0</span> || map.Stages[stagenum].boss_movement == <span class="number">3</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		switch (way)</span><br><span class="line">		&#123;</span><br><span class="line">		case <span class="number">0</span>:</span><br><span class="line">			boss_x = boss_x - <span class="number">3</span>;</span><br><span class="line">			<span class="keyword">if</span> (boss_x &lt; <span class="number">100</span>)</span><br><span class="line">				way = <span class="number">2</span>;</span><br><span class="line">			break;</span><br><span class="line">		case <span class="number">1</span>:</span><br><span class="line">			boss_y = boss_y - <span class="number">3</span>;</span><br><span class="line">			<span class="keyword">if</span> (boss_y &lt; <span class="number">50</span>)</span><br><span class="line">				way = <span class="number">3</span>;</span><br><span class="line">			break;</span><br><span class="line">		case <span class="number">2</span>:</span><br><span class="line">			boss_x = boss_x + <span class="number">3</span>;</span><br><span class="line">			<span class="keyword">if</span> (boss_x &gt; <span class="number">540</span>)</span><br><span class="line">				way = <span class="number">0</span>;</span><br><span class="line">			break;</span><br><span class="line">		case <span class="number">3</span>:</span><br><span class="line">			boss_y = boss_y + <span class="number">3</span>;</span><br><span class="line">			<span class="keyword">if</span> (boss_y &gt; <span class="number">200</span>)</span><br><span class="line">				way = <span class="number">1</span>;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		boss_move_t = clock();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (clock() - boss_move_q &gt; <span class="number">3000</span> &amp;&amp; (map.Stages[stagenum].boss_movement == <span class="number">1</span> || map.Stages[stagenum].boss_movement == <span class="number">3</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		boss_x = rand() % <span class="number">440</span> + <span class="number">100</span>;</span><br><span class="line">		boss_y = rand() % <span class="number">150</span> + <span class="number">50</span>;</span><br><span class="line">		boss_move_q = clock();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bullet_above_spawn()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (clock() - bullet_spawn1 &gt; spawnlimit )</span><br><span class="line">	&#123;</span><br><span class="line">		bullet p;</span><br><span class="line">		p = (bullet)malloc(sizeof(Qnode));</span><br><span class="line">		<span class="keyword">if</span> (!p)</span><br><span class="line">		&#123;</span><br><span class="line">			outtextxy(<span class="number">280</span>, <span class="number">280</span>, <span class="string">&quot;ERROR OCCURED!&quot;</span>);</span><br><span class="line">			Sleep(<span class="number">2000</span>);</span><br><span class="line">			exit(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="title">p</span>-&gt;</span>y = <span class="number">0</span>;</span><br><span class="line">		<span class="function"><span class="title">p</span>-&gt;</span>x = rand() % <span class="number">640</span>;</span><br><span class="line">		<span class="function"><span class="title">p</span>-&gt;</span>hit = <span class="number">0</span>;</span><br><span class="line">		<span class="function"><span class="title">p</span>-&gt;</span>next = NULL;</span><br><span class="line">		<span class="function"><span class="title">bullet_above_q</span>.rear-&gt;</span>next = p;</span><br><span class="line">		bullet_above_q.rear = p;</span><br><span class="line">		bullet_spawn1 = clock();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bullet_left_spawn()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (clock() - bullet_spawn2 &gt; spawnlimit)</span><br><span class="line">	&#123;</span><br><span class="line">		bullet p;</span><br><span class="line">		p = (bullet)malloc(sizeof(Qnode));</span><br><span class="line">		<span class="keyword">if</span> (!p)</span><br><span class="line">		&#123;</span><br><span class="line">			outtextxy(<span class="number">280</span>, <span class="number">280</span>, <span class="string">&quot;ERROR OCCURED!&quot;</span>);</span><br><span class="line">			Sleep(<span class="number">2000</span>);</span><br><span class="line">			exit(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="title">p</span>-&gt;</span>x = <span class="number">0</span>;</span><br><span class="line">		<span class="function"><span class="title">p</span>-&gt;</span>y = rand() % <span class="number">480</span>;</span><br><span class="line">		<span class="function"><span class="title">p</span>-&gt;</span>hit = <span class="number">0</span>;</span><br><span class="line">		<span class="function"><span class="title">p</span>-&gt;</span>next = NULL;</span><br><span class="line">		<span class="function"><span class="title">bullet_left_q</span>.rear-&gt;</span>next = p;</span><br><span class="line">		bullet_left_q.rear = p;</span><br><span class="line">		bullet_spawn2 = clock();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bullet_right_spawn()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (clock() - bullet_spawn3 &gt; spawnlimit )</span><br><span class="line">	&#123;</span><br><span class="line">		bullet p;</span><br><span class="line">		p = (bullet)malloc(sizeof(Qnode));</span><br><span class="line">		<span class="keyword">if</span> (!p)</span><br><span class="line">		&#123;</span><br><span class="line">			outtextxy(<span class="number">280</span>, <span class="number">280</span>, <span class="string">&quot;ERROR OCCURED!&quot;</span>);</span><br><span class="line">			Sleep(<span class="number">2000</span>);</span><br><span class="line">			exit(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="title">p</span>-&gt;</span>x = <span class="number">680</span>;</span><br><span class="line">		<span class="function"><span class="title">p</span>-&gt;</span>y = rand() % <span class="number">480</span>;</span><br><span class="line">		<span class="function"><span class="title">p</span>-&gt;</span>hit = <span class="number">0</span>;</span><br><span class="line">		<span class="function"><span class="title">p</span>-&gt;</span>next = NULL;</span><br><span class="line">		<span class="function"><span class="title">bullet_right_q</span>.rear-&gt;</span>next = p;</span><br><span class="line">		bullet_right_q.rear = p;</span><br><span class="line">		bullet_spawn3 = clock();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bullet_player_spawn()</span><br><span class="line">&#123;</span><br><span class="line">	bullet p;</span><br><span class="line">	p = (bullet)malloc(sizeof(Qnode));</span><br><span class="line">	<span class="keyword">if</span> (!p)</span><br><span class="line">	&#123;</span><br><span class="line">		outtextxy(<span class="number">280</span>, <span class="number">280</span>, <span class="string">&quot;ERROR OCCURED!&quot;</span>);</span><br><span class="line">		Sleep(<span class="number">2000</span>);</span><br><span class="line">		exit(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="title">p</span>-&gt;</span>x = player_x;</span><br><span class="line">	<span class="function"><span class="title">p</span>-&gt;</span>y = player_y-<span class="number">10</span>;</span><br><span class="line">	<span class="function"><span class="title">p</span>-&gt;</span>hit = <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="title">p</span>-&gt;</span>next = NULL;</span><br><span class="line">	<span class="function"><span class="title">bullet_player_q</span>.rear-&gt;</span>next = p;</span><br><span class="line">	bullet_player_q.rear = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bullet_above_move()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (clock() - bullet_move1 &gt; bullet_above_speed)</span><br><span class="line">	&#123;</span><br><span class="line">		bullet p;</span><br><span class="line">		<span class="function"><span class="title">p</span> = bullet_above_q.front-&gt;</span>next;</span><br><span class="line">		<span class="keyword">while</span>(p &amp;&amp; bullet_above_q.front != bullet_above_q.rear)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">y</span> = p-&gt;</span>y + <span class="number">10</span>;</span><br><span class="line">			<span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">hit</span>=player_hit(p-&gt;</span><span class="function"><span class="title">x</span>, p-&gt;</span><span class="function"><span class="title">y</span>,p-&gt;</span>hit);</span><br><span class="line">			<span class="function"><span class="title">if</span> (p-&gt;</span>y &gt; <span class="number">480</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="function"><span class="title">bullet_above_q</span>.front-&gt;</span><span class="function"><span class="title">next</span> = p-&gt;</span>next;</span><br><span class="line">				bullet q=p;</span><br><span class="line">				<span class="function"><span class="title">p</span> = p-&gt;</span>next;</span><br><span class="line">				free(q);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="function"><span class="title">p</span> = p-&gt;</span>next;</span><br><span class="line">		&#125;</span><br><span class="line">		bullet_move1 = clock();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bullet_left_move()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (clock() - bullet_move2 &gt; bullet_left_speed)</span><br><span class="line">	&#123;</span><br><span class="line">		bullet p;</span><br><span class="line">		<span class="function"><span class="title">p</span> = bullet_left_q.front-&gt;</span>next;</span><br><span class="line">		<span class="keyword">while</span> (p &amp;&amp; bullet_left_q.front != bullet_left_q.rear)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">x</span> = p-&gt;</span>x + <span class="number">10</span>;</span><br><span class="line">			<span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">hit</span> = player_hit(p-&gt;</span><span class="function"><span class="title">x</span>, p-&gt;</span><span class="function"><span class="title">y</span>,p-&gt;</span>hit);</span><br><span class="line">			<span class="function"><span class="title">if</span> (p-&gt;</span>x &gt; <span class="number">640</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="function"><span class="title">bullet_left_q</span>.front-&gt;</span><span class="function"><span class="title">next</span> = p-&gt;</span>next;</span><br><span class="line">				bullet q = p;</span><br><span class="line">				<span class="function"><span class="title">p</span> = p-&gt;</span>next;</span><br><span class="line">				free(q);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="function"><span class="title">p</span> = p-&gt;</span>next;</span><br><span class="line">		&#125;</span><br><span class="line">		bullet_move2 = clock();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bullet_right_move()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (clock() - bullet_move3 &gt; bullet_right_speed)</span><br><span class="line">	&#123;</span><br><span class="line">		bullet p;</span><br><span class="line">		<span class="function"><span class="title">p</span> = bullet_right_q.front-&gt;</span>next;</span><br><span class="line">		<span class="keyword">while</span> (p &amp;&amp; bullet_right_q.front != bullet_right_q.rear)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">x</span> = p-&gt;</span>x - <span class="number">10</span>;</span><br><span class="line">			<span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">hit</span> = player_hit(p-&gt;</span><span class="function"><span class="title">x</span>, p-&gt;</span><span class="function"><span class="title">y</span>,p-&gt;</span>hit);</span><br><span class="line">			<span class="function"><span class="title">if</span> (p-&gt;</span>x &lt; <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="function"><span class="title">bullet_right_q</span>.front-&gt;</span><span class="function"><span class="title">next</span> = p-&gt;</span>next;</span><br><span class="line">				bullet q = p;</span><br><span class="line">				<span class="function"><span class="title">p</span> = p-&gt;</span>next;</span><br><span class="line">				free(q);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="function"><span class="title">p</span> = p-&gt;</span>next;</span><br><span class="line">		&#125;</span><br><span class="line">		bullet_move3 = clock();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bullet_player_move()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (clock() - bullet_move4 &gt; bullet_player_speed)</span><br><span class="line">	&#123;</span><br><span class="line">		bullet p;</span><br><span class="line">		<span class="function"><span class="title">p</span> = bullet_player_q.front-&gt;</span>next;</span><br><span class="line">		<span class="keyword">while</span> (p &amp;&amp; bullet_player_q.front != bullet_player_q.rear)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">y</span> = p-&gt;</span>y - <span class="number">10</span>;</span><br><span class="line">			<span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">hit</span> = boss_hit(p-&gt;</span><span class="function"><span class="title">x</span>, p-&gt;</span><span class="function"><span class="title">y</span>, p-&gt;</span>hit);</span><br><span class="line">			<span class="function"><span class="title">if</span> (p-&gt;</span>x &lt; <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="function"><span class="title">bullet_player_q</span>.front-&gt;</span><span class="function"><span class="title">next</span> = p-&gt;</span>next;</span><br><span class="line">				bullet q = p;</span><br><span class="line">				<span class="function"><span class="title">p</span> = p-&gt;</span>next;</span><br><span class="line">				free(q);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="function"><span class="title">p</span> = p-&gt;</span>next;</span><br><span class="line">		&#125;</span><br><span class="line">		bullet_move4 = clock();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bullet_above_draw()</span><br><span class="line">&#123;</span><br><span class="line">	bullet p;</span><br><span class="line">	<span class="function"><span class="title">p</span> = bullet_above_q.front-&gt;</span>next;</span><br><span class="line">	<span class="keyword">while</span>(p &amp;&amp; bullet_above_q.front != bullet_above_q.rear)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function"><span class="title">if</span> (p-&gt;</span>hit == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="function"><span class="title">clearrectangle</span>(p-&gt;</span><span class="function"><span class="title">x</span> - 4, p-&gt;</span><span class="function"><span class="title">y</span> - 8, p-&gt;</span><span class="function"><span class="title">x</span> + 4, p-&gt;</span>y + <span class="number">8</span>);</span><br><span class="line">			<span class="function"><span class="title">putimage</span>(p-&gt;</span><span class="function"><span class="title">x</span> - 4, p-&gt;</span>y - <span class="number">8</span>, &amp;bullet_above);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="title">p</span> = p-&gt;</span>next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bullet_left_draw()</span><br><span class="line">&#123;</span><br><span class="line">	bullet p;</span><br><span class="line">	<span class="function"><span class="title">p</span> = bullet_left_q.front-&gt;</span>next;</span><br><span class="line">	<span class="keyword">while</span> (p &amp;&amp; bullet_left_q.front != bullet_left_q.rear)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function"><span class="title">if</span> (p-&gt;</span>hit == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="function"><span class="title">clearrectangle</span>(p-&gt;</span><span class="function"><span class="title">x</span> - 8, p-&gt;</span><span class="function"><span class="title">y</span> - 4, p-&gt;</span><span class="function"><span class="title">x</span> + 8, p-&gt;</span>y + <span class="number">4</span>);</span><br><span class="line">			<span class="function"><span class="title">putimage</span>(p-&gt;</span><span class="function"><span class="title">x</span> - 8, p-&gt;</span>y - <span class="number">4</span>, &amp;bullet_left);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="title">p</span> = p-&gt;</span>next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bullet_right_draw()</span><br><span class="line">&#123;</span><br><span class="line">	bullet p;</span><br><span class="line">	<span class="function"><span class="title">p</span> = bullet_right_q.front-&gt;</span>next;</span><br><span class="line">	<span class="keyword">while</span> (p &amp;&amp; bullet_right_q.front != bullet_right_q.rear)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function"><span class="title">if</span> (p-&gt;</span>hit == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="function"><span class="title">clearrectangle</span>(p-&gt;</span><span class="function"><span class="title">x</span> - 8, p-&gt;</span><span class="function"><span class="title">y</span> - 4, p-&gt;</span><span class="function"><span class="title">x</span> + 8, p-&gt;</span>y + <span class="number">4</span>);</span><br><span class="line">			<span class="function"><span class="title">putimage</span>(p-&gt;</span><span class="function"><span class="title">x</span> - 8, p-&gt;</span>y - <span class="number">4</span>, &amp;bullet_right);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="title">p</span> = p-&gt;</span>next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bullet_player_draw()</span><br><span class="line">&#123;</span><br><span class="line">	bullet p;</span><br><span class="line">	<span class="function"><span class="title">p</span> = bullet_player_q.front-&gt;</span>next;</span><br><span class="line">	<span class="keyword">while</span> (p &amp;&amp; bullet_player_q.front != bullet_player_q.rear)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function"><span class="title">if</span> (p-&gt;</span>hit == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="function"><span class="title">clearrectangle</span>(p-&gt;</span><span class="function"><span class="title">x</span> - 4, p-&gt;</span><span class="function"><span class="title">y</span> - 8, p-&gt;</span><span class="function"><span class="title">x</span> + 4, p-&gt;</span>y + <span class="number">8</span>);</span><br><span class="line">			<span class="function"><span class="title">putimage</span>(p-&gt;</span><span class="function"><span class="title">x</span> - 4, p-&gt;</span>y - <span class="number">8</span>, &amp;bullet_up);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="title">p</span> = p-&gt;</span>next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void score_out()</span><br><span class="line">&#123;</span><br><span class="line">	char num[<span class="number">20</span>];</span><br><span class="line">	sprintf(num, <span class="string">&quot;%d&quot;</span>, score);</span><br><span class="line">	outtextxy(<span class="number">10</span>, <span class="number">10</span>, <span class="string">&quot;SCORE:&quot;</span>);</span><br><span class="line">	outtextxy(<span class="number">70</span>, <span class="number">10</span>, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void levelup_draw()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> ( levelup_s ==<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		outtextxy(<span class="number">10</span>, <span class="number">30</span>, <span class="string">&quot;level up!&quot;</span>);</span><br><span class="line">		levelup_t++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (levelup_t &gt; <span class="number">60</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		levelup_s = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void levelup()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (score &gt; <span class="number">8000</span> &amp;&amp; level == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		level++;</span><br><span class="line">		player_shoot_speed = <span class="number">300</span>;</span><br><span class="line">		push_player(player_health);</span><br><span class="line">		levelup_s = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">13000</span> &amp;&amp; level == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		level++;</span><br><span class="line">		player_shoot_speed = <span class="number">200</span>;</span><br><span class="line">		push_player(player_health);</span><br><span class="line">		levelup_s = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dont_touch_boss()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">abs</span>(player_x - boss_x) &lt; map.Stages[stagenum].boss_length / <span class="number">2</span> &amp;&amp; <span class="built_in">abs</span>(player_y - boss_y) &lt; map.Stages[stagenum].boss_width / <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		gameover();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">	char num[<span class="number">20</span>];</span><br><span class="line">	sprintf(num, <span class="string">&quot;%d&quot;</span>, map.Stages[stagenum].bullet_above_judge);</span><br><span class="line">	outtextxy(<span class="number">10</span>, <span class="number">100</span>, num);</span><br><span class="line">	sprintf(num, <span class="string">&quot;%d&quot;</span>, map.Stages[stagenum].bullet_left_judge);</span><br><span class="line">	outtextxy(<span class="number">10</span>, <span class="number">150</span>, num);</span><br><span class="line">	sprintf(num, <span class="string">&quot;%d&quot;</span>, map.Stages[stagenum].bullet_right_judge);</span><br><span class="line">	outtextxy(<span class="number">10</span>, <span class="number">200</span>, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void draw()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (clock() - draw_t &gt; <span class="number">50</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function"><span class="title">if</span> (player_health-&gt;</span>next == NULL)</span><br><span class="line">			gameover();</span><br><span class="line">		putimage(<span class="number">0</span>, <span class="number">0</span>, &amp;<span class="built_in">background</span>);</span><br><span class="line">		player_draw(player_x, player_y);</span><br><span class="line">		boss_draw();</span><br><span class="line">		<span class="keyword">if</span> (map.Stages[stagenum].bullet_above_judge == <span class="number">1</span>)</span><br><span class="line">			bullet_above_draw();</span><br><span class="line">		<span class="keyword">if</span> (map.Stages[stagenum].bullet_left_judge == <span class="number">1</span>)</span><br><span class="line">			bullet_left_draw();</span><br><span class="line">		<span class="keyword">if</span> (map.Stages[stagenum].bullet_right_judge == <span class="number">1</span>)</span><br><span class="line">			bullet_right_draw();</span><br><span class="line">		bullet_player_draw();</span><br><span class="line">		time_draw();</span><br><span class="line">		health_draw();</span><br><span class="line">		score_out();</span><br><span class="line">		levelup_draw();</span><br><span class="line">		bullet_explode();</span><br><span class="line">		<span class="comment">//test();</span></span><br><span class="line">		draw_t = clock();</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void player_move()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (clock() - player_move_t &gt; <span class="number">50</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (GetAsyncKeyState(VK_ESCAPE))exit(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (GetAsyncKeyState(VK_UP))player_y=player_y-<span class="number">5</span>;</span><br><span class="line">		<span class="keyword">if</span> (GetAsyncKeyState(VK_DOWN))player_y=player_y+<span class="number">5</span>;</span><br><span class="line">		<span class="keyword">if</span> (GetAsyncKeyState(VK_LEFT))player_x=player_x-<span class="number">5</span>;</span><br><span class="line">		<span class="keyword">if</span> (GetAsyncKeyState(VK_RIGHT))player_x=player_x+<span class="number">5</span>;</span><br><span class="line">		<span class="keyword">if</span> (player_x &gt; <span class="number">640</span>) player_x = <span class="number">640</span>;</span><br><span class="line">		<span class="keyword">if</span> (player_y &gt; <span class="number">480</span>) player_y = <span class="number">480</span>;</span><br><span class="line">		<span class="keyword">if</span> (player_x &lt; <span class="number">0</span>) player_x = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (player_y &lt; <span class="number">0</span>) player_y = <span class="number">0</span>;</span><br><span class="line">		player_move_t = clock();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (clock() - player_shoot_t &gt; player_shoot_speed)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (GetAsyncKeyState(VK_SPACE))</span><br><span class="line">		&#123;</span><br><span class="line">			bullet_player_spawn();</span><br><span class="line">			PlaySound(<span class="string">&quot;SHOT&quot;</span>, NULL, SND_FILENAME | SND_ASYNC);</span><br><span class="line">		&#125;</span><br><span class="line">		player_shoot_t = clock();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void touhou()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		player_move();</span><br><span class="line">		boss_move();</span><br><span class="line">		<span class="keyword">if</span> (map.Stages[stagenum].bullet_above_judge == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			bullet_above_spawn();</span><br><span class="line">			bullet_above_move();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (map.Stages[stagenum].bullet_left_judge == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			bullet_left_spawn();</span><br><span class="line">			bullet_left_move();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (map.Stages[stagenum].bullet_right_judge == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			bullet_right_spawn();</span><br><span class="line">			bullet_right_move();</span><br><span class="line">		&#125;</span><br><span class="line">		bullet_player_move();</span><br><span class="line">		levelup();</span><br><span class="line">		dont_touch_boss();</span><br><span class="line">		draw();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	initgraph(<span class="number">640</span>, <span class="number">480</span>);</span><br><span class="line">	cleardevice();</span><br><span class="line">	setcolor(BLACK);</span><br><span class="line">	settextcolor(WHITE);</span><br><span class="line">	outtextxy(<span class="number">280</span>, <span class="number">240</span>, <span class="string">&quot;loading...&quot;</span>);</span><br><span class="line">	loadimage(&amp;<span class="built_in">background</span>,_T(<span class="string">&quot;IMAGE&quot;</span>), _T(<span class="string">&quot;background&quot;</span>), <span class="number">640</span>, <span class="number">480</span>, <span class="number">1</span>);</span><br><span class="line">	loadimage(&amp;plane, _T(<span class="string">&quot;IMAGE&quot;</span>), _T(<span class="string">&quot;plane&quot;</span>), <span class="number">20</span>, <span class="number">20</span>, <span class="number">0</span>);</span><br><span class="line">	loadimage(&amp;bullet_up, _T(<span class="string">&quot;IMAGE&quot;</span>), _T(<span class="string">&quot;bullet_above&quot;</span>), <span class="number">8</span>, <span class="number">16</span>, <span class="number">0</span>);</span><br><span class="line">	loadimage(&amp;bullet_above, _T(<span class="string">&quot;IMAGE&quot;</span>), _T(<span class="string">&quot;bullets_down&quot;</span>), <span class="number">8</span>, <span class="number">16</span>, <span class="number">0</span>);</span><br><span class="line">	loadimage(&amp;bullet_left, _T(<span class="string">&quot;IMAGE&quot;</span>), _T(<span class="string">&quot;bullet_right&quot;</span>), <span class="number">16</span>, <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line">	loadimage(&amp;bullet_right, _T(<span class="string">&quot;IMAGE&quot;</span>), _T(<span class="string">&quot;bullet_left&quot;</span>), <span class="number">16</span>, <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line">	loadimage(&amp;boss1, _T(<span class="string">&quot;IMAGE&quot;</span>), _T(<span class="string">&quot;boss1&quot;</span>), <span class="number">90</span>, <span class="number">30</span>, <span class="number">0</span>);</span><br><span class="line">	loadimage(&amp;boss2, _T(<span class="string">&quot;IMAGE&quot;</span>), _T(<span class="string">&quot;boss2&quot;</span>), <span class="number">30</span>, <span class="number">40</span>, <span class="number">0</span>);</span><br><span class="line">	loadimage(&amp;boss3, _T(<span class="string">&quot;IMAGE&quot;</span>), _T(<span class="string">&quot;boss3&quot;</span>), <span class="number">50</span>, <span class="number">50</span>, <span class="number">0</span>);</span><br><span class="line">	loadimage(&amp;explode, _T(<span class="string">&quot;IMAGE&quot;</span>), _T(<span class="string">&quot;explode&quot;</span>), <span class="number">100</span>, <span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line">	loadimage(&amp;explode_small, _T(<span class="string">&quot;IMAGE&quot;</span>), _T(<span class="string">&quot;explode&quot;</span>), <span class="number">20</span>, <span class="number">20</span>, <span class="number">0</span>);</span><br><span class="line">	loadimage(&amp;<span class="built_in">title</span>, _T(<span class="string">&quot;IMAGE&quot;</span>), _T(<span class="string">&quot;title&quot;</span>), <span class="number">400</span>, <span class="number">200</span>, <span class="number">0</span>);</span><br><span class="line">	loadimage(&amp;start_button, _T(<span class="string">&quot;IMAGE&quot;</span>), _T(<span class="string">&quot;start_button&quot;</span>), <span class="number">100</span>, <span class="number">50</span>, <span class="number">0</span>);</span><br><span class="line">	player_move_t = clock();</span><br><span class="line">	bullet_spawn1 = clock();</span><br><span class="line">	bullet_spawn2 = clock();</span><br><span class="line">	bullet_spawn3 = clock();</span><br><span class="line">	bullet_move1 = clock();</span><br><span class="line">	bullet_move2 = clock();</span><br><span class="line">	bullet_move3 = clock();</span><br><span class="line">	player_shoot_t = clock();</span><br><span class="line">	boss_move_s = clock();</span><br><span class="line">	boss_move_t = clock();</span><br><span class="line">	boss_move_q = clock();</span><br><span class="line">	srand(<span class="built_in">time</span>(NULL));</span><br><span class="line">	<span class="keyword">if</span> (!InitQueue(bullet_above_q) || !InitQueue(bullet_left_q) || !InitQueue(bullet_right_q) || !InitQueue(bullet_player_q))</span><br><span class="line">	&#123;</span><br><span class="line">		outtextxy(<span class="number">280</span>, <span class="number">280</span>, <span class="string">&quot;ERROR OCCURED!&quot;</span>);</span><br><span class="line">		Sleep(<span class="number">2000</span>);</span><br><span class="line">		exit(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	InitStack_player(player_health);</span><br><span class="line">	InitGraph(map);</span><br><span class="line">	putimage(<span class="number">0</span>, <span class="number">0</span>, &amp;<span class="built_in">background</span>);</span><br><span class="line">	putimage(<span class="number">120</span>, <span class="number">60</span>, &amp;<span class="built_in">title</span>);</span><br><span class="line">	putimage(<span class="number">270</span>, <span class="number">335</span>, &amp;start_button);</span><br><span class="line">	mciSendString(<span class="string">&quot;play bgm.mp3 repeat&quot;</span>, NULL, <span class="number">0</span>, NULL);</span><br><span class="line">	MOUSEMSG m;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		m = GetMouseMsg();</span><br><span class="line">		<span class="keyword">if</span> (m.mkLButton)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (m.x &gt; <span class="number">270</span> &amp;&amp; m.x &lt; <span class="number">370</span> &amp;&amp; m.y&gt;<span class="number">335</span> &amp;&amp; m.y &lt; <span class="number">385</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	putimage(<span class="number">0</span>, <span class="number">0</span>, &amp;<span class="built_in">background</span>);</span><br><span class="line">	outtextxy(<span class="number">280</span>, <span class="number">220</span>, <span class="string">&quot;stage&quot;</span>);</span><br><span class="line">	char num[<span class="number">20</span>];</span><br><span class="line">	sprintf(num, <span class="string">&quot;%d&quot;</span>, <span class="number">1</span>);</span><br><span class="line">	outtextxy(<span class="number">340</span>, <span class="number">220</span>, num);</span><br><span class="line">	outtextxy(<span class="number">230</span>, <span class="number">280</span>, <span class="string">&quot;↑ ↓ ← → 控制移动方向&quot;</span>);</span><br><span class="line">	outtextxy(<span class="number">265</span>, <span class="number">310</span>, <span class="string">&quot;Space 发射子弹&quot;</span>);</span><br><span class="line">	outtextxy(<span class="number">255</span>, <span class="number">340</span>, <span class="string">&quot;左下角是你的血量&quot;</span>);</span><br><span class="line">	outtextxy(<span class="number">240</span>, <span class="number">370</span>, <span class="string">&quot;右上角是你剩余的时间&quot;</span>);</span><br><span class="line">	Sleep(<span class="number">4000</span>);</span><br><span class="line">	time_draw_t = clock();</span><br><span class="line">	time_draw_s = clock();</span><br><span class="line">	touhou();</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>发癫产物~</category>
      </categories>
  </entry>
  <entry>
    <title>基于Sovits4.0的AI惠惠语音实现</title>
    <url>/2023/03/20/%E5%9F%BA%E4%BA%8ESovits4-0%E7%9A%84AI%E6%83%A0%E6%83%A0%E8%AF%AD%E9%9F%B3%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>我要开始叠buff了</p>
<p>此次实现仅为本人个人兴趣，不会用于盈利，模型及使用项目不会外传，此项目仅用于制作音乐或用于视频配音，且音乐或视频不开启收益，仅作为分享用</p>
<p>有可能一次写不完，之后随缘更新吧</p>
<p>另外，我的性别认知是武装直升机，如果想从我这里拿模型，首先你需要出示直升机驾驶证（笑）</p>
<h1 id="数据集获取"><a href="#数据集获取" class="headerlink" title="数据集获取"></a>数据集获取</h1><p>哪里有语音呢？</p>
<p>番剧？</p>
<p>从视频里获取语音数据需要一点一点分开视频语音，然后去除背景音，然后再总和。</p>
<p>合理推断获取500条数据需要至少10小时</p>
<p>怎么说都太麻烦了，如果能直接拿到语音数据就好了，比如游戏语音解包文件</p>
<p>等等，游戏？</p>
<p>素晴可是有游戏的，据我所知有PSV游戏和手游</p>
<p>PSV游戏基本没有解包的可能性，可恶的索尼</p>
<p>那就只能看手游了，首先你需要把它下载下来</p>
<h2 id="游戏解包"><a href="#游戏解包" class="headerlink" title="游戏解包"></a>游戏解包</h2><p>这里我用到了雷电模拟器，这个模拟器很容易就可以root，推荐使用</p>
<p>游戏从哪里下载呢？从网上查了几个方案都是从加速器界面下载，但看加速器之后他们都停止了对游戏的服务，原因未知</p>
<p>有一个加速器可以下，树懒acc</p>
<p>但是树懒acc不能在模拟器上运行</p>
<p>好了难点来了，怎么拿到游戏呢？</p>
<p>首先在手机上下载树懒acc并安装游戏，然后生成分享apk，分享给自己的电脑，然后把apk文件安装在模拟器里，大功告成</p>
<p>接下来你还需要在模拟器里安个加速器，加速后打开游戏，此时需要点击下载所有文件，这样就可以获取到所有的语音文件。</p>
<p>然后打开这个路径</p>
<p>jp.co.sumzap.pj0007\files\bundles\Cri\Cpk </p>
<p>把所有的cpk拷贝出来，同时你还需要这三个工具：GARbro，VGMToolbox，hcadecode</p>
<h2 id="开始音频提取"><a href="#开始音频提取" class="headerlink" title="开始音频提取"></a>开始音频提取</h2><p>音频提取其实就是解密，因为手游为了减小文件大小，将音频，图片等资源进行了加密压缩，比如音频，素晴手游音频wav大概在10G左右，但是在游戏里也就不带1G。</p>
<p>首先使用GARbro工具，将上边获得的cpk拖进去，可以看到软件里一个cpk对应两个文件，分别是awb和acb，全选后右键提取，第一步完成。</p>
<p>第二步使用VGMToolbox，将需解包的文件全部拖到  VGMToolvox\MusicTools\ExtractionTools\Streams\CRI-HCA-Extractor 目录中，将awb&#x2F;acb转化为hca形式，第二步完成。</p>
<p>第三步使用hcadecode，将这个和hca文件放在一个文件夹下，然后可以用脚本进行批量转换，最后得到转换好的wav</p>
<p>此处可以参考这个大哥写的博客</p>
<p><a href="https://www.bilibili.com/read/cv5939682?from=search&spm_id_from=333.337.0.0">B站博客链接</a></p>
<h2 id="提取惠惠音频"><a href="#提取惠惠音频" class="headerlink" title="提取惠惠音频"></a>提取惠惠音频</h2><p>终于到了整个工程最恐怖最难受的部分，素晴为了事件编辑方便，将所有声音文件按事件分类，并在时间内按人物进行二级排序，虽然我并不知道这样分有什么好处，但是这无疑大大加重了声音分拣工作量。</p>
<p>然后你会发现你得到了10W条音频，紧接着你会发现音频需要你一点一点提取</p>
<p>当然有快方法，但是仅能筛选一部分音频，毕竟素晴手游是个抽卡游戏，所以是存在活动语音和人物语音的，并且这两种语音都是存在人物角色分类的，经过分类发现惠惠的人物编号是102，这样可以筛选出来大概500条语音</p>
<p>500条语音肯定训练不出来很好的模型，所以我现在训练出来第一个模型之后在重新铸造数据集准备训练个惠惠v2，还可以顺便尝试vits最新版本</p>
<h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><p>这里就相对好弄，你只需要一个so-vits项目，调整合适的参数，把数据集放进去，然后运行就行了，我挂了一晚上训练出来的72000步模型相对稳定但是有些过拟合，惠惠的音色有些失去了特色，唉</p>
<p>然后这里可以去看我B站视频，向您推荐未来的百大up</p>
<p><a href="https://space.bilibili.com/28605906/channel/seriesdetail?sid=3146373&ctype=0">AI惠惠</a></p>
<iframe src="//player.bilibili.com/player.html?aid=653761665&bvid=BV1UY4y1X7QE&cid=1063673370&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>如果单纯是可以唱歌我也不会做这么麻烦的东西</p>
<p>唉但是其实只会唱歌的话也能发癫所以我还是会做对不起</p>
<p>我希望把这个玩意回头集成在我的AI管家项目里，可以让AI管家发出特定音色，完事给管家套个皮，恭喜你得到了一个AI老婆（不是）</p>
<p>然后现在的AI是可以炼丹的，也就是说可以在数据集里添加不同人物的音色得到所有人物音色融合的模型，这个模型可以未来应用到个人设计“欢迎来到滕文市”的角色语音。AI真的为内容创作者贡献了太多（他真的我哭死）</p>
]]></content>
      <categories>
        <category>发癫产物~</category>
      </categories>
  </entry>
  <entry>
    <title>对百度网盘使用工具吧！</title>
    <url>/2023/03/19/%E5%AF%B9%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E4%BD%BF%E7%94%A8CE%E5%90%A7%EF%BC%81/</url>
    <content><![CDATA[<p>百度网盘限速贼垃圾？</p>
<p>账号被封禁下载超慢？</p>
<h1 id="对他使用CE吧！"><a href="#对他使用CE吧！" class="headerlink" title="对他使用CE吧！"></a>对他使用CE吧！</h1><p>打开CE，选中process方式中的百度网盘host，这里有两个，肯定有一个是好用的<br><img src="/2023/03/19/%E5%AF%B9%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E4%BD%BF%E7%94%A8CE%E5%90%A7%EF%BC%81/1.png"></p>
<p>然后右边开启变速，直接拉到500差不多能跑满<br><img src="/2023/03/19/%E5%AF%B9%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E4%BD%BF%E7%94%A8CE%E5%90%A7%EF%BC%81/2.png"></p>
<p>你会发现百度网盘里好像没什么特别的变化</p>
<p>但是打开任务浏览器看网络使用<br><img src="/2023/03/19/%E5%AF%B9%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E4%BD%BF%E7%94%A8CE%E5%90%A7%EF%BC%81/3.png"></p>
<p>直接拉满！</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>看来百度不过就是在客户端做了个sleep，我的评价是不过如此。</p>
<h1 id="2023-5-12更新"><a href="#2023-5-12更新" class="headerlink" title="2023-5-12更新"></a>2023-5-12更新</h1><p>CE方法被ban了，但是还有办法！</p>
<h1 id="Motrix-Kubedown"><a href="#Motrix-Kubedown" class="headerlink" title="Motrix+Kubedown"></a>Motrix+Kubedown</h1><p>首先你需要下载一个Motrix，然后油猴脚本弄一个Kubedown,Kubedown是油猴脚本，所以你还需要一个油猴</p>
<p><a href="https://scriptcat.org/script-show-page/952">Kubedown</a></p>
<p><a href="https://github.com/agalwood/Motrix/releases">Motrix</a></p>
<p>你首先需要将别人分享的文件保存到自己的网盘里，然后分享，再打开你自己分享的分享链接，紧接着你就能看见Kubedown按钮了</p>
<p><img src="/2023/03/19/%E5%AF%B9%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E4%BD%BF%E7%94%A8CE%E5%90%A7%EF%BC%81/5.png"></p>
<p>选择一个你要下载的文件，点击Kubedown按钮，输入验证码后可以看见这样的界面</p>
<p><img src="/2023/03/19/%E5%AF%B9%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E4%BD%BF%E7%94%A8CE%E5%90%A7%EF%BC%81/6.png"></p>
<p>上面的链接复制到Motrix的连接栏，下面的netdisk是agent</p>
<p><img src="/2023/03/19/%E5%AF%B9%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E4%BD%BF%E7%94%A8CE%E5%90%A7%EF%BC%81/7.png"></p>
<p>然后添加就行，效果是这样的</p>
<p><img src="/2023/03/19/%E5%AF%B9%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E4%BD%BF%E7%94%A8CE%E5%90%A7%EF%BC%81/4.png"></p>
<h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p>想限制我？我的评价是不过如此。</p>
]]></content>
      <categories>
        <category>发癫产物~</category>
      </categories>
  </entry>
  <entry>
    <title>小小魔法 for UOOC</title>
    <url>/2023/05/15/%E5%B0%8F%E5%B0%8F%E9%AD%94%E6%B3%95-for-UOOC/</url>
    <content><![CDATA[<h1 id="直接开始魔法"><a href="#直接开始魔法" class="headerlink" title="直接开始魔法"></a>直接开始魔法</h1><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">eval</span>(function(p,a,c,k,e,r)&#123;e=function(c)&#123;return(c&lt;<span class="number">62</span>?&#x27;&#x27;:e(parseInt(c/<span class="number">62</span>)))+((c=c%<span class="number">62</span>)&gt;<span class="number">35</span>?String.fromCharCode(c+<span class="number">29</span>):c.toString(<span class="number">36</span>))&#125;;if(&#x27;<span class="number">0</span>&#x27;.replace(<span class="number">0</span>,e)==<span class="number">0</span>)&#123;while(c--)r[e(c)]=k[c];k=[function(e)&#123;return r[e]||e&#125;];e=function()&#123;return&#x27;[<span class="number">3</span>-<span class="number">9</span>a-zA-G]&#x27;&#125;;c=<span class="number">1</span>&#125;;while(c--)if(k[c])p=p.replace(new RegExp(&#x27;\\b&#x27;+e(c)+&#x27;\\b&#x27;,&#x27;g&#x27;),k[c]);return p&#125;(&#x27;<span class="number">8</span> s=<span class="number">800010000</span>;(<span class="number">5</span>(<span class="number">3</span>,$)&#123;<span class="number">3</span>.l=<span class="number">0</span>;<span class="number">3</span>.m=<span class="number">0</span>;<span class="number">3</span>.d=<span class="number">2000</span>;<span class="number">9</span>.a(\&#x27;start run.\&#x27;);<span class="number">3</span>.setInterval(<span class="number">5</span>()&#123;<span class="number">6</span>(e.f().g!=undefined)&#123;<span class="number">6</span>(!e.f().g.A)&#123;e.f().g.A=<span class="number">1</span>;<span class="number">3</span>.m+=<span class="number">1</span>;<span class="number">9</span>.a(c()+\&#x27;-&gt;m:\&#x27;+<span class="number">3</span>.m);$(<span class="string">&quot;html&quot;</span>).<span class="literal">off</span>(<span class="string">&quot;mouseleave blur visibilitychange&quot;</span>);<span class="number">8</span> <span class="number">4</span>=&#123;&#125;;<span class="number">4</span>.t=<span class="number">5</span>()&#123;<span class="number">3</span>.u(<span class="number">5</span>()&#123;<span class="number">9</span>.a(c()+\&#x27;-&gt;<span class="number">2</span>倍速度\&#x27;);$(\&#x27;.vjs-B\&#x27;).h(\&#x27;ul[role=<span class="string">&quot;B&quot;</span>]\&#x27;).<span class="number">7</span>().h(\&#x27;li\&#x27;).<span class="number">7</span>().n(\&#x27;o\&#x27;)&#125;,<span class="number">3</span>.d)&#125;;<span class="number">4</span>.b=<span class="number">5</span>()&#123;<span class="number">3</span>.u(<span class="number">5</span>()&#123;<span class="number">9</span>.a(c()+\&#x27;-&gt;播放下一个\&#x27;);<span class="number">8</span> v=$(\&#x27;p[q=<span class="string">&quot;w b-scope&quot;</span>]\&#x27;);<span class="number">6</span>(v.i&gt;<span class="number">0</span>)&#123;<span class="number">8</span> <span class="number">7</span>=v.<span class="number">7</span>();<span class="number">6</span>(<span class="number">7</span>.h(\&#x27;C[b-<span class="number">6</span>=<span class="string">&quot;D.E == 10&quot;</span>]\&#x27;).i&gt;<span class="number">0</span>)&#123;<span class="number">7</span>.n(\&#x27;o\&#x27;);<span class="number">4</span>.t()&#125;j <span class="number">6</span>(<span class="number">7</span>.h(\&#x27;C[b-<span class="number">6</span>=<span class="string">&quot;D.E == 80&quot;</span>]\&#x27;).i&gt;<span class="number">0</span>)&#123;<span class="number">4</span>.r();x(<span class="string">&quot;请完成测验&quot;</span>)&#125;j&#123;<span class="number">4</span>.r();x(<span class="string">&quot;r,请重试.&quot;</span>)&#125;&#125;j&#123;<span class="number">4</span>.k()&#125;&#125;,<span class="number">3</span>.d)&#125;;<span class="number">4</span>.r=<span class="number">5</span>()&#123;<span class="number">6</span>(s)&#123;<span class="number">8</span> F=\&#x27;tencent://message/?uin=\&#x27;+s;<span class="number">3</span>.open(F)&#125;&#125;;<span class="number">4</span>.k=<span class="number">5</span>()&#123;<span class="number">3</span>.u(<span class="number">5</span>()&#123;<span class="number">9</span>.a(c()+\&#x27;-&gt;下一个子节点\&#x27;);<span class="number">8</span> y=$(\&#x27;p[q=<span class="string">&quot;w k&quot;</span>]\&#x27;).h(\&#x27;p[q=<span class="string">&quot;oneline b-binding&quot;</span>]\&#x27;);<span class="number">6</span>(y.i&gt;<span class="number">0</span>)&#123;y.<span class="number">7</span>().n(\&#x27;o\&#x27;);<span class="number">4</span>.b()&#125;j&#123;<span class="number">4</span>.G()&#125;&#125;,<span class="number">3</span>.d)&#125;;<span class="number">4</span>.G=<span class="number">5</span>()&#123;<span class="number">9</span>.a(c()+\&#x27;-&gt;下一个章节\&#x27;);<span class="number">8</span> z=$(\&#x27;p[q=<span class="string">&quot;w chapter k&quot;</span>]\&#x27;);<span class="number">6</span>(z.i&gt;<span class="number">0</span>)&#123;z.<span class="number">7</span>().n(\&#x27;o\&#x27;);<span class="number">4</span>.k()&#125;j&#123;x(\&#x27;end\&#x27;)&#125;&#125;;e.f().g.<span class="literal">on</span>(<span class="string">&quot;pause&quot;</span>,<span class="number">5</span>()&#123;<span class="number">3</span>.l+=<span class="number">1</span>;<span class="number">9</span>.a(c()+\&#x27;-&gt;l:\&#x27;+<span class="number">3</span>.l);<span class="number">4</span>.b()&#125;);<span class="number">4</span>.t();e.f().g.play()&#125;&#125;&#125;,<span class="number">3</span>.d)&#125;)(<span class="number">3</span>,<span class="number">3</span>.jQuery);&#x27;,[],<span class="number">43</span>,&#x27;|||window|funObj|function|if|first|var|console|log|ng|Date|wait|videojs|getPlayers|player|find|length|else|uncomplete|countRun|countInit|trigger|click|div|class|error|qq|speed|setTimeout|ng_scope|basic|alert|ng_binging|chapter_uncomplete|executeFlag|menu|span|source|type|url|chapterUncomplete&#x27;.split(&#x27;|&#x27;),<span class="number">0</span>,&#123;&#125;))</span><br></pre></td></tr></table></figure>

<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>控制台enter</p>
<h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>视频自动切换，小章节和大章节都行<br><br><strong>不能直做测试和讨论题，到讨论题附近魔法会暂停，需要手动</strong><br><br><del>其实是因为我不想改代码了</del></p>
<p><a href="https://github.com/leiyong0326/UoocAutoPlay">来源</a></p>
]]></content>
      <categories>
        <category>学习资料</category>
      </categories>
  </entry>
  <entry>
    <title>CADE: 检测和解释安全应用中的概念漂移样本</title>
    <url>/2024/07/14/CADE-%E6%A3%80%E6%B5%8B%E5%92%8C%E8%A7%A3%E9%87%8A%E5%AE%89%E5%85%A8%E5%BA%94%E7%94%A8%E4%B8%AD%E7%9A%84%E6%A6%82%E5%BF%B5%E6%BC%82%E7%A7%BB%E6%A0%B7%E6%9C%AC/</url>
    <content><![CDATA[
## 摘要

概念漂移：因攻击者的行为变化，导致部署的模型出现重大失败
提出CADE：1>可以检测偏离现有类别的样本 2>提供解释来解释检测到的偏移

## 现状

为应对概念漂移，传统解决方法会定期重新训练安全模型，这样需要标注大量新样本，还需要其确定重新训练的时间，费时费力。

## CADE

思想：判断一个样本在对某个分类的相似度与其他属于该分类的样本相比是否正常

CADE：主要包含一个检测器用于检测输入的样本是否产生漂移，包含一个解释器解释检测器筛选出的样本的漂移
![](1.png)

### 检测器
采用对比学习，将高维的样本数据映射到低维，每个类形成紧密的群体。在这个隐空间中，距离函数可以有效地识别新样本从这些群体中漂移开的情况。

首先使用编码器将所有训练样本映射到隐空间中（第2-4行）。对于每个类别 $ i $，我们计算其质心 $ {\mathbf{c}}_{i} $（通过在欧几里得空间中取每个维度的平均值，第5行）。给定一个测试样本 $ {\mathbf{x}}_{t}^{\left( k\right) } $，我们也使用编码器将其映射到隐空间表示 $ {\mathbf{z}}_{t}^{\left( k\right) } $（第14行）。然后，我们计算测试样本与其质心之间的欧氏距离：$ {d}_{i}^{\left( k\right) } = {\begin{Vmatrix}{\mathbf{z}}_{t}^{\left( k\right) } - {\mathbf{c}}_{i}\end{Vmatrix}}_{2} $（第16行）。根据其到质心的距离，我们确定这个测试样本是否对于 $ N $ 个类别中的每一个都是分布外的。在这里，我们根据样本到质心的距离而不是样本到最近训练样本的距离做出决策。这是因为后一种选择很容易受到训练数据中的异常点的影响。

为了根据 $ {d}_{i}^{\left( k\right) } $ 确定异常点，挑战在于不同类别的紧密度可能不同，因此需要不同的距离阈值。而不是手动为每个类别设置绝对距离阈值，我们使用了一种称为中位数绝对偏差（MAD）[40]的方法。想法是通过计算 $ {\mathrm{{MAD}}}_{i} $（第6-10行）来估计每个类别的数据分布 $ i $，它是中位数距离 $ {d}_{i}^{\left( j\right) }\left( {j = 1,\ldots ,{n}_{i}}\right) $ 的绝对偏差。在这里 $ {d}_{i}^{\left( j\right) } $ 表示类别 $ i $ 中每个样本与其质心的潜在距离，以及 $ {n}_{i} $ 是类别 $ i $ 中样本的数量（第7行）。然后基于 $ {\mathrm{{MAD}}}_{i} $，我们可以确定 $ {d}_{i}^{\left( k\right) } $ 是否足够大，使得测试样本 $ {\mathbf{x}}_{t}^{\left( k\right) } $ 成为类别 $ i $ 的异常点（第15-24行）。如果测试样本对于所有 $ N $ 个类别都是异常点，那么它被确定为一个漂移样本。否则，我们确定它是一个内分布样本，并且其最近的质心由最近的质心确定（第26行）。MAD的优势在于每个类别都有自己的距离阈值来根据其内类分布确定异常点。例如，如果一个簇更分散，阈值就会更大。

### 解释器

因为很难移动一个漂移样本跨越决策边界，提出了一个专为漂移样本设计的解释器

首先需要设计一个特征扰动机制。大多数现有的扰动方法都是专门为图像设计的，这些图像的特征是数值值。在我们的情况下，$ {\mathbf{x}}_{t} $的特征可以是数值的也可以是分类的，因此直接应用现有的方法将产生不明确的特征值。为了确保扰动对于数值和分类特征都是有意义的，我们提出通过替换特征值来扰动 $ {\mathbf{x}}_{t} $，这个特征值对应于参考训练样本 $ {\mathbf{x}}_{{y}_{t}}^{\left( c\right) } $ 中的特征值。这个 $ {\mathbf{x}}_{{y}_{t}}^{\left( c\right) } $ 是训练样本，它与中心点 $ {\mathbf{c}}_{{y}_{t}} $ 的潜在距离最短。这样一来，我们的解释目标就是识别一组特征，使得用 $ {\mathbf{x}}_{{y}_{t}}^{\left( c\right) } $ 中的特征替换它们，将对 $ f\left( {\mathbf{x}}_{t}\right) $ 和 $ {\mathbf{c}}_{{y}_{t}} $ 之间的距离产生最大的影响
# 全文翻译

杨Limin $ {}^{ * } $, 郭Wenbo $ {}^{ \dagger } $, 郝Qingying $ {}^{ * } $, 西塔迪Arridhana $ {}^{ \ddagger } $

阿赫马兹德Ali Ahmadzadeh $ {}^{ \ddagger } $, 邢Xinyu $ {}^{ \dagger } $, 王Gang $ {}^{ * } $

*伊利诺伊大学香槟分校 $ {}^{ \dagger } $ 宾夕法尼亚州立大学 $ {}^{ \ddagger } $ 蓝色六边形

liminy2@illinois.edu, wzg13@ist.psu.edu, qhao2@illinois.edu, \{arri, ali\}@bluehexagon.ai, xxing@ist.psu.edu, gangw@illinois.edu

摘要

概念漂移对将机器学习模型应用于解决实际安全问题构成了一个关键挑战。由于攻击者（或良性对手）的行为变化，测试数据的分布往往随着时间的推移从原始训练数据中发生变化，导致部署的模型出现重大失败。

为了对抗概念漂移，我们提出了一种名为CADE的全新系统，旨在1) 检测偏离现有类别的变化样本，以及2) 提供解释来解释检测到的漂移。与传统方法（需要大量新标签来统计确定概念漂移）不同，我们的目标是识别随着时间推移到达的单个变化样本。认识到高维异常空间带来的挑战，我们提出将数据样本映射到低维空间，并自动学习一个距离函数来测量样本之间的差异。使用对比学习，我们可以充分利用训练数据集中的标签来学习如何比较和对比样本对。为了解释检测到的漂移的意义，我们开发了一种基于距离的解释方法。我们展示在这种情况中解释“距离”比专注于解释决策边界的传统方法要有效得多。我们在两个案例研究中评估了CADE：Android恶意软件分类和网络入侵检测。我们还与一家安全公司合作，在其恶意软件数据库上测试CADE。我们的结果表明，CADE能够有效地检测变化样本并提供有意义的解释。

## 1 引言

部署基于机器学习的网络安全应用可能会非常困难，因为存在概念漂移。无论是恶意软件分类、入侵检测还是在线滥用检测 $ \left\lbrack {6,{12},{17},{42},{48}}\right\rbrack $，基于学习的模型都是在“封闭世界”假设下工作的，期望测试数据的分布大致与训练数据的分布相匹配。然而，实际情况往往并非如此。随着时间推移，数据分布可能会发生变化，导致模型在新的数据分布上表现不佳。这种现象称为概念漂移，它对模型的性能造成了严重的影响。


Figure 1: 漂移样本检测与解释。

环境中的模型部署通常随时间动态变化。这样的变化可能包括良性玩家的有机行为变化以及攻击者的恶意突变和适应。因此，测试数据分布从原始训练数据转移，这可能导致模型出现严重失败[23]。

为了应对概念漂移，大多数基于学习的模型需要定期重新训练 $ \left\lbrack {{36},{39},{52}}\right\rbrack $。然而，重新训练往往需要标注大量的新样本（成本高昂）。更重要的是，确定何时重新训练模型也相当困难。延后的重新训练可能会使过时的模型容易受到新的攻击。

我们设想对抗概念漂移需要建立一个监控系统来检查流入的数据流与训练数据（以及/或当前的分类器）之间的关系。高层的想法如图1所示。当原始分类器在生产空间中工作时，另一个系统应该定期检查它对流入的数据样本做出决策的资格。一个检测模块（O）可以过滤出那些远离训练空间漂移的样本。更重要的是，为了解释漂移的原因（例如，攻击者的变异、有机行为的变化、之前未知的系统漏洞），我们需要一种解释方法（2）将检测决策与具有语义意义的特征联系起来。这些两种能力对于为开放世界环境准备基于学习的安全应用至关重要。

先前的工作已经探索了通过直接检查原始分类器的预测信心来检测漂移样本的方法（O）[32]。低信心得分可能表明传入的样本是漂移样本。然而，这个信心得分是基于所有类别都已知的假设（封闭世界）计算的概率（总和为1.0）。不属于任何现有类别的漂移样本可能会被错误地分配给一个错误的类别（由现有工作 $ \left\lbrack {{25},{32},{37}}\right\rbrack $ 验证）。最近的一项工作提出了计算新样本与现有类别之间的非一致性度量以确定适应性的想法[38]。这种非一致性度量是基于一个距离函数来量化样本之间的差异。然而，我们发现，尤其是在数据稀疏且维度高的情况下，这样的距离函数很容易失去效力。


请注意，"non-conformity measure" 被翻译为 "非一致性度量"，"distance function" 被翻译为 "距离函数"，"closed-world" 被翻译为 "封闭世界"，"conformity" 被翻译为 "一致性"，"dissimilarity" 被翻译为 "差异"。
我们的方法。在本文中，我们提出了一种新的方法来检测漂移样本，并辅以一种新颖的方法来解释检测决策。我们共同建立了一个名为CADE的系统，即“对比自编码器用于漂移检测和解释”的缩写。关键挑战是导出一个有效的距离函数来测量样本的不相似性。而不是任意选择距离函数，我们利用对比学习[29]的想法从现有的训练数据中学习距离函数，基于现有的标签。给定原始分类器训练数据（多个类别），我们将训练样本映射到一个低维潜空间。映射函数通过对比样本来学习，以增大不同类别样本之间的距离，同时减小同一类别样本之间的距离。我们展示了在潜空间中得到的距离函数能够有效地检测和排名漂移样本。


为了解释漂移样本，我们识别出一组重要的特征，这些特征区分了这个样本与其最近的类别。一个关键的观察是，传统的（监督的）解释方法并不适用于这个情况 $ \left\lbrack {{22},{28},{53},{62}}\right\rbrack $ 。这个见解是，监督解释方法需要两个类别（漂移样本和现有类别）都有足够的样本来估计它们的分布。然而，由于漂移样本位于训练分布之外的空间稀疏区域，这个要求很难满足。相反，我们发现基于距离变化的解释更为有效，即那些导致漂移样本与其最近类别之间的距离发生最大变化的特征。

评测。我们使用两个数据集来评估我们的方法，包括一个Android恶意软件数据集[7]和一个在2018年发布的内存入侵检测数据集[57]。我们的评测显示，我们的漂移检测方法非常准确，平均$ {F}_{1} $分数高于0.96，这优于各种基线和现有方法。我们的分析还展示了使用对比学习减少检测决策模糊性的好处。对于解释模型，我们进行了定量和定性的评估。案例研究也显示，选定的特征与漂移样本的语义行为相匹配。

此外，我们还与安全公司合作者一起，在他们的内部恶意软件数据库上测试了CADE。作为初步测试，我们从395个家族中获得了20,613个Windows PE恶意软件样本，这些样本出现在2019年8月至2020年2月之间。这使我们能够在多样化的环境中测试系统的性能，并与更多的恶意软件家族进行测试。结果令人鼓舞。例如，当在10个家族上进行训练并在160个未见过的家族上进行测试时，CADE实现了$ {F}_{1} $分数为0.95。这导致了对CADE在生产系统中进一步测试和部署的兴趣。

贡献。本文有三项主要贡献。

- 我们提出CADE来补充现有的基于监督学习的网络安全应用，以对抗概念漂移。我们介绍了一种基于对比性表征学习检测漂移样本的有效方法。

- 我们展示了监督式解释方法在解释异常样本时的局限性，并介绍了一种基于距离的解释方法，以应对这种情况。

- 我们广泛地评估了提出的这些方法，并将其应用于两个不同的场景。与一家安全公司的初步测试表明，CADE是有效的。我们已经在[1]中发布了CADE的代码，以支持未来的研究。

## 2 背景与问题范围

在本节中，我们介绍了安全应用背景下的概念漂移，并讨论了一些可能解决方案的局限性。

概念漂移。在许多安全上下文中，监督机器学习已被用于训练检测模型。当部署在实际中时，概念漂移是这些模型面临的主要挑战之一。当测试数据分布偏离原始训练数据时，就会发生概念漂移，导致真实决策边界发生变动[23]。这通常会导致随着时间的推移，原模型出现重大错误。

为了检测概念漂移，研究人员提出了各种技术，这些技术大多涉及收集新的数据集，以统计方式评估模型的行为$ \left\lbrack {9,{10},{20},{31}}\right\rbrack $。对于这些工作中的某些，它们还需要数据标注的努力。在安全应用中，知道存在新的攻击并且收集有关它们的数据首先就是一项挑战。此外，数据标注耗时且需要大量的专业知识。因此，假设大多数传入数据都能得到充分的标注是不切实际的。

除了监督模型，半监督异常检测系统也不一定能够免受概念漂移的影响。例如，大多数网络入侵检测系统都是



除了监督模型，半监督异常检测系统也不一定能够免受概念漂移的影响。例如，大多数网络入侵检测系统都是

---


$ {}^{1} $ https://github.com/whyisyoung/CADE

---


学习了“正常”交通的数据，然后用于检测与学习到的“正常”模式不符的入站交通作为攻击。对于这样的系统，它们可能会检测到以前未知的攻击；然而，概念漂移，尤其是在良性交通中，可能会轻易导致模型失败。本质上，入侵检测仍然是一个分类问题，即区分正常交通和异常交通。其训练仅使用一类数据进行。这在一定程度上削弱了学习成果。这些系统仍然依赖于这样一个假设，即正常数据已经涵盖了所有可能的情况——这在测试阶段经常被违反。


我们的问题范围。我们不是用准备好的全标记数据来检测概念漂移，而是关注一个更实用的场景。如图1所示，我们研究个别样本，以检测那些偏离原始训练数据的样本。这使我们能够在样本到达时检测到漂移样本并标记（一部分）它们。一旦我们积累了足够的漂移样本，我们就可以评估重新训练模型的需要。

在多类分类设置中，存在两种主要类型的概念漂移。类型A：引入新类：漂移样本来自一个新类，该类在训练数据集中不存在。因此，原本训练的分类器无法对漂移样本进行分类；类型B：内部类进化：漂移样本仍然来自现有类，但它们的行为模式与训练数据集中的行为模式有显著差异。在这种情况下，原始分类器在这些漂移样本上很容易出错。

在这篇论文中，我们主要关注类型A概念漂移，即在多类设置中引入一个新的类别。以恶意软件分类为例（图1），我们的目标是检测和解释从现有训练数据中的所有类别未见过的恶意软件家族中出现的漂移样本。本质上，漂移样本是对所有现有类别的训练数据的出界样本。在第六节中，我们探讨了将我们的解决方案适应于解决类型B概念漂移（内部类进化），并检查了我们方法的一般化能力。

可能的解决方案与限制。我们简要讨论了解决这一问题的可能方向以及限制。

第一个方向是使用原始分类器的预测概率。更具体地说，监督分类器通常会输出一个预测概率（或信心）作为预测标签的副产品[32]。例如，在深度神经网络中，softmax函数经常用于产生一个预测概率，该概率表示给定样本属于现有类别的可能性（总和为1）。因此，一个低的预测概率可能表明传入的样本与现有训练数据不同。然而，我们认为预测概率在我们的问题上下文中不太可能有效。原因在于这个概率反映了相对于现有类别的相对适应性（例如，样本更适合于类A而不是类B）。如果样本来自一个全新的类（既不是类A也不是类B），那么预测概率可能会误导人。许多先前的研究[25,32,37]已经表明，来自新类别的测试样本可能导致误导性的概率分配（例如，将一个错误的类与一个高的概率关联起来）。从根本上说，预测概率仍然继承了分类器的“封闭世界假设”，因此不适合检测漂移样本。

与预测概率相比，评估样本与给定类别的直接适应性是一个更有希望的方向。想法是，而不是评估样本是否比其他样本更适合类A或类B，我们评估这个样本在类A中的适应性与其他类A中的训练样本相比如何。例如，可以使用自编码器[33]来根据重建误差评估样本与给定分布的适应性。然而，作为一种无监督方法，当忽略标签时，很难学习训练分布的准确表示（见第4节）。最近的一项工作，Jordaney等人介绍了一个名为Transcend[38]的系统。它将“非一致性度量”定义为适应性评估。Transcend使用可信性$ p $ -值来量化测试样本$ \mathbf{x} $与共享相同类别的训练样本之间的相似性。$ p $是这个类中至少与$ \mathbf{x} $相似或更不相似的其他样本在该类中的比例。虽然这种度量可以定位漂移样本，但这样的系统对“不相似性”的良好定义高度依赖。正如我们在第4节中将展示的那样，任意的不相似性度量（尤其是当数据维度很高时）可能导致性能不佳。

## 3 设计CADE



我们提出一个名为CADE的系统，用于检测和解释漂移样本。我们首先描述我们的设计背后的直觉和洞察，然后是每个组件的技术细节。

## 3.1 我们的设计背后的洞察

如图 1 所示，我们的系统有两个组件：（1）检测偏离训练分布的样本；以及（2）解释这些偏离样本，以帮助分析师理解偏离的含义。经过初步分析，我们发现这两个任务都面临着一个共同的问题：偏离样本位于一个稀疏的异常点空间中，这使得难以推导出对于两个任务都需要的意义重大的距离函数。

首先，检测偏离样本需要学习一个好的距离函数，以衡量“偏离样本”与现有分布的不同。然而，异常点空间是无界的且非常稀疏。对于高维数据，距离的概念由于“维度灾难” [74] 而开始失去效力。其次，解释的目标是识别一小部分最重要的特征，这些特征能够最有效地区分偏离样本与训练数据。因此，我们也需要一个有效距离函数来衡量差异。

在接下来的部分中，我们将设计一个偏离检测模块和一个解释模块，共同解决这些挑战。在高级别上，我们首先使用对比学习来学习训练数据的压缩表示。对比学习的关键好处是，它能够利用现有的标签来达到比无监督方法，如自编码器 [33] 和主成分分析（PCA） [2] 更好的性能。这使我们能够从训练数据中学习一个检测偏离样本的距离函数（第 3.2 节）。对于解释模块，我们将描述一个基于距离的解释公式，以解决上述挑战（第 3.3 节）。

## 3.2 漂移样本检测

漂移检测模型监控传入的数据样本，以检测传入的样本不在训练数据的分布范围内。

对比学习对于潜在表示。我们探讨了对比学习以学习训练数据的良好表示。对比学习利用训练数据中现有的标签来学习一个有效的距离函数来测量不同样本的相似度（或对比度）[16]。与监督分类器不同，对比学习的目标不是将样本分类到已知类别。它的目标是学习如何比较两个样本。

如图2所示，给定输入样本（高维特征向量），对比学习模型旨在将它们映射到一个低维隐空间。该模型被优化，使得在隐空间中，同一类别的样本对之间的距离较小，而不同类别的样本对之间的距离较大。因此，隐空间中的距离度量可以反映样本对之间的差异。任何表现出与所有现有类别有较大距离的新样本都是候选漂移样本。

为了实现这个想法，我们使用了一个带有对比损失的自编码器。自编码器是一个有用的工具，用于学习给定输入分布的压缩表示（具有减少的维度）[33]。形式上，设 $ \mathbf{x} \in {\mathbb{R}}^{q \times 1} $ 是给定训练集的一个样本。我们训练一个包含编码器 $ f $ 和解码器 $ h $ 的自编码器。注意，$ f $ 是由 $ \mathbf{\theta } $ 参数化的；$ h $ 是由 $ \mathbf{\phi } $ 参数化的。我们构造损失函数如下：



最小化 \(\mathbf{\theta },\mathbf{\phi }\) 对于 \(\mathbf{x}\) 的期望 \(\parallel \mathbf{x} - \widehat{\mathbf{x}}{\parallel }_{2}^{2}\) 加上 \(\lambda\) 对 \(\mathbf{x}_{i},\mathbf{x}_{j}\) 的期望 \(\left\lbrack \left( {1 - {y}_{ij}}\right) {d}_{ij}^{2} + {y}_{ij}{\left( m - {d}_{ij}\right) }_{ + }^{2}\right\rbrack\)。

翻译后的文本。

在此，第一个术语是自动编码器的重建损失。更具体地说，编码器$ f $的目标是学习原始输入的良好表征。给定一个输入$ \mathbf{x} $，编码器$ f $将原始输入$ \mathbf{x} $映射到一个低维表征$ \mathbf{z} = f\left( {\mathbf{x};\mathbf{\theta }}\right) $。自动编码器确保了这个潜在


图2：对比学习的高级概念。

表征 $ z $ 可以解码以重建原始输入，且重构损失最小。在这里，$ \widehat{\mathbf{x}} \in {\mathbb{R}}^{q \times 1} $ 是这个原始输入的重构，即，$ \widehat{\mathbf{x}} = h\left( \mathbf{z}\right) $。这个损失项代表了 $ \mathbf{x} $ 和 $ \widehat{\mathbf{x}} $ 之间的均方误差。

第二个方程式（1）项指的是对比损失，它以一对样本 $ \left( {{\mathbf{x}}_{i},{\mathbf{x}}_{j}}\right) $ 和它们的关系 $ {y}_{ij} $ 作为输入。如果两个样本来自不同的类别，则 $ {y}_{ij} = 1 $；如果两个样本来自同一类别，则 $ {y}_{ij} = 0 $。$ {\left( \cdot \right) }_{ + } $ 是对 $ \max \left( {0, \cdot }\right) $ 的简写，而 $ {d}_{ij} $ 是隐空间表征 $ {\mathbf{z}}_{i} = f\left( {{\mathbf{x}}_{i};\mathbf{\theta }}\right) $ 和 $ {\mathbf{z}}_{j} = f\left( {{\mathbf{x}}_{j};\mathbf{\theta }}\right) $ 之间的欧氏距离，其中 $ \mathbf{z} \in {\mathbb{R}}^{d \times 1}\left( {d \ll p}\right) $。这个损失项最小化如果它们来自同一类别，则 $ {\mathbf{x}}_{i} $ 和 $ {\mathbf{x}}_{j} $ 在隐空间中的距离，并最大化它们之间的距离，直到半径 $ m > 0 $ 被定义，这样不相似的配对只在其距离在这个半径内时才对损失函数做出贡献。$ \lambda $ 是损失函数中第二个项的超参数。

在对比学习之后，编码器 $ f $ 可以将输入样本映射到一个低维的隐空间中，其中每个类形成紧密的群体（如图2所示）。在这个隐空间中，距离函数可以有效地识别新样本从这些群体中漂移开的情况。

基于MAD的漂移样本检测。在训练对比自编码器之后，我们可以使用它来检测漂移样本。给定一组测试样本 $ K $ $ \left\{ {\mathbf{x}}_{t}^{\left( k\right) }\right\} (k = $ $ 1,\ldots, K) $，我们寻求确定每个样本 $ {\mathbf{x}}_{t}^{\left( k\right) } $是否相对于训练数据中的现有类别是漂移样本。检测方法如算法1所示。

假设训练集有 $ N $ 个类别，每个类别有 $ {n}_{i} $ 个训练样本，对于 $ i = 1,2,\ldots, N $ 。我们首先使用编码器将所有训练样本映射到隐空间中（第2-4行）。对于每个类别 $ i $，我们计算其质心 $ {\mathbf{c}}_{i} $（通过在欧几里得空间中取每个维度的平均值，第5行）。给定一个测试样本 $ {\mathbf{x}}_{t}^{\left( k\right) } $，我们也使用编码器将其映射到隐空间表示 $ {\mathbf{z}}_{t}^{\left( k\right) } $（第14行）。然后，我们计算测试样本与其质心之间的欧氏距离：$ {d}_{i}^{\left( k\right) } = {\begin{Vmatrix}{\mathbf{z}}_{t}^{\left( k\right) } - {\mathbf{c}}_{i}\end{Vmatrix}}_{2} $（第16行）。根据其到质心的距离，我们确定这个测试样本是否对于 $ N $ 个类别中的每一个都是分布外的。在这里，我们根据样本到质心的距离而不是样本到最近训练样本的距离做出决策。这是因为后一种选择很容易受到训练数据中的异常点的影响。

---


算法1：对比性自编码器驱动检测。

训练数据 $ {\mathbf{x}}_{i}^{\left( j\right) }, i = 1,\ldots, N, j = 1,\ldots ,{n}_{i}, N $ 表示类别数量，$ {n}_{i} $ 表示类别 $ i $ 下的训练样本数量；测试数据 $ {\mathbf{x}}_{t}^{\left( k\right) } $，$ t $ 指测试集，$ k = 1,\ldots, K, K $ 是总测试样本数量；编码器 $ f $；常数 $ b $。

输出: 每个测试样本的漂移分数 $ {A}^{\left( k\right) } $，最接近的类别 $ {y}_{t}^{\left( k\right) } $，每个类别的中心 $ {\mathbf{c}}_{i},{\mathrm{{MAD}}}_{i} $ 到每个类别。

对于班级$ i = 1 $到$ N $做

对于 $ j = 1 $ 到 $ {n}_{i} $ 做

$ {\mathbf{z}}_{i}^{\left( j\right) } = f\left( {{\mathbf{x}}_{i}^{\left( j\right) };\mathbf{\theta }}\right) \; \vartriangleright $ 第 $ j $ 层的 $ i $ 号样本的隐特征表示。

$ {\mathbf{c}}_{i} = \frac{1}{{n}_{i}}\mathop{\sum }\limits_{{j = 1}}^{{n}_{i}}{\mathbf{z}}_{i}^{\left( j\right) }\; \vartriangleright $ 第 $ i $ 类的中心点。

$ {d}_{i}^{\left( j\right) } = {\begin{Vmatrix}{\mathbf{z}}_{i}^{\left( j\right) } - {\mathbf{c}}_{i}\end{Vmatrix}}_{2} \vartriangleright $ 样本与质心的距离。

结束循环

$ {{\widetilde{d}}_{i} = \operatorname{median}\left( {d}_{i}^{\left( j\right) }\right), j = 1,\ldots ,{n}_{i} } $

$ {\operatorname{MAD}}_{i} = b * \operatorname{median}\left( \left| {{d}_{i}^{\left( j\right) } - {\widetilde{d}}_{i}}\right| \right), j = 1,\ldots ,{n}_{i} $

结束循环

: 对于 $ k = 1 $ 到 $ K $ 做

$ {{\bf z}}_t^{(k)} = f\left( {{\bf x}_t^{(k)}; \mathbf{\theta} }\right) $

对于班级$ i = 1 $到$ N $做

$ {d}_{i}^{\left( k\right) } = {\begin{Vmatrix}{\mathbf{z}}_{t}^{\left( k\right) } - {\mathbf{c}}_{i}\end{Vmatrix}}_{2} $

$ {A}_{i}^{\left( k\right) } = \frac{\left| {d}_{i}^{\left( k\right) } - {\widetilde{d}}_{i}\right| }{{\mathrm{{MAD}}}_{i}} $

结束循环

$ {A}^{\left( k\right) } = \min \left( {A}_{i}^{\left( k\right) }\right), i = 1,\ldots, N $

如果 $ {A}^{\left( k\right) } > {T}_{\mathrm{{MAD}}} $ 则 $ \; \vartriangleright {T}_{\mathrm{{MAD}}} $ 被设置为3.5，这是基于经验[40]。

$ {\mathbf{x}}_{t}^{\left( k\right) } $ 是一个潜在的漂移样本。

否则。

$ {\mathbf{x}}_{t}^{\left( k\right) } $ 是一个不漂移的样本。

结束 if 判断。

最近的类对于 $ {\mathbf{x}}_{t}^{\left( k\right) } $ 。

结束循环

---


为了根据 $ {d}_{i}^{\left( k\right) } $ 确定异常点，挑战在于不同类别的紧密度可能不同，因此需要不同的距离阈值。而不是手动为每个类别设置绝对距离阈值，我们使用了一种称为中位数绝对偏差（MAD）[40]的方法。想法是通过计算 $ {\mathrm{{MAD}}}_{i} $（第6-10行）来估计每个类别的数据分布 $ i $，它是中位数距离 $ {d}_{i}^{\left( j\right) }\left( {j = 1,\ldots ,{n}_{i}}\right) $ 的绝对偏差。在这里 $ {d}_{i}^{\left( j\right) } $ 表示类别 $ i $ 中每个样本与其质心的潜在距离，以及 $ {n}_{i} $ 是类别 $ i $ 中样本的数量（第7行）。然后基于 $ {\mathrm{{MAD}}}_{i} $，我们可以确定 $ {d}_{i}^{\left( k\right) } $ 是否足够大，使得测试样本 $ {\mathbf{x}}_{t}^{\left( k\right) } $ 成为类别 $ i $ 的异常点（第15-24行）。如果测试样本对于所有 $ N $ 个类别都是异常点，那么它被确定为一个漂移样本。否则，我们确定它是一个内分布样本，并且其最近的质心由最近的质心确定（第26行）。MAD的优势在于每个类别都有自己的距离阈值来根据其内类分布确定异常点。例如，如果一个簇更分散，阈值就会更大。


图 3：在我们的设置中，边界基于解释和距离基于解释的说明。

请注意，当一个类别的样本不足时，MAD可能会受到影响，因为它的中位数可能会变得不准确。在我们的设计中，对比学习可以帮助缓解这个问题，因为每个类别都被映射到一个紧凑的区域中，这有助于稳定中位数。

排名漂移样本。如图1所示，漂移样本可能需要分析师进一步调查以解释漂移的含义。鉴于分析师的时间有限，对漂移样本进行排名至关重要，以便分析师可以专注于调查最新颖的变体。我们使用一种简单的方法根据它们与最近邻中心的距离（在行26中计算）对漂移样本进行排名。这允许我们优先调查与最近邻中心最远的漂移样本。

## 3.3 解释漂移样本

解释模块旨在识别导致测试样本远离现有类别的最重要特征。具体来说，给定一个漂移样本 $ {\mathbf{x}}_{t} $，以及它在训练集中的最近类别 $ {y}_{t} $，我们希望识别出一小组特征，使 $ {\mathbf{x}}_{t} $ 成为类别 $ {y}_{t} $ 的异常点。为了实现这一目标，一种直觉反应是将它转化为解释监督学习模型的一个问题，这是一个研究广泛的问题。例如，我们可以将我们的漂移检测器（O）近似为一个分类器，并使用为分类器 $ \lbrack {28},{35} $ , $ {53},{58},{62}\rbrack $ 开发的存在解释方法来推导解释。然而，由于异常点空间的极高稀疏性，我们发现很难移动一个漂移样本跨越决策边界，因此无法推导出有意义的解释。受此启发，我们设计了一种专门为漂移检测设计的新的解释方法，该方法解释漂移样本与其同类样本之间的距离，而不是决策边界。下面，我们先分析“直截了当的方法”，然后描述我们的方法。

基准方法：边界基于解释。鉴于解释监督分类器的丰富文献，一种直观的方法是将漂移检测模块转换为监督学习模型，然后运行现有的解释算法。监督解释方法是为了解释两个类之间的决策边界（例如，类A和类B）。目标是识别${\mathbf{x}}_{t}$内的一个最小特征集，使得扰动这些特征会让${\mathbf{x}}_{t}$跨越决策边界。如图3所示，类A代表来自$ {y}_{t} $的训练样本，类B代表测试集中的检测到的漂移样本。决策边界用蓝色虚线表示（决策边界以距离阈值的形式表示）。给定一个漂移样本${\mathbf{x}}_{t}$（如图3中的星号表示），解释方法通过扰动一组重要特征将样本拉入正域类（即带有灰色画布的区域）。$ {}^{2} $我们使用现有的基于扰动的监督解释方法（文献[13]、[18]、[21]、[22]）实现了这个想法（附录A中的实现细节）。

评估结果如第5节所述，表明这种方法从根本上受到了限制。我们认为原因有二。首先，由于漂移样本的数量有限，很难为决策边界得出一个准确的近似模型。其次，更为重要的是，异常点空间远大于分布内区域。由于漂移样本远离决策边界，很难找到一组特征扰动，将漂移样本带过决策边界进入分布内区域。如果没有越过边界的能力，解释方法将无法获得必要的梯度（或反馈）来计算特征重要性。

我们的方法：基于距离的解释。受到这一观察的启发，我们提出了一种新的方法，该方法通过解释距离（如图3中的红色箭头所示）来识别重要的特征。与基于决策边界做出决策的监督分类器不同，漂移检测模型基于样本到中心点的距离做出决策。因此，我们的目标是找到一组原始特征，帮助漂移样本 $ {\mathbf{x}}_{t} $ 向最近的中心点 $ {\mathbf{c}}_{{y}_{t}} $ 移动。有了这种设计，我们就不再需要强迫 $ {\mathbf{x}}_{t} $ 跨越边界，这很难实现。相反，我们扰动原始特征并观察隐空间中的距离变化。

为了实现这个想法，我们首先需要设计一个特征扰动机制。大多数现有的扰动方法都是专门为图像设计的[18]，这些图像的特征是数值值。在我们的情况下，$ {\mathbf{x}}_{t} $的特征可以是数值的也可以是分类的，因此直接应用现有的方法将产生不明确的特征值。为了确保扰动对于数值和分类特征都是有意义的，我们提出通过替换特征值来扰动 $ {\mathbf{x}}_{t} $，这个特征值对应于参考训练样本 $ {\mathbf{x}}_{{y}_{t}}^{\left( c\right) } $ 中的特征值。这个 $ {\mathbf{x}}_{{y}_{t}}^{\left( c\right) } $ 是训练样本，它与中心点 $ {\mathbf{c}}_{{y}_{t}} $ 的潜在距离最短。这样一来，我们的解释目标就是识别一组特征，使得用 $ {\mathbf{x}}_{{y}_{t}}^{\left( c\right) } $ 中的特征替换它们，将对 $ f\left( {\mathbf{x}}_{t}\right) $ 和 $ {\mathbf{c}}_{{y}_{t}} $ 之间的距离产生最大的影响。替换

$ {}^{2} $ 请注意，我们不在隐空间中执行特征扰动，因为隐特征不携带语义含义。相反，我们在原始输入空间中选择特征。与 $ {\mathbf{x}}_{{y}_{t}}^{\left( c\right) } $ 的特征值也帮助确保扰动样本朝着中心点的粗略方向移动。与之前一样，扰动在原始特征空间中进行，其中特征具有语义含义。

我们使用一个 $ \mathbf{m} \in {\mathbb{R}}^{q \times 1} $ 来表示重要特征，其中 $ {\mathbf{m}}_{i} = 1 $ 表示 $ {\left( {\mathbf{x}}_{t}\right) }_{i} $ 被 $ {\left( {\mathbf{x}}_{{y}_{t}}^{\left( c\right) }\right) }_{i} $ 的值所替换，而 $ {\mathbf{m}}_{i} = 0 $ 表示我们保持 $ {\left( {\mathbf{x}}_{t}\right) }_{i} $ 的值不变。换句话说，$ {\mathbf{m}}_{i} = 1 $ 表示第 $ i $ 个特征被选为重要特征。这个特征掩码的每个元素 $ {\mathbf{m}}_{i} $ 可以从一个伯努利分布中采样，其概率为 $ {p}_{i} $。因此，我们可以保证 $ {\mathbf{m}}_{i} $ 等于 1 或 0。然后，我们的目标就转化为求解 $ {p}_{i} $，其中 $ i = 1,2,\ldots, q $。技术上，这可以通过对 $ {p}_{1 : q} $ 最小化以下目标函数来实现。

期望方差加正则化损失函数：
$$
{\mathbb{E}}_{\mathbf{m} \sim Q\left( \mathbf{p}\right) }{\begin{Vmatrix}{\widehat{\mathbf{z}}}_{t} - {\mathbf{c}}_{{y}_{t}}\end{Vmatrix}}_{2} + {\lambda }_{1}R\left( {\mathbf{m},\mathbf{b}}\right) ,
$$

$$
{\widehat{\mathbf{z}}}_{t} = f\left( {{\mathbf{x}}_{t} \odot \left( {1 - \mathbf{m} \odot \mathbf{b}}\right) + {\mathbf{x}}_{{y}_{t}}^{\left( c\right) } \odot \left( {\mathbf{m} \odot \mathbf{b}}\right) }\right) ,
$$


翻译文本。

$$
R\left( {\mathbf{m},\mathbf{b}}\right) = \parallel \mathbf{m} \odot \mathbf{b}{\parallel }_{1} + \parallel \mathbf{m} \odot \mathbf{b}{\parallel }_{2},\;Q\left( \mathbf{p}\right) = \mathop{\prod }\limits_{{i = 1}}^{q}p\left( {{\mathbf{m}}_{i} \mid {p}_{i}}\right) .
$$


请注意，$ \odot $ 表示逐元素乘法；$ {\widehat{\mathbf{z}}}_{t} $ 表示扰动样本的潜在向量。根据上述方程，直接计算 $ \mathbf{m} $ 很困难，因为其维度很高。为了加快搜索速度，我们引入了一个过滤器 $ \mathbf{b} $ 来预先过滤掉不值得考虑的特征。我们设定 $ {\left( \mathbf{b}\right) }_{i} = 0 $，如果 $ {\left( {\mathbf{x}}_{t}\right) }_{i} $ 和 $ {\left( {\mathbf{x}}_{{y}_{t}}^{\left( c\right) }\right) }_{i} $ 是相同的。换句话说，如果 $ {\mathbf{x}}_{t} $ 的特征值与参考样本 $ {\mathbf{x}}_{{y}_{t}}^{\left( c\right) } $ 的特征值相同，那么这个特征在优化过程中被排除（因为它不会影响距离的变化）。这样，$ {\widehat{\mathbf{z}}}_{t} = f\left( {{\mathbf{x}}_{t} \odot \left( {1 - \mathbf{m} \odot \mathbf{b}}\right) + {\mathbf{x}}_{{y}_{t}}^{\left( c\right) } \odot \left( {\mathbf{m} \odot \mathbf{b}}\right) }\right) $ 表示扰动样本的潜在向量。

在方程（2）中，损失函数中的第一个项旨在最小化扰动样本 $ {\widehat{\mathbf{z}}}_{t} $ 与类别 $ {y}_{t} $ 的中心 $ {\mathbf{c}}_{{y}_{t}} $ 的潜空间距离。$ \mathbf{m} $ 中的每个元素是从参数为 $ {p}_{i} $ 的伯努利分布中采样的。在这里，我们使用 $ Q\left( \mathbf{p}\right) $ 来代表它们的联合分布。$ {}^{3} $ 对于第二个项，$ \lambda $ 是一个超参数，控制弹性网正则化 $ R\left( \cdot \right) $ 的强度，它限制了 $ \mathbf{m} $ 中非零元素的数量。通过最小化 $ R\left( {\mathbf{m},\mathbf{b}}\right) $，优化过程选择了一个最小的重要特征子集。

请注意，伯努利分布是离散的，这意味着相对于 $ {p}_{i} $ 的 $ {\mathbf{m}}_{i} $ 的梯度（即 $ \frac{\partial {\mathbf{m}}_{i}}{\partial {p}_{i}} $ ）没有明确的定义。我们不能通过梯度优化方法来解决式（2）中的优化问题。为了解决这个挑战，我们引用了[45]中的变量变换技巧。通过用连续近似（即实数分布）替换伯努利分布，该分布由 $ {p}_{i} $ 参数化，我们使梯度计算成为可能。然后，我们可以通过梯度优化方法（本文中我们使用Adam优化器）来解决参数 $ {p}_{1 : q} $ 。

我们假设每个特征是从一个不同的伯努利分布中独立抽取的。

<table><thead><tr><th></th><th>Id</th><th>Family</th><th># of Samples</th></tr></thead><tr><td></td><td>0</td><td>FakeInstaller</td><td>925</td></tr><tr><td></td><td>1</td><td>DroidKungFu</td><td>667</td></tr><tr><td></td><td>2</td><td>Plankton</td><td>625</td></tr><tr><td></td><td>3</td><td>GingerMaster</td><td>339</td></tr><tr><td></td><td>4</td><td>BaseBridge</td><td>330</td></tr><tr><td></td><td>5</td><td>Iconosys</td><td>152</td></tr><tr><td></td><td>6</td><td>Kmin</td><td>147</td></tr><tr><td></td><td>7</td><td>FakeDoc</td><td>132</td></tr><tr><td colspan="4">Total:3,317</td></tr></table>


表 1：Drebin 数据集中的 Android 恶意软件样本。

## 4 评估：漂移检测

在本节中，我们使用两个安全应用程序来评估我们的系统：Android恶意软件家族归属，以及网络入侵检测。在本节（第4节）中，我们专注于漂移检测模块的评估。我们将在第5节中评估解释模块。在这些受控实验之后，我们在安全公司的恶意软件数据库上测试了我们的系统（第7节）。

## 4.1 实验设置和数据集

Android恶意软件归属。我们使用Drebin数据集[7]来探索恶意软件家族归属问题。原始分类器（图1中的$ \mathbf{O} $模块）是一个多层感知机（MLP）分类器。它识别一个恶意软件样本属于哪个家族。Drebin数据集包含5,560个Android恶意软件样本。对于这次评估，我们选择了8个家族$ {}^{4} $，每个家族至少有100个恶意软件样本（总共3,317个样本，见表1）。

为了评估漂移样本检测模块，对于每项实验，我们选择8个家族中的一个作为未知的家族。例如，假设我们选择了“FakeDoc”（第7家族）作为未知家族。我们将其他七个家族分成训练集和测试集，并将“FakeDoc”仅添加到测试集。这样，在训练期间“FakeDoc”是不可用的。我们的目标是正确地识别测试时间来自“FakeDoc”的样本作为漂移样本。

我们将训练集和测试集的比例分为80:20。分割基于时间戳（恶意软件创建时间），这是多项工作[52,65]推荐的做法，以模拟一个现实的环境。基于时间的分割也意味着我们不能在训练模型时使用仅出现在测试集中的新特征。这使我们只剩下7,218个特征。然后，我们使用scikit-learn的VarianceThreshold函数[51]来移除方差非常低的特征（即，$ < {0.003} $），这创造了最终的1,340个特征集。

<table><thead><tr><th>Id</th><th>Family</th><th># of Flows</th></tr></thead><tr><td>0</td><td>Benign</td><td>66,245</td></tr><tr><td>1</td><td>SSH-Bruteforce</td><td>11,732</td></tr><tr><td>2</td><td>DoS-Hulk</td><td>43,487</td></tr><tr><td>3</td><td>Infiltration</td><td>9,238</td></tr><tr><td colspan="3">Total:130,702</td></tr></table>


表 2：网络入侵数据集：来自 IDS2018 数据集的 3 个网络入侵类别和一个良性类别。

为了展示结果的泛化能力，我们迭代地选择每个恶意软件家族作为“未见家族”并重复实验。

网络入侵检测。我们使用一个网络入侵数据集[57]，我们将其称为IDS2018。该数据集包含不同类型的网络轨迹，这些轨迹是由已知攻击生成的。为了我们的评估，我们选择良性类别（一天的流量）和三种不同的攻击类别：SSH-Bruteforce、Dos-Hulk和Infiltration。SSH-Bruteforce是一种暴力攻击，用于猜测SSH登录密码。DoS-Hulk攻击旨在向目标机器发送多余的请求，试图使机器暂时不可用。Infiltration攻击首先发送带有恶意附件的电子邮件，利用主机应用程序的漏洞，然后利用后门运行端口扫描，以发现更多的漏洞。我们对感兴趣的读者[57]提供了更多关于攻击的详细信息。为了加快实验并测试不同的设置，我们使用了其流量的$ {10}\% $作为实验数据集（表2）。在附录D中，我们展示了更多的流量只会增加计算开销，并且对所选方法的性能几乎没有影响。

我们迭代地选择攻击家族中的一个作为未见过的家族，并在测试集中只包含这个家族。我们重复实验以报告平均性能。我们将训练-测试集的比例分为80:20。请注意，IDS2018数据集中的特征需要进一步归一化和编码。为了现实性，我们只使用训练数据来构建特征编码方案。在较高层次上，每个样本代表一个网络流量。诸如“目的地端口”和“网络协议”的分类特征使用独热编码进行编码。其他77个统计特征被归一化到0和1之间，使用一个MinMaxS-caler。每个网络流量有83个特征。我们发布的代码的详细特征工程步骤可在文档中找到。

评估指标。对于漂移检测模块（图1中的模块 $ \mathbf{O} $），正样本是测试集中的未见家族样本。负样本是已知家族的其余测试样本。给定一个检测样本的排名列表，我们模拟分析师从列表的顶部检查样本。随着我们从列表的顶部向下移动，我们计算三种评估指标：精确度、召回率和 $ {F}_{1} $ 分数。精确度衡量真阳性与所有预测阳性的比率。召回率衡量真阳性与所有实际阳性样本的比例。 $ {F}_{1} $ 分数是一个精确度和召回率的调和平均值，用于衡量检测性能。

---


$ {}^{4} $ 两个家族 FakeInstaller 和 Opfake 在攻击的本质方面非常相似。在它们的家族标签方面存在强烈的分歧，即样本在某些引擎中被标记为一种家族，而在其他引擎中被标记为另一种家族。因此，我们只包括了 FakeInstaller（表 1）。

---


translated text.


超出

图 4：精确度和召回率与检查样本的数量（根据各自方法对漂移样本进行排名）。

<table><thead><tr><th rowspan="2">方法</th><th colspan="4">Drebin $ \left( {\mathrm{{Avg}} \pm \mathrm{{Std}}}\right) $</th><th colspan="4">IDS2018 (Avg $ \pm $ Std)</th></tr><tr><th>精确度</th><th>召回率</th><th>$ {F}_{1} $</th><th>正常努力</th><th>精确度</th><th>召回率</th><th>$ {F}_{1} $</th><th>正常努力</th></tr></thead><tr><td>原版AE</td><td>$ {0.63} \pm {0.17} $</td><td>$ {0.88} \pm {0.13} $</td><td>$ {0.72} \pm {0.15} $</td><td>$ {1.48} \pm {0.31} $</td><td>$ {0.61} \pm {0.16} $</td><td>$ {0.99} \pm {0.00} $</td><td>$ {0.74} \pm {0.12} $</td><td>$ {1.74} \pm {0.40} $</td></tr><tr><td>超越</td><td>$ {0.76} \pm {0.19} $</td><td>$ {0.90} \pm {0.14} $</td><td>$ {0.80} \pm {0.12} $</td><td>$ {1.29} \pm {0.45} $</td><td>$ {0.64} \pm {0.45} $</td><td>$ {0.67} \pm {0.47} $</td><td>$ {0.65} \pm {0.46} $</td><td>$ {1.45} \pm {0.57} $</td></tr><tr><td>CADE</td><td>$ {0.96} \pm {0.05} $</td><td>$ {0.96} \pm {0.04} $</td><td>$ {0.96} \pm {0.03} $</td><td>$ {1.00} \pm {0.09} $</td><td>$ {0.98} \pm {0.02} $</td><td>$ {0.93} \pm {0.09} $</td><td>$ {0.96} \pm {0.06} $</td><td>$ {0.95} \pm {0.07} $</td></tr></table>

表 3：Drebin 和 IDS2018 数据集上的漂移检测结果。我们比较了 CADE 与两种基线 Transcend [38] 和 Vanilla AE。对于每个评估指标，我们都报告了所有设置下的平均值和标准差。


图5：$ {F}_{1} $ 评分漂移图6：归一化调查-检测。

未见家族样本中的样本。召回率衡量检测模块成功发现的所有未见家族样本的比例。$ {F}_{1} $分数是精确度和召回率的调和平均值：$ {F}_{1} = 2 \times \frac{\text{ 精确度 } \times \text{ 召回率 }}{\text{ 精确度 } + \text{ 召回率 }} $ 。最后，为了量化检查的努力，我们定义了一个称为检查努力度量的指标，它是检查的总样本数，除以测试集中真实未见家族样本的数量。

基准方法。我们包括两种主要的基础线。第一个基础线是一个标准的Vanilla自编码器[33]，它用于说明对比学习的好处。我们将Vanilla自编码器（AE）设置为与CADE相同的层数和输出维数。我们使用它来进行维度降低，将输入映射到一个潜空间中，在那里我们使用相同的MAD方法来检测和排名漂移样本。这个基线的差异与CADE不同，因为该基线不进行对比学习。超参数设置见附录B。

第二个基线是Transcend [38]。如第2节所述，Transcend定义了一个“非一致性度量”来量化输入样本与预测类之间的吻合程度，并计算一个可信度 $ p $ -值来确定输入样本是否为漂移样本。我们从作者那里获得了Transcend的源代码，并遵循论文中的描述，对实现进行了调整，以支持多类分类（原始代码只支持二元分类）。具体来说，我们使用 $ - p $ 初始化非一致性度量，其中 $ p $ 是softmax输出概率，表示测试样本属于给定家族的概率。然后我们计算测试样本的可信度 $ p $ -值。如果对于所有现有家族，$ p $ -值接近零，我们将其视为漂移样本。我们根据最大可信度 $ p $ -值对漂移样本进行排名。请注意，我们没有使用其他异常检测方法 $ \left\lbrack {{14},{41},{49}}\right\rbrack $ 作为我们的基线，主要是因为它们的工作设置与CADE和Transcend不同。更具体地说，这些方法在训练过程中需要一个辅助的异常数据集，或者需要修改原始分类器。对于生产环境中的恶意软件分类器，这些要求很难满足（第9节中有更详细的讨论）。

## 4.2 评估结果

在本节中，我们首先比较了 CADE 的漂移检测性能与基线，并评估了对比学习的影响。然后，我们进行案例研究，以调查检测错误的原因。

漂移样本检测性能。首先，我们使用一个实验设置来解释我们的评估过程。以Drebin数据集为例。假设我们在测试集中使用家庭Iconosys作为未见过的家庭。在训练检测模型（没有任何Iconosys样本）之后，我们使用它来检测并排名漂移样本。为了评估排名列表的质量，我们模拟分析师从列表顶部检查样本。

图4a显示，随着我们检查更多的漂移样本（最多150个样本），精度保持在很高的水平（超过0.97），而召回率逐渐达到$ {100}\% $。结合


图 8：Drebin 数据集中的测试样本与其原始空间和隐空间中最近聚类中心的距离的箱形图。来自先前未见家族的样本被视为漂移样本。

准确性和召回率的最高 $ {F}_{1} $ 分数为0.98。在150个样本之后，精度会下降，因为剩余的集合中不再有未见过的家庭样本。这确认了排名列表的高质量，这意味着几乎所有未见过的家庭样本都排在最前面。

作为比较，Transcend和Vanilla $ \mathrm{{AE}} $的排名列表不那么令人满意。对于Transcend（图4b），前150个样本的精度召回都很低，这表明前排的样本不是来自未见过的家族。在检查了150个样本后，我们开始看到更多的来自未见过的家族的样本。在检查了350个样本后，Transcend已经覆盖了大部分来自未见过的家族的样本（即召回率接近1.0），但精度只有0.46。这意味着分析师检查的样本中有一半是不相关的。最佳 $ {F}_{1} $ 分数为0.63。如图 $ 4\mathrm{c} $ 所示，Vanilla $ \mathrm{{AE}} $的表现更差。即使在检查了600个样本后，召回率也只有略高于0.8。

为了概括观察结果，我们迭代地对待每个家族作为未见的家族，并计算不同设置下的平均统计数据，以获得 $ {F}_{1} $ 分数（见图5）和归一化的检查努力（见图6）。表3进一步展示了相应的精确度和召回率。对于每种实验设置，我们报告了每个模型的最高 $ {F}_{1} $ 分数。这个 $ {F}_{1} $ 分数是在分析家沿着排名列表向下移动并停止检查时实现的，当他们开始获得大量误报时。“检查努力”是指达到报告的 $ {F}_{1} $ 分数的总检查样本数，该数被测试集中的真实漂移样本数归一化。

表3确认了CADE能够准确地检测漂移样本，并且超过了两个基线。在Drebin上，CADE的平均$ {F}_{1} $分数为0.96，而基线的$ {F}_{1} $分数分别为0.80和0.72。对于IDS2018数据集，也能得出类似的结论。此外，CADE的标准差远小于基线的标准差，表明在不同实验设置中性能更加一致。最后，我们展示了CADE具有较低的归一化检查努力，这证实了排名的高质量。

请注意，Transcend基线在实际应用中某些情况下表现良好。例如，当DoS-Hulk设置为IDS2018数据集中未见过的家族时，其$ {F}_{1} $分数为$ {99.69}\% $（与我们系统的性能相似）。然而，问题在于Transcend的性能在不同设置中不够稳定，这在表3中的高标准偏差中得到了反映。

对比学习的影响。为了理解性能提升的来源，我们考察了对比学习的效应。首先，我们展示了一个可视化图，如图7所示，该图显示了Drebin数据集的训练样本和来自选定的未知家族（FakeDoc）的测试样本的t-SNE图。t-SNE [66]执行其自身的非线性降维，将数据样本投影到一个二维图中。为了可视化我们的数据样本，我们将样本从原始空间 $ \left( {1,{340}\text{维度}}\right) $ 映射到一个二维空间（图7a）。我们也将样本从隐空间（7维度）映射到二维空间进行比较（图 $ 7\mathrm{\;b} $ 和图 $ 7\mathrm{c} $ ）。我们可以观察到，CADE的隐空间中的样本形成了更紧凑的簇，使得更容易将现有样本与未知家族区分开来。

为了提供不同实验设置下的统计视角，我们绘制了图8。与之前一样，我们迭代地选取一个家族作为Drebin中的不可见家族。然后我们在原始特征空间（图8a）和CADE生成的隐空间（图8b）中测量测试样本与其最近聚类中心的距离。IDS2018数据集的结果具有相同的结论，因此为了简洁省略了它们。我们展示了在原始空间中漂移样本和非漂移样本更难以分离。在对比学习之后，隐空间中的分离更为明显。原因在于对比学习已经学习了适合的距离函数，该函数可以进一步拉伸不同类别的样本，使得更容易检测到不可见家族。

案例研究：CADE的局限性。CADE在大多数设置中表现良好。然而，我们发现，在某些情况下，CADE的性能不佳。例如，当使用Fake-Installer作为未知的家族时，我们的检测精度仅为$ {82}\% $，而召回率达到$ {100}\% $。我们注意到，许多来自GingerMaster和Plankton家族的测试样本被检测为漂移样本。经过更仔细的检查，我们发现，当FakeInstaller被视为未知家族时，为了保持整体80:20的训练-测试比例，我们需要在GingerMaster和Plankton家族的训练样本数量还不足时分割数据集。因此，许多来自GingerMaster和Plankton家族的测试样本在外观上与这两个家族的小数量训练样本（基于潜在距离）有很大差异。外部证据也表明，这两个家族有许多变体$ \left\lbrack {5,{70}}\right\rbrack $。虽然这些恶意软件变体不是来自新的家族（在我们的定义下为假阳性），但它们也可能对理解同一家族内的恶意软件变异有价值。

## 5 评估：解释漂移样本

为了评估解释模块，我们从每个数据集（即 Drebin 的 FakeDoc 和 IDS2018 的 Infiltration）中随机选择一个家族作为漂移样本。其他设置的结果具有相同的结论，因此为了简洁，省略了这些结果。基于这种设置，我们对检测到的漂移样本生成解释，并对解释结果进行定量和定性的评估。

<table><thead><tr><th>方法</th><th>Drebin-FakeDoc 平均 $ \pm $ 标准差</th><th>IDS2018-Infiltration 平均 $ \pm $ 标准差</th></tr></thead><tr><td>原始距离</td><td>5.363 $ \pm $ 0.568</td><td>$ {11.715} \pm {2.321} $</td></tr><tr><td>随机</td><td>5.422 $ \pm $ 1.773</td><td>$ {11.546} \pm {3.169} $</td></tr><tr><td>边界基于</td><td>$ {3.960} \pm {2.963} $</td><td>$ {6.184} \pm {3.359} $</td></tr><tr><td>COIN [43]</td><td>$ {6.219} \pm {3.962} $</td><td>$ {8.921} \pm {2.234} $</td></tr><tr><td>CADE</td><td>0.065 $ \pm $ 0.035</td><td>2.349 $ \pm $ 3.238</td></tr></table>

表 4：基于与最近聚类中心距离的平均值比较解释的精确度。较短的距离更好。“原始距离”是漂移样本与最近聚类中心的距离。

## 5.1 实验设置

基线方法。我们考虑三种基线方法：（1）随机基线，它随机选择特征作为重要特征；(2) 第3节描述的基于边界的解释方法，以及（3）一种称为COIN[43]的无监督解释方法。由于空间限制，我们只简要描述COIN的工作原理。COIN构建一组局部线性SVM分类器来区分单个异常点与其分布邻域样本。由于线性SVM分类器是自解释的，它们可以 pinpoint重要特征，这些特征有助于异常点的分类。为了公平比较，我们选择与我们的方法相同数量的顶级特征。这些基线的实现和超参数可以在附录B中找到。请注意，我们没有选择现有的黑盒解释方法（例如，LIME[53]和SHAP[44]）作为我们的比较基线。这是因为由于它们能够访问原始模型，白盒方法通常比黑盒方法表现更好[67]。

评估指标。定量地，我们直接评估所选特征对距离变化的影响。给定一个测试样本 $ {\mathbf{x}}_{t} $ 和一种解释方法，我们获得所选特征 $ {\mathbf{m}}_{t} $，其中 $ {\left( {\mathbf{m}}_{t}\right) }_{i} = 1 $，如果第 $ {i}^{\text{th }} $ 个特征被选为重要，我们通过这个指标量化这个解释结果的准确性：$ {d}_{{\mathbf{x}}_{t}}^{\prime } = \parallel f\left( {{\mathbf{x}}_{t} \odot \left( {1 - {\mathbf{m}}_{t}}\right) + {\mathbf{x}}_{{y}_{t}}^{\left( c\right) } \odot } \right. $ $ \left. {\mathbf{m}}_{t}\right) - {\mathbf{c}}_{{y}_{t}}{\parallel }_{2} $，其中 $ f,{\mathbf{c}}_{{y}_{t}} $ 和 $ {\mathbf{x}}_{{y}_{t}}^{\left( c\right) } $ 在Eqn. (2)中的定义与 ones 相同。$ {d}_{{\mathbf{x}}_{t}}^{\prime } $ 表示 $ {\mathbf{x}}_{t} $ 扰动样本与其最近邻中心点 $ {\mathbf{c}}_{{y}_{t}} $ 之间的潜在距离。扰动样本是通过将 $ {\mathbf{x}}_{t} $ 中的重要特征值替换为类 $ {y}_{t} $ 最接近中心点（即 $ {\mathbf{x}}_{{y}_{t}}^{\left( c\right) } $）的训练样本的特征值而产生的。如果所选特征确实重要，那么将它们替换为类 $ {y}_{t} $ 训练样本的特征值将减少扰动样本与 $ {\mathbf{c}}_{{y}_{t}} $ 中心点的距离。在这种情况下，较低的距离 $ {d}_{{\mathbf{x}}_{t}}^{\prime } $ 更好。

除了这个 $ {d}_{{x}_{t}}^{\prime } $ 度量之外，我们还在第 5.2 节中使用了一个传统的度量来检查能够跨越决策边界的扰动样本的比例。

---


漂移样本家族：FakeDoc；最近的家族：GingerMaster

[api_call::android/telephony/SmsManager;->sendTextMessage], [call::readSMS], [permission::android.permission.DISABLE_KEYGUARD],

接收短信权限，发送短信权限，写入短信权限。

权限: android.permission.SEND_SMS , 权限: android.permission.READ_SMS , 功能: android.hardware.telephony ,

[权限::android.permission.READ_CONTACTS], [实际权限::android.permission.READ_CONTACTS],

[api_call::android/location/LocationManager;->isProviderEnabled], [api_call::android/accounts/AccountManager;->getAccounts],

意图: android.intent.category.HOME, 功能: android.hardware.location.network, 实际权限: android.permission.RESTART_PACKAGES。

权限：[real_permission::android.permission.WRITE_SETTINGS]，API 调用：[api_call::android/net/ConnectivityManager, >getAllNetworkInfo]，

[api_call::android/net/wifi/WifiManager;->setWifiEnabled], [api_call::org/apache/http/impl/client/DefaultHttpClient],

[网址::https://ws.tapjoyads.com/], [网址::https://ws.tapjoyads.com/set_publisher_user_id?],

[权限::android.permission.CHANGE_WIFI_STATE], [实际权限::android.permission.ACCESS_WIFI_STATE],

真实的权限：android.permission.BLUETOOTH，android.permission.BLUETOOTH_ADMIN，调用：setWifiEnabled。

表 5：解释为何给定样本是漂移样本的案例研究。高亮显示的特征表示那些与区分漂移样本与其最近亲本的语义特征相匹配的特征。

---


<table><thead><tr><th>方法</th><th>Drebin-FakeDoc</th><th>IDS2018-Infiltration</th></tr></thead><tr><td>随机</td><td>0%</td><td>0%</td></tr><tr><td>边界基</th><th>础</th><th>0%</th></tr><tr><td>COIN [43]</td><td>0%</td><td>0%</td></tr><tr><td>CADE</td><td>97.64%</td><td>1.41%</td></tr></table>


表 6：基于决策边界交叉的扰动样本比例的说明精确度比较。更高的比例意味着扰动的特征更为重要。

## 5.2 保真度评估结果



特征对距离的影响。表 4 显示了所有漂移样本的平均和标准差 $ {d}_{{\mathbf{x}}_{t}}^{\prime } $（即漂移样本与最近聚类中心的距离）。我们有四个关键观察点。首先，基于随机选择的特征对漂移样本进行扰动几乎不会影响隐空间距离（比较第 2 行和第 3 行）。其次，基于边界的解释方法可以在两个数据集上降低距离，百分比为 $ {26}\% - {47}\% $（比较第 2 行和第 4 行）。这表明这种方法有一定的效果。然而，绝对距离值仍然很高。第三，COIN在 IDS2018 数据集上降低了隐空间距离（比较第 2 行和第 5 行），但在 Drebin 数据集上平均距离有所增加。本质上，COIN是一种专门基于边界的方法，它使用一组线性支持向量机（LinearSVM）分类器来近似决策边界。我们发现 COIN在高维空间中效果不佳，并且很难将漂移样本拖到边界的另一侧（将在第 5.3 节讨论）。最后，CADE的解释模块在距离度量上的平均值和标准差最低。距离从原始距离显著减少（即 Drebin 数据集上的 98.8% 和 IDS2018 数据集上的 79.9%，比较第 2 行和第 6 行）。特别是，CADE在基于边界的解释方法上表现出了显著的优势。由于我们的方法克服了样本稀疏性和不平衡问题，它指出了对距离有更大影响的更有效的特征（这些特征影响漂移检测决策）。

选定特征的数量。总体而言，选定特征的数量很小，这使得手动解释成为可能。如前所述，我们配置所有方法以选择相同数量的重要特征（与 CADE 相同）。对于 Drebin 数据集，平均选定特征数为 44.7，标准差为 6.2。这仅占所有特征的极小部分（即 3%）。同样，IDS2018 数据集的平均选定特征数为 16.2，约占所有特征的 $ {20}\% $。

## 5.3 跨越决策边界

上述评估确认了所选特征对距离度量产生的影响，而这正是CADE设计用来优化的。为了提供另一个视角，我们进一步考察了所选特征对跨越边界的影响。更具体地说，我们计算了被扰动样本中成功跨越决策边界的比例。如表6所示，我们确认在大多数设置中，跨越边界在漂移检测上下文中对于大多数设置来说都是困难的。特别是，对于Drebin数据集，CADE可以将$ {97.64}\% $的扰动样本推到跨越检测边界，但对于IDS2018数据集，只有$ {1.41}\% $的样本能够跨越边界。相比之下，基线方法在原始特征空间中很少能够成功扰动漂移样本，使其跨越边界。通过放宽这一条件，并将重点放在距离变化上，我们的方法在识别重要特征方面更加有效。

## 5.4 案例研究

为了展示我们的方法确实捕获了有意义的特征，我们提供了一些案例研究。在表5中，我们为Drebin数据集展示了一个案例研究。我们选择当FakeDoc是一个未知的家族，并随机挑选一个漂移样本来运行解释模块。在我们的解释模块中，从$ {1000} + $个特征中，我们指出了42个重要的特征，其中27个特征的价值是“1”（意味着这个样本包含这些特征）。如表5所示，最近的家族是GingerMaster。

我们手动检查这些特征，以确定这些特征是否携带正确的语义含义。虽然获得“地面真相”解释很困难，但我们收集了关于FakeDoc恶意软件和Ginger-Master $ \left\lbrack {{68},{70}}\right\rbrack $的外部分析报告。根据这些报告，FakeDoc恶意软件与GingerMaster的一个关键区别是，它通常通过短信订阅付费服务并将其费用转嫁给受害用户。如表5所示，许多选中的特征与读取、写入和发送短信的权限和API调用相关。我们强调了这些与短信相关功能相关的特征。其他相关的特征也被强调了。例如，“RESTART_PACKAGES”权限允许恶意软件结束后台进程（例如，显示短信进入的进程）以避免用户注意。“DISABLE_KEYGUARD”权限允许恶意软件在不解锁屏幕的情况下发送付费短信。“WRITE_SETTINGS”也有助于秘密发送短信。“url::https://ws.tapjoyads.com/”是一个通常被FakeDoc使用的广告库。再次，这些特征是从超过1000个特征中选出的。我们得出结论，这些特征是这个样本与最近已知家族不同的一个高度指示。

## 6 评估：课堂进化



到目前为止，我们的评估主要集中在一种类型的概念漂移（类型A），其中漂移样本来自先前未见过的家庭。接下来，我们将探讨如何将我们的解决方案适应于解决另一种类型的概念漂移（类型B），其中漂移样本来自现有类别。我们在二元分类设置中进行了一个简短的实验，遵循与[38]相似的设置。

更具体地说，我们首先使用Drebin数据集训练一个二元SVM分类器，用于分类恶意软件样本与良性样本。该分类器在Drebin上的训练 $ {F}_{1} $ 分数为0.99。我们想测试这个分类器在另一个Android恶意软件数据集Marvin [42]上的表现。Marvin是一个稍新的数据集（从2010年到2014年），与Drebin（从2010年到2012年）相比。我们首先从Marvin数据集中移除与Drebin重叠的样本，以确保Marvin样本确实是未见过的。这给我们留下了9,592个良性样本和9,179个恶意软件样本在Marvin。

对于这次实验，我们随机将Marvin数据集分为验证集和测试集（50:50）。对于两组，我们保持恶意软件和良性样本的比例平衡。我们将原始分类器（在Drebin数据上训练的）应用于Marvin测试集。我们发现测试精度不再高 $ \left( {F}_{1}\right. $ 分数0.70)，这可能是由于恶意软件类别或良性类别中的内部进化。

为了解决内部进化问题，我们在Marvin验证集上应用CADE和Transcend来识别一小部分

<table><tr><td rowspan="2"># 选定样本</td><th colspan="2">$ {F}_{1} $ 的重训练分类器</th></tr><tr><td>CADE</td><td>Transcend</td></tr><tr><td>0</td><td>0.70</td><td>0.70</td></tr><tr><td>100</td><td>0.91</td><td>0.71</td></tr><tr><td>150</td><td>0.92</td><td>0.76</td></tr><tr><td>200</td><td>0.93</td><td>0.74</td></tr><tr><td>250</td><td>0.94</td><td>0.71</td></tr></table>

表7：重训练分类器在Marvin测试集上的性能。我们使用CADE和Transcend在Marvin验证集上选择漂移样本进行重新训练。

的漂移样本（它们可以是良性或恶意的）。我们模拟通过使用它们的“真实标签”来标记它们，然后将这些标记的漂移样本添加回Drebin训练数据进行重新训练。最后，我们在Marvin测试集上测试重训练的分类器。

如表7所示，我们发现CADE仍然显著优于Transcend。例如，通过添加仅150个漂移样本（Marvin验证集的 $ {1.7}\% $）进行重新训练，CADE将二元分类器的 $ {F}_{1} $ 分数提高到0.92。对于Transcend，相同数量的样本只能将 $ {F}_{1} $ 分数提高到0.74。此外，我们还发现CADE也更快：CADE的运行时间是1.2小时（与Transcend的10小时相比）。这次实验确认CADE可以适应于处理二元恶意软件分类器的内部进化。

## 7 真实世界中的PE恶意软件测试

我们与安全公司蓝六角公司合作，在其专有样本集上测试CADE。更具体地说，我们在蓝六角公司的Windows恶意软件数据库上进行了初始测试。在这个测试中，我们获得了从2019年8月29日至2020年2月10日收集的样本集的访问权限。这个集合包括来自395个家族的20,613个独特的Windows PE恶意软件样本。我们使用这个数据集在一个更加多样化的设置中测试CADE（即漂移样本来自更多的家族）。

PE恶意软件数据集。对于每个样本，我们都有原始二进制文件和Blue Hexagon提供的元数据，包括样本首次被观察的时间戳，以及家族名称（由安全分析师标注）。我们遵循Ember [6]的特征工程方法，并使用LIEF [63]来解析二进制文件并提取特征向量。每个特征向量有2,381个维度。这些特征包括字节频率直方图和不同字节的熵，可打印字符串和特殊模式，关于文件大小的特征，头信息，节信息，导入的库和函数，导出函数，以及数据目录的大小和虚拟地址。

家族归属实验。原始分类器是一个多类分类器，用于归属恶意软件家族。我们的目标是使用CADE检测不应归属于现有家族的未知家族。我们根据

<table><thead><tr><th>$ N $</th><th>精度</th><th>召回率</th><th>$ {F}_{1} $</th><th>正常努力</th><th>检测到的家族</th></tr></thead><tr><td>5</td><td>0.96</td><td>0.98</td><td>0.97</td><td>1.02</td><td>161/165</td></tr><tr><td>10</td><td>0.96</td><td>0.94</td><td>0.95</td><td>0.98</td><td>153/160</td></tr><tr><td>15</td><td>0.95</td><td>0.80</td><td>0.87</td><td>0.84</td><td>140/155</td></tr></table>


表 8：PE恶意软件数据集的漂移检测结果。$ N $ 是训练集中的已知家族数量。“检测到的家族”表示CADE检测到的所有新家族的数量。

时间。训练集包含从2019年8月29日至2020年1月10日收集的恶意软件样本。测试集包含在随后的月份收集的样本，从2020年1月10日至2020年2月10日。为了训练，我们需要确保恶意软件家族有足够的样本来训练原始分类器。因此，我们专注于前$ N $个家族。我们分别测试了三种设置，$ N = 5,{10} $和15。这确保了训练家族中每个家族至少有298个样本。不在前$ N $个家族中的样本被排除在训练集之外。对于原始分类器来说，这样的最小样本数量是必要的，以确保其有合理的准确性。例如，对于$ N = {15} $，准确率为$ {96.5}\% $。如果数据集更大，该分类器有可能支持更多的家族。对于测试集，所有家族都被保留。此外，根据Blue Hexagon分析团队的建议，我们向测试集中添加了两个家族（Tinba和Smokeloader），因为它们观察到这些家族在逃避现有的基于机器学习的恶意软件检测引擎方面更为成功。如表8所示，测试集中有155到165个以前未见过的家族，即CADE的目标。

结果与案例研究。表8显示，在具有超过155个先前未见家族的多样化样本集上，CADE仍然表现良好。当训练家族的数量 $ N = {10} $ 时，CADE实现了$ {F}_{1} $分数为$ {95}\% $。当 $ N = {15} $ 时，$ {F}_{1} $分数仍然为0.87。大多数先前未见的家庭被成功识别。确实，更多的家庭数量使得问题变得更加困难。原因不一定是由于现有家庭和未见家庭难以区分。相反，随着训练家庭数量的增加，我们观察到更多的测试样本在现有家庭中，这些样本与未见家庭的样本相比，甚至更远。这些家庭内的变体成为在我们的定义下假阳性贡献的主要因素。观察结果与我们第四部分案例研究中的观察相似。作为快速比较，我们也在 $ N = {15} $ 设置下运行了Transcend。我们发现CADE在这个 $ N = {15} $ 设置下仍然在更多样化的未见家庭上优于Transcend（Transcend的 $ {F}_{1} $ 分数仅为0.76）。

我们使用Tinba和Smokeloader的说明模块进行了快速的特征分析，这两个样本对于其底层的分类器来说都是公认的挑战性例子。Tinba（微型银行木马）针对金融网站进行浏览器内攻击和网络嗅探。Smokeloader是一种下载其他恶意软件的木马，虽然是一个古老的恶意软件家族，但它发展迅速。特别是，我们发现Tinba的新样本与现有的Wabot家族最为接近。CADE指出了45个特征以提供解释。例如，我们发现Tinba启用了“LARGE_ADDRESS_AWARE”选项，该选项告诉链接器程序可以处理大于2千兆字节的地址。这种选项在64位编译器中是默认启用的。这提供了一些解释，说明为什么Tinba能够在现有的恶意软件检测引擎中成功逃逸，因为绝大多数PE恶意软件文件是基于32位的。根据“部分”的特征，我们注意到Tinba样本使用了“UPX”作为打包器。根据导入的库和函数的选定特征，我们发现Tinba引用了“crypt32.dll”用于加密字符串。Tinba样本在这些特征上与Wabot样本不同。

## 8 讨论

计算复杂性。CADE的计算开销小于现有的方法。检测模块的复杂性包含两部分：对比学习和对流检测。对比学习的复杂性是 $ O\left( {I{B}^{2}\left| \theta \right| }\right) $，其中 $ I, B $ 和 $ \left| \theta \right| $ 分别代表训练迭代次数、批大小和自动编码器模型的参数数量。对流检测（算法1）的复杂性是 $ O\left( {N{\widetilde{n}}_{i} + {NK}}\right) $，其中 $ N,{\widetilde{n}}_{i} $ 和 $ K $ 分别代表类别数量、每个类别的最大训练样本数量和测试样本数量。CADE检测模块的整体复杂性是 $ O\left( {I{B}^{2}\left| \theta \right| + N{\widetilde{n}}_{i} + {NK}}\right) $。我们的训练开销是可接受的，因为它仅与批大小 $ B $ 成二次关系。我们的检测运行时开销远低于Transcend（其复杂性为 $ O\left( {N{\widetilde{n}}_{i}K}\right) $）。经验上，我们在第4节记录了检测实验的平均运行时间，并确认CADE比Transcend快。例如，在更大的IDS2018数据集上，CADE和Transcend的平均运行时间分别为1,422.7s和4,289.3s。至于解释模块，CADE与基于边界的解释方法（如COIN）相当。例如，对于IDS2018数据集，CADE、COIN和基于边界的解释方法解释一个流样本的平均运行时间分别为 $ {3.2}\mathrm{\;s},{8.2}\mathrm{\;s} $ 和 $ {3.7}\mathrm{\;s} $。基于边界的解释方法还需要平均额外 $ {76.5}\mathrm{\;s} $ 来为解释构建近似模型。


解释 vs. 对抗性攻击。我们注意到CADE中的解释模块与对抗性示例生成过程有一些相似之处，例如，两者都涉及对给定输入进行特定目标的扰动。然而，我们认为它们有两大不同之处。首先，它们的输出不同。对抗性攻击（旨在逃避）直接输出跨越决策边界所需的扰动；我们的解释方法（旨在理解漂移）输出影响距离的重要特征。其次，它们对扰动的约束不同。我们的解释方法只尝试最小化扰动特征的数量，而对抗性攻击还对扰动的幅度进行了限制。更重要的是，对抗性样本需要在各自的应用中有效（即有效的恶意软件样本，可以执行并保持恶意行为，有效的网络流量，可以执行原始攻击）。因此，生成对抗性样本在我们的上下文中可能比推导解释更困难。也就是说，对抗性攻击超出了本文的范围。我们将CADE的对抗性攻击留待将来研究（即创建非感知扰动，将漂移样本转换为分布内的样本）。

限制与未来工作。我们的工作有几个限制。首先，CADE对所有漂移样本进行单一列表排名。然而，在实践中，漂移样本可能包含子结构（例如，多个新恶意软件家族）。一种实用的策略可能是进一步将漂移样本分组为簇。这样，安全分析师只需检查和解释每个簇的代表性样本，以进一步节省时间。其次，CADE的某些超参数是经验确定的（例如，MAD阈值）。我们在附录C中测试了CADE对超参数的敏感性。未来的工作可以研究更系统的策略来配置超参数。第三，CADE是基于假设训练集没有误标样本（或中毒样本）而设计的。我们将未来的工作推迟到对我们的系统进行低质量或恶意标签的鲁棒化。第四，我们的实验主要集中在检测新家族上。在第六节中，我们仅简要实验了现有家族内的概念漂移（类内进化）。我们将更深入的分析推迟到未来的工作。

最终，我们在第7节中的评估仅限于$ N = {15} $个训练类别（以及155个先前未见过的测试类别）。我们将$ N $限制为$ {15} $，以确保每个训练类别的样本数量足够训练一个准确的原始分类器。为了测试更大的$ N $，我们尝试将CADE应用于多个其他恶意软件数据集，但没有找到一个满足我们需求的数据集。例如，Ember-2018数据集[6]提供了大量恶意软件样本。然而，家族标签并不完善。例如，Ember-2018中的一个流行恶意软件家族名为“high”（有8,417个样本），这实际上是从VirusTotal报告中错误解析的：报告中的原始条目名称为“恶意（高度信心）”，这不是一个真实的恶意软件家族名称。我们观察到标签中存在其他类似的解析错误和不一致性。Ember-2017数据集[6]和UCSB打包恶意软件数据集[3]不提供恶意软件家族信息。Microsoft恶意软件分类挑战赛的数据集[55]只有9个恶意软件家族，这比我们的Blue Hexagon数据集要小。鉴于我们的努力失败，我们将对更大数量的训练类别的检查推迟到未来的工作。

## 9 相关工作

安全领域中使用的机器学习。机器学习已经被用来解决许多安全问题，如恶意软件检测 $ \left\lbrack {6,7,{17},{42}}\right\rbrack $，恶意软件家族归属 $ \left\lbrack {4,{11}}\right\rbrack $，网络入侵检测 $ \left\lbrack {{24},{34},{48},{60}}\right\rbrack $。最近，研究人员开始研究使用深度学习方法进行二进制分析 $ \left\lbrack {{27},{69}}\right\rbrack $，软件漏洞识别 [72]，和严重性预测 [30]。这些机器学习模型中的大多数在实践中需要解决概念漂移问题。

环境检测。最近，机器学习社区在环境检测方面取得了进展 $ \left\lbrack {{14},{32},{41},{46},{49}}\right\rbrack $ 。这些工作相关，但与我们工作的假设和目标不同。在较高层次上，这些方法大多试图校准原始分类器生成的“概率”以检测环境样本。研究人员确实认识到了当涉及到未知的分布时，概率可能是不可信的 $ \left\lbrack {{14},{32}}\right\rbrack $ 。为了避免给环境样本分配一个高的概率，所提出的方法通常需要引入一个辅助的环境数据集到训练数据中。这些方法在安全应用中很难实现，原因有两个。首先，辅助环境数据集（即未知的攻击）在最初就很难获得。其次，这些解决方案需要重新设计原始分类器（例如，功能性恶意软件检测器），这在生产环境中不方便进行。相反，我们的方法不依赖于辅助环境数据集，并且与原始分类器脱钩。

分类可信度。相关的工作旨在评估分类结果的可信度，例如 $ \left\lbrack {{11},{37},{50}}\right\rbrack $。一个共同的目标是识别不可信的预测，例如对抗性攻击的预测。这些方法大多基于“最近邻”的概念。直觉是，不可信的预测更有可能与其最近邻训练样本不同标签。例如，DkNN [50] 通过比较测试样本与其在深度神经网络（DNN）每一层的邻近训练样本来推导信任分数。另一项最近的工作 [37] 基于“高密度集”计算信任分数。然而，这样的基于邻居的方法仍然依赖于一个好的距离函数。正如 [37] 所承认的，他们的方法在高维空间中可能会遇到问题。总体而言，这些方法与我们关注的领域不同。他们的目标是识别现有类别内的误分类（而不是从新类别漂移的样本）。与此方向相关，主动学习方法也使用预测概率来选择低信心样本进行重新标记 $ \left\lbrack {{47},{73}}\right\rbrack $。如前所述（见 [32]），在概念漂移下，预测概率本身可能是误导性的。

机器学习解释。最近的工作集中于对机器学习分类器的后验解释方法的研究 $ \left\lbrack {8,{22},{35},{58},{59}}\right\rbrack $ ，并研究解释的鲁棒性 $ \left\lbrack {{15},{71}}\right\rbrack $ 。给定一个测试样本，目标是 pinpoint 重要的特征来解释分类决策。大多数方法是为深度神经网络设计的。例如，基于扰动的方 法会微妙地操纵输入，观察输出变化来识别重要的特征 $ \left\lbrack {{13},{18},{21},{22}}\right\rbrack $ 。基于梯度的方法（例如，saliency maps）通过深度神经网络反向传播梯度来衡量每个特征的敏感性 $ \left\lbrack {{56},{58},{59},{61}}\right\rbrack $ 。其他解释方法将目标分类器视为黑盒 [53,54]。像LIME [53]、LEMNA [28] 和 SHAP [44]这样的系统尝试使用更简单的模型（例如，线性回归）来近似输入样本附近的决策边界，然后使用更简单的模型来 pinpoint 特征以生成解释。

我们的方法属于基于扰动的类别。关键的区别在于，现有方法是为监督分类器设计的，旨在解释决策边界。我们的方法专注于解释距离变化，这些变化更适合于异常点检测。只有少数工作试图解释无监督模型（[19], [43]）。我们在评估中使用了COIN [43] 作为基线，并展示了基于距离的解释的优势。

## 结论

在本论文中，我们构建了一个名为CADE的全新系统，以补充监督分类器，以对抗安全情境中的概念漂移。通过对比自编码器和基于距离的解释方法，CADE被设计用来检测从原始训练分布中偏离的漂移样本，并提供相应的解释来解释漂移的意义。通过使用各种数据集，我们展示了CADE在性能上超过了现有方法。与一家行业合作伙伴合作，我们演示了CADE能够检测和解释来自先前未见过的家族的漂移样本的能力。

致谢



我们感谢我们的导师David Freeman和匿名审稿人提出的建设性评论和建议。这项工作部分得到了NSF资助CNS-2030521和CNS-1717028的支持，以及亚马逊研究奖的资助。

参考文献

[1] 马丁·阿巴迪（Martín Abadi），保罗·巴尔汉姆（Paul Barham），简明·陈（Jianmin Chen），张峰（Zhifeng Chen），安迪·戴维森（Andy Davis），杰弗里·德恩（Jeffrey Dean），马修·德文（Matthieu Devin），桑杰·盖马沃（Sanjay Ghemawat），盖伊·伊文（Geoffrey Irving），迈克尔·伊斯尔（Michael Isard），等。Tensorflow：大规模机器学习系统。在Proc. of USENIX OSDI，2016年。


[2] Hervé Abdi 和 Lynne J. Williams. 主成分分析。WIREs 计算统计，2010年。

[3] 霍贾特·阿加哈尼（Hojjat Aghakhani），法比奥·格里蒂（Fabio Gritti），弗朗西斯科·梅卡（Francesco Mecca），马蒂娜·林多弗（Martina Lindorfer），斯蒂芬诺·奥尔托兰尼（Stefano Ortolani），达维德·巴尔扎科蒂（Davide Balzarotti），乔瓦尼·维加（Giovanni Vigna）和克里斯托弗·克鲁格（Christopher Kruegel）。当恶意软件是“热包装”；基于静态分析特征的机器学习分类器的限制。在Proc. of NDSS上，2020年。

[4] 曼苏尔·阿哈米迪（Mansour Ahmadi），德米特里·乌利扬诺夫（Dmitry Ulyanov），斯坦尼斯拉夫·塞门诺夫（Stanislav Semenov），米哈伊尔·特罗菲莫夫（Mikhail Trofimov）和乔治·贾钦托（Giorgio Giacinto）。新型特征提取、选择和融合，用于有效恶意软件家族分类。在Proc. of CO-DASPY，2016年。

[5] 布鲁斯·安。更多广告软件和磷虾变种出现在应用商店中。趋势科技，2012。

[6] Hyrum S Anderson 和 Phil Roth. Ember: 一个用于训练静态 PE 恶意软件机器学习模型的开放式数据集。arXiv 预印本arXiv:1804.04637，2018年。

[7] Daniel Arp, Michael Spreitzenbarth, Malte Hubner, Hugo Gascon, Konrad Rieck, 和 CERT Siemens 的检测。Drebin：在您的口袋中有效地和可解释地检测 Android 恶意软件。在 Proc. of NDSS 的第 2014 页。

[8] Sebastian Bach, Alexander Binder, Grégoire Montavon, Frederick Klauschen, Klaus-Robert Müller, 和 Wojciech Samek. 关于非线性分类器决策的像素级解释：逐层相关性传播法。PloS one, 2015。

[9] 马努埃尔·贝纳-加西亚，何塞·德尔·科尔波-阿维拉，拉乌尔·菲达尔戈，阿尔伯特·比费特，R Gavalda，和 R 莫雷尔斯-布埃诺。早期漂移检测方法。在第四届数据流知识发现国际研讨会，2006年。

[10] Albert Bifet 和 Ricard Gavalda. 使用自适应窗口学习随时间变化的数据。在 Proc. of SDM 上的论文。2007年。

[11] 塔姆奥·查克拉博蒂（Tanmoy Chakraborty），法比奥·皮埃拉齐（Fabio Pierazzi）和VS苏布拉曼尼亚（VS Subrahmanian）。Ec2：用于预测安卓恶意软件家族的聚类和分类的集合。TDSC，2017年。

[12] Eshwar Chandrasekharan, Mattia Samory, Anirudh Srinivasan, 和 Eric Gilbert. 社区袋: 使用现有互联网数据识别在线滥用行为。在 Proc. of CHI 上，2017 年。

[13] Chun-Hao Chang, Elliot Creager, Anna Goldenberg, 和 David Duvenaud. 解释图像分类器通过反事实生成。在 Proc. of ICLR 上，2019 年。

[14] 陈杰峰, 李逸轩, 吴希, 李莹玉, 和 Somesh Jha. 神经网络中的鲁棒出分布检测. arXiv预印本, arXiv:2003.09711, 2020年.

[15] 陈杰峰, 吴希, 维亚巴夫·拉斯托吉, 杨宇, 和 Somesh Jha. 稳健的归因正则化。在 Proc. of NeurIPS 上，2019 年。

[16] Ting Chen, Simon Kornblith, Mohammad Norouzi, 和 Geoffrey Hinton. 一种简单的框架，用于对比学习视觉表征。arXiv:2002.05709，2020年。

[17] Yizheng Chen, Shiqi Wang, Dongdong She, and Suman Jana. On training robust pdf malware classifiers. In Proc. of USENIX Security, 2020.


[18] Piotr Dabkowski 和 Yarin Gal. 实时图像显著性对于黑箱分类器。在 Proc. of NeurIPS 上，2017 年。

[19] Xuan Hong Dang, Ira Assent, Raymond T Ng, Arthur Zimek, 和 Erich Schubert. 识别和解释离群值的判别特征。在Proc. of ICDE上，2014年。

[20] Denis Moreira dos Reis, Peter Flach, Stan Matwin, 和 Gustavo Batista. 快速无监督在线漂移检测使用增量kolmogorov-smirnov测试。在Proc. of $ {KDD},{2016} $ 上。

[21] Ruth C Fong, Mandela Patrick, 和 Andrea Vedaldi. 理解深度网络通过极值扰动和光滑掩码。在 Proc. of ICCV 上，2019 年。

[22] Ruth C Fong 與 Andrea Vedaldi. 通過有意義的干擾解釋黑盒子的可解釋性。在 Proc. of ICCV 會議論文集中，2017 年。

translated text.

[23] 若昂·加马、因德里·兹利奥贝蒂、阿尔伯特·比费、米科拉·佩切尼齐耶和阿卜杜勒哈米德·布恰亚。概念漂移适应性综述。ACM计算机调查（CSUR），2014年。

异常基于网络入侵检测：技术、系统和挑战。

[25] Ian J Goodfellow, Jonathon Shlens, 和 Christian Szegedy. 解释和利用对抗性例子。Proc. of ICLR, 2015。

[26] Antonio Gulli 和 Sujit Pal. 深度学习与 Keras. 2017年。

[27] 郭文博, 穆东良, 邢新宇, 杜敏, 和 唐娜·宋. 深度vsa: 使用深度学习加速程序分析的死亡后价值集分析. 在美国计算机安全会议上的论文. 2019年.

[28] 郭文博, 穆东良, 徐俊, 苏普瑞, 王刚, 和 邢新宇. Lemna: 解释基于深度学习的网络安全应用。在 Proc. of CCS 上，2018 年。

[29] Raia Hadsell, Sumit Chopra 和 Yann LeCun. 通过学习不变映射进行维度减少。在 Proc. of CVPR 上的论文。2006年。

[30] Han Zhuobing, Li Xiaohong, Xing Zhenchang, Liu Hongtao, 
Feng Zhiyong. 仅使用漏洞描述学习预测软件漏洞严重性。在ICSME上发表的论文，2017年。

[31] מאין הראל, שי מנור, רן אל-יניב, וקובי קרמר. חיפוש שינוי ראשון דרך מחלקת תרשיות. באירועים של ICML, 2014.


[32] 丹·亨德利克斯和凯文·金普尔。神经网络中检测误分类和出分布示例的基线。在Proc. of ICLR上，2017年。

[33] 杰弗里·H·欣顿和鲁斯兰·R·萨拉霍季诺夫。使用神经网络降低数据的维度。科学，2006年。

[34] Elike Hodo, Xavier Bellekens, Andrew Hamilton, Christos Tachtatzis, 和 Robert Atkinson. 浅层和深层网络入侵检测系统：一种分类法和调查。arXiv预印本arXiv:1701.02145，2017年。

[35] 萨拉·霍克（Sara Hooker），杜米特鲁·埃尔汉（Dumitru Erhan），皮埃尔-让·肯德曼斯（Pieter-Jan Kindermans）和本·金（Been Kim）。深度神经网络中的可解释性方法基准。在NeurIPS的Proc.中，2019年。

[36] Steve TK Jan, Qingying Hao, Tianrui Hu, Jiameng Pu, Sonal Oswal, Gang Wang, and Bimal Viswanath. 黑暗中掷镖？使用有限数据和神经数据增强检测机器人。在《Proc. of $ S\& P $》，2020年。

[37] 海因里希·Jiang, 被恩·Kim, 旋律·Guan, 和 玛雅·Gupta。信任或不信任一个分类器。在 Proc. of NeurIPS 上的论文，2018 年。

[38] 罗伯托·乔丹尼，库马尔·夏拉德，桑坦古·K·达什，智·王，达维德·帕皮尼，伊利亚·诺雷丁夫，洛伦佐·卡瓦拉罗。超越：检测恶意软件分类模型中的概念漂移。在Proc. of USENIX Security，2017年。

[39] Alex Kantchelian, Sadia Afroz, Ling Huang, Aylin Caliskan Islam, Brad Miller, Michael Carl Tschantz, Rachel Greenstadt, Anthony D. Joseph, 和 J. D. Tygar. 对抗性漂移的方法。在 Proc. of AISec 的 2013 年。

[40] Christophe Leys, Christophe Ley, Olivier Klein, Philippe Bernard, 和 Laurent Licata. 检测异常点：不要使用平均值的标准差，使用中位数周围的标准差。Journal of Experimental Social Psychology, 2013年。

[41] 梁世玉, 李一轩, 和 Srikant Rayadurgam. 增强神经网络中图像出分布检测的可靠性。ICLR会议论文集, 2018年。

[42] 马丁娜·林多夫勒、马提亚斯·纽格施瓦尔登特纳和克里斯蒂安·普拉策尔。Marvin：通过静态和动态分析高效且全面地分类移动应用程序。在COMPSAC的教授中，2015年。

[43] Ninghao Liu, Donghwa Shin, and Xia Hu. 上下文异常点解释。在 Proc. of IJCAI，2018。

[44] Scott M. Lundberg 和 Su-In Lee. 一种统一的模型预测解释方法。在 Proc. of NeurIPS 上，2017 年。

[45] Chris J Maddison, Andriy Mnih, 和 Yee Whye Teh. 混凝土分布：离散随机变量的连续松弛。在 Proc. of ICLR 上，2017 年。

[46] Marc Masana, Idoia Ruiz, Joan Serrat, Joost van de Weijer, 和 Antonio M Lopez. 用于新颖性和异常检测的度量学习。在 Proc. of BMVC 上，2018 年。

[47] Brad Miller, Alex Kantchelian, Sadia Afroz, Rekha Bachwani, Edwin Dauber, Ling Huang, Michael Carl Tschantz, Anthony D. Joseph, 和 J.D. Tygar. 对抗性主动学习。在 Proc. of AISec，2014年。

[48] Yisroel Mirsky, Tomer Doitshman, Yuval Elovici, 和 Asaf Shabtai. Kitsune: 一个自动编码器集合的在线网络入侵检测。在 Proc. of NDSS 上，2018 年。

[49] 亚里士提莱斯-安杰洛斯·帕帕多普洛斯 (Aristotelis-Angelos Papadopoulos), 莫哈默德·雷扎·拉吉蒂 (Mohammad Reza Rajati), 纳西姆·夏伊克 (Nazim Shaikh), 和 贾迈因·王 (Jiamian Wang). 带有信心控制的异常点暴露用于异常检测。arXiv预印本arXiv:1906.03509，2019年。

[50] Nicolas Papernot 和 Patrick McDaniel. Deep k-最近邻: 向自信、可解释和鲁棒的深度学习迈进。arXiv预印本arXiv:1803.04765, 2018年。

[51] F. Pedregosa, G. Varoquaux, A. Gramfort, V. Michel, B. Thirion, O. Grisel, M. Blondel, P. Prettenhofer, R. Weiss, V. Dubourg, J. Vander-plas, A. Passos, D. Cournapeau, M. Brucher, M. Perrot, 和 E. Duch-esnay. Scikit-learn: Python 中的机器学习。Journal of Machine Learning Research, 2011.

[52] 费格努斯·彭德尔伯里（Feargus Pendlebury），法比奥·皮埃拉齐（Fabio Pierazzi），罗伯托·乔丹尼（Roberto Jordaney），约纳斯·基德（Johannes Kinder）和洛伦佐·卡瓦拉罗（Lorenzo Cavallaro）。TESSERACT：消除空间和时间跨度上的恶意软件分类实验偏差。在USENIX安全会议上的论文，2019年。

为什么应该信任你？解释任何分类器的预测。在KDD会议上的论文。2016年。

[54] Marco Tulio Ribeiro, Sameer Singh, 和 Carlos Guestrin. Anchors: 高精度的模型无关解释。在 Proc. of AAAI, 2018 年。

[55] Royi Ronen, Marian Radu, Corina Feuerstein, Elad Yom-Tov, 和 Man-sour Ahmadi. Microsoft恶意软件分类挑战。arXiv预出版arXiv:1802.10135, 2018年。

[56] Ramprasaath R Selvaraju, Michael Cogswell, Abhishek Das, Ramakrishna Vedantam, Devi Parikh, 和 Dhruv Batra. Grad-cam: 基于梯度定位的深度网络视觉解释。在Proc. of ICCV上，2017年。

[57] 伊曼·沙拉法迪尼（Iman Sharafaldin），阿扎什·哈比比·拉什卡里（Arash Habibi Lashkari）和阿里·A·戈尔巴尼（Ali A Ghorbani）。朝向生成一个新的入侵检测数据集和入侵流量特性化。在Prof. of ICISSP，2018年。

[58] Avanti Shrikumar, Peyton Greenside, 和 Anshul Kundaje. 通过传播激活差异学习重要特征。在 Proc. of ICML 上，2017 年。

[59] Karen Simonyan, Andrea Vedaldi, 和 Andrew Zisserman. 深入卷积网络: 可视化图像分类模型和关注图. ICLR 工作坊, 2014年.

[60] Robin Sommer 和 Vern Paxson. 走出封闭世界：关于使用机器学习进行网络入侵检测。在 Proc. of S&P 会议上。2010 年。

[61] Jost Tobias Springenberg, Alexey Dosovitskiy, Thomas Brox, 和 Martin Riedmiller. 追求简单性：全卷积网络。在 Proc. of ICLR 上，2015 年。

[62] 穆昆德·桑达拉拉詹（Mukund Sundararajan），安库尔·塔利（Ankur Taly）和奇奇·杨（Qiqi Yan）。深度网络的公理归因。在ICML的论文中，2017年。

[63] Romain Thomas. Lief - 图书馆用于测量可执行格式。https://lief.quarkslab.com/，2017年4月。

translated text.

[64] 罗伯特·泰斯希里尼和格特·瓦尔特。通过预测强度验证簇。《计算和图形统计学杂志》，2005年。

[65] Daniele Ucci, Leonardo Aniello, 和 Roberto Baldoni. 恶意软件分析中机器学习技术的调查. 计算机安全, 2019.

[66] Laurens van der Maaten 和 Geoffrey Hinton. 使用t-SNE可视化数据。Journal of Machine Learning Research, 2008年。

[67] 亚历山大·瓦尔尼克（Alexander Warnecke），丹尼尔·阿普（Daniel Arp），克里斯蒂安·弗伦泽格（Christian Wressnegger）和康拉德·里埃克（Konrad Rieck）。不要把它漆成黑色：深度学习在计算机安全中的白盒解释。在Euro S&P的会议上。2020年。

[68] Fengguo Wei, Yuping Li, Sankardas Roy, Xinming Ou, and Wu Zhou. 深度分析当前Android恶意软件的真实值。在Proc. of DIMVA上，2017年。

[69] Xiaojun Xu, Chang Liu, Qian Feng, Heng Yin, Le Song, and Dawn Song. 基于神经网络的图嵌入方法用于跨平台二进制代码相似性检测。在Proc. of CCS上发表，2017年。

[70] Rowland Yu. 酒窖大师：一个Android恶意软件案例研究。在病毒子弹会议，2013年。

[71] 张新阳, 王宁飞, 季守岭, 申华, 汪婷婷. 火力下的深度学习解释性. 美国USENIX安全会议论文集, 2020.

[72] 周亚琴, 刘尚清, 杨景凯, 杜晓宁, 和 柳阳. Devign: 通过学习综合程序语义的图神经网络有效识别漏洞。在 Proc. of NeurIPS 上，2019 年。

[73] 朱敬波, 王慧珍, 胡维恩, 和 马 马. 基于信心的主动学习数据标注停止准则. ACM 语音与语言处理杂志, 2010.

[74] Arthur Zimek, Erich Schubert, 和 Hans-Peter Kriegel. 高维数值数据中无监督异常检测的调查。Statistical Analysis and Data Mining, 2012年。

## 附录 A：边界基于解释

为了执行边界基于解释，我们首先需要用参数化函数近似漂移检测模块的检测边界。我们需要进行近似，因为漂移检测器的真实边界是基于阈值的，而不是参数化的。具体来说，我们使用一个多层感知器（MLP）在隐空间中执行近似。由于漂移样本的数量有限，为了近似决策边界，我们首先通过向检测漂移样本的隐表示中添加高斯噪声来合成更多的漂移样本。然后，我们训练一个MLP $ g\left( \mathbf{z}\right) $来区分来自漂移样本的样本分布的隐表示。在获得近似模型后，我们将它与对比自编码器 $ f $结合起来，构建一个监督近似检测模块（即 $ g\left( {f\left( \mathbf{x}\right) }\right) $）。我们在隐空间中而不是输入空间中进行近似，原因有两个。首先，在低维空间中训练一个MLP比在高维空间中更有效率。其次，直接使用原始对比自编码器比用另一个网络近似自编码器，可以实现更高的监督近似精度。使用监督近似，然后我们应用基于扰动的解释方法 [22] 来解释每个漂移样本。与CADE类似，这种方法也会输出一个掩码，指示特征的重要性。我们将 $ {\mathbf{m}}_{i} $ 进行排名，并指出具有高 $ {\mathbf{m}}_{i} $ 的特征作为重要的特征。

# 附录 B：CADE 实现细节

CADE。我们基于 Keras [26] 包和 Tensorflow [1] 作为后端实现了 CADE。CADE 和基线的超参数配置如下。对于 CADE，我们设定了编码器为 MLP，Drebin 数据集的架构为 1340-512-128-32-7（当使用不同家族作为未见家族时，第一个维度可能会变化），IDS2018 数据集的架构为 83-64-32-16-3。每个隐藏层的激活函数是 ReLU 函数。我们应用了学习率为 0.0001 的 Adam 优化器，训练了 250 个轮次来训练两个网络。Drebin 和 IDS2018 的批量大小分别为 32 和 256。对于方程 (1) 中提到的对比损失超参数，我们设定了 $ \lambda = {0.1} $ 和 $ m = {10} $。我们应用了广泛使用的经验值作为 MAD 阈值和系数：$ {T}_{\mathrm{{MAD}}} = {3.5} $ 和 $ b = {1.4826} $。对于方程 (2) 中提到的解释损失超参数，我们设定了 $ {\lambda }_{1} = {1e} - 3 $，并使用学习率为 0.01 的 Adam 优化器来解决优化函数。训练轮次设置为 250。

漂移检测基线。我们的系统没有使用对比学习，而是作为变体的 vanilla autoencoder 基线。我们还根据作者提供的源代码实现了 Transcend 的多类版本。vanilla AE 基线的超参数与 CADE 几乎相同，除了 MAD 阈值 $ {T}_{MAD} = 0 $。我们尝试了 $ {T}_{MAD} = {3.5} $ 的方法，结果为零精确度和召回率。原因是 vanilla AE 的隐空间中的距离没有被优化来比较不同的样本，因此 MAD 失去了其有效性。

对于 Transcend，我们使用了一个 MLP 架构，Drebin 数据集为 1340-100-30-7，IDS2018 数据集为 83-30-3，来训练一个多类分类器。然后我们使用负输出概率 $ - p $ 作为 Transcend 的非一致性度量。我们设定了可信度 $ p $ 值的阈值为 1.0。也就是说，如果测试样本的 $ p $ 值低于 1.0，则将其标记为漂移样本。

解释基线。我们根据主文本描述实现了边界解释方法和随机选择方法。对于 COIN，我们使用了作者发布的源代码作为实现。$ {}^{5} $ 在边界解释方法中，近似函数 $ g $ 的网络架构分别为 Drebin 和 IDS2018 的 7-15-2 和 3-15-2。优化器、批量大小和轮次与我们的系统相同。

<table><tr><td rowspan="2">参数</td><th colspan="2">Drebin $ \left( {\mathrm{{Avg}} \pm \mathrm{{Std}}}\right) $</th><th colspan="2">IDS2018 (Avg $ \pm $ Std)</th></tr><tr><td>$ {F}_{1} $</td><td>Norm. Effort</td><td>$ {F}_{1} $</td><td>Norm. Effort</td></tr><tr><td>$ m = 5 $</td><td>$ {0.95} \pm {0.05} $</td><td>$ {0.97} \pm {0.05} $</td><td>$ {0.72} \pm {0.39} $</td><td>$ {0.72} \pm {0.39} $</td></tr><tr><td>$ m = {10} $</td><td>$ {0.96} \pm {0.03} $</td><td>$ {1.00} \pm {0.09} $</td><td>$ {0.96} \pm {0.06} $</td><td>$ {0.95} \pm {0.07} $</td></tr><tr><td>$ m = {15} $</td><td>$ {0.91} \pm {0.06} $</td><td>$ {1.00} \pm {0.14} $</td><td>$ {0.77} \pm {0.33} $</td><td>$ {0.76} \pm {0.34} $</td></tr><tr><td>$ m = {20} $</td><td>$ {0.93} \pm {0.03} $</td><td>$ {1.06} \pm {0.13} $</td><td>$ {0.98} \pm {0.02} $</td><td>$ {1.02} \pm {0.02} $</td></tr><tr><td>$ \lambda = 1 $</td><td>$ {0.95} \pm {0.03} $</td><td>$ {1.05} \pm {0.11} $</td><td>$ {0.94} \pm {0.09} $</td><td>$ {1.00} \pm {0.00} $</td></tr><tr><td>$ \lambda = {0.1} $</td><td>$ {0.96} \pm {0.03} $</td><td>$ {1.00} \pm {0.09} $</td><td>$ {0.96} \pm {0.06} $</td><td>$ {0.95} \pm {0.07} $</td></tr><tr><td>$ \lambda = {0.01} $</td><td>$ {0.94} \pm {0.03} $</td><td>$ {1.05} \pm {0.09} $</td><td>$ {0.67} \pm {0.47} $</td><td>$ {0.71} \pm {0.42} $</td></tr><tr><td>$ \lambda = {0.001} $</td><td>$ {0.89} \pm {0.10} $</td><td>$ {1.19} \pm {0.33} $</td><td>$ {0.95} \pm {0.05} $</td><td>$ {0.93} \pm {0.08} $</td></tr><tr><td>$ {T}_{MAD} = {2.0} $</td><td>$ {0.96} \pm {0.03} $</td><td>$ {1.00} \pm {0.09} $</td><td>$ {0.94} \pm {0.09} $</td><td>$ {0.99} \pm {0.02} $</td></tr><tr><td>$ {T}_{MAD} = {2.5} $</td><td>$ {0.96} \pm {0.03} $</td><td>$ {1.00} \pm {0.09} $</td><td>$ {0.95} \pm {0.07} $</td><td>$ {0.97} \pm {0.04} $</td></tr><tr><td>$ {T}_{MAD} = {3.0} $</td><td>$ {0.96} \pm {0.03} $</td><td>$ {1.00} \pm {0.09} $</td><td>$ {0.95} \pm {0.07} $</td><td>$ {0.96} \pm {0.05} $</td></tr><tr><td>$ {T}_{MAD} = {3.5} $</td><td>$ {0.96} \pm {0.03} $</td><td>$ {1.00} \pm {0.09} $</td><td>$ {0.96} \pm {0.06} $</td><td>$ {0.95} \pm {0.07} $</td></tr></table>

# 附录 C：超参数敏感性

在 3.2 节中，对比自编码器的损失函数有两个超参数：$ \lambda $ 和 $ m $。在这里，我们评估 CADE 性能对这些超参数的敏感性。我们的实验方法是在固定一个参数的同时交换另一个参数。我们固定 $ \lambda $ 为 0.1，并设置 $ m $ 为 5,10,15，

<table><thead><tr><th>抽样率</th><th>10%</th><th>15%</th><th>20%</th><th>25%</th><th>30%</th></tr></thead><tr><td>$ {F}_{1} $ 分数</td><td>0.96</td><td>0.98</td><td>0.98</td><td>0.98</td><td>0.97</td></tr></table>

表 11：IDS2018 数据集的抽样率与 CADE 的 $ {F}_{1} $ 分数。

20. 如表 9 所示，当 $ m = 5 $ 和 $ m = 10 $ 时，CADE 在 Drebin 数据集上实现了较高的 $ {F}_{1} $ 分数，但在 $ m = 15 $ 和 $ m = 20 $ 时略有下降。在 IDS2018 数据集上的检测性能在 $ m $ 设置为较高值时良好，例如 $ m = 20 $。请记住，$ m $ 是控制将被考虑的距离上限的阈值。只有当两个样本的距离在 $ m $ 半径内时，它们的不相似对才能对损失函数做出贡献。因此，如果数据集更加分散和嘈杂，则可以将 $ m $ 设置为更高。

为了测试 $ \lambda $ 的影响，我们像之前一样固定 $ m = 10 $，并设置 $ \lambda $ 为 1, 0.1, 0.01 和 0.001。$ \lambda $ 控制对比损失的重要性。从表 9 可以看出，如果 $ \lambda $ 太小，它就会损害 CADE 的性能。结果证实了对比损失的重要性。

在算法 1 中，我们设定了 MAD $ {T}_{MAD} $ 的阈值为 3.5，这是一个经验值 [40]。我们也测试了其他常用的 MAD 阈值，如 2, 2.5, 3。较小的 MAD 阈值可以检测更多的样本作为潜在的漂移样本，但它可能不会影响排名过程。如表 9 所示，检测到的漂移样本的平均结果与 Drebin 和 IDS2018 数据集上的 $ {T}_{MAD} = 3.5 $ 相同，表明 $ {T}_{MAD} $ 对检测漂移样本的影响较小。

为了评估损失函数 (Eqn.(2)) 中距离基解释的超参数 $ {\lambda }_{1} $ 的敏感性，我们设定了 $ {\lambda }_{1} $ 为 $ 0.1, 0.01, 0.001 $ 和 0.0001。如表 10 所示，我们注意到 Drebin 和 IDS2018 数据集上的最近邻中心距平均值随着 $ {\lambda }_{1} $ 的减小而减小。此外，较小的 $ {\lambda }_{1} $ 可以将扰动样本穿越决策边界的比例从 Drebin-FakeDoc 的 $ 91.34\% $ 增加到 $ 99.21\% $。对于 IDS-Infiltration，比例在不同 $ {\lambda }_{1} $ 值之间有所波动，但总体而言，不同的 $ {\lambda }_{1} $ 值对评估指标没有显著差异。

## 附录 D: IDS2018 额外结果

在我们的实验中，我们仅从 IDS2018 数据集中抽取了 $ {10}\% $ 的网络流量。流量抽样是入侵检测中常见的一种方法，它使我们能够全面测试不同的实验设置。我们还发现，包含更多的流量只会增加计算开销，并且对性能的影响微乎其微。如表 11 所示，随着抽样率的增加，CADE 的 $ {F}_{1} $ 分数保持一致的高水平。

]]></content>
  </entry>
  <entry>
    <title>工控网络安全-复习</title>
    <url>/2023/05/20/%E5%B7%A5%E6%8E%A7%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="标记类型"><a href="#标记类型" class="headerlink" title="标记类型"></a>标记类型</h2><ul>
<li>斜体：看看就行</li>
<li>正常：正常掌握</li>
<li>粗体&#x2F;emoji❗：重点掌握</li>
</ul>
<h1 id="第一章-工业互联网与工业控制网络"><a href="#第一章-工业互联网与工业控制网络" class="headerlink" title="第一章 工业互联网与工业控制网络"></a>第一章 工业互联网与工业控制网络</h1><h2 id="工业互联网概述"><a href="#工业互联网概述" class="headerlink" title="工业互联网概述"></a>工业互联网概述</h2><h3 id="工业互联网概念"><a href="#工业互联网概念" class="headerlink" title="工业互联网概念"></a>工业互联网概念</h3><p>工业互联网是互联网和新一代信息技术与全球工业系统全方位深度融合集成所形成的产业和应用生态吗，是工业智能化发展的关键综合信息基础设施</p>
<p>工业互联网应用-工业互联网网络体系-工业互联网终端<br>端到端数据流动</p>
<h3 id="三大智能化闭环"><a href="#三大智能化闭环" class="headerlink" title="三大智能化闭环"></a>三大智能化闭环</h3><p>智能生产控制、智能运营决策优化、消费需求与生产制造精确对接</p>
<p>数据：数据智能在工业中的全周期应用<br>网络：本质是实现数据智能的网络基础<br>安全：本质是工业&#x2F;产业互联网各个领域和环境的安全保障</p>
<h2 id="工业控制系统与工业控制网络"><a href="#工业控制系统与工业控制网络" class="headerlink" title="工业控制系统与工业控制网络"></a>工业控制系统与工业控制网络</h2><h3 id="工业控制系统层次❗"><a href="#工业控制系统层次❗" class="headerlink" title="工业控制系统层次❗"></a><strong>工业控制系统层次</strong>❗</h3><p>工业控制系统是指由计算机与工业过程控制不见组成的自动控制系统</p>
<h4 id="5个层次："><a href="#5个层次：" class="headerlink" title="5个层次："></a>5个层次：</h4><ol>
<li>企业资源层（第4层）<br>为企业决策层及员工提供决策运行手段（ERP）<br>企业网络和企业服务器</li>
<li>生产管理层（第3层）<br>为企业提供管理模块（MES）<br>对站点或区域的监控、监督和运营支持</li>
<li>过程监控层（第2层）<br>采集和监控生产过程参数，实现人机交互（SCADA、HMI）<br>对单个过程、单元、生产线或分布式控制系统及进行监控和监督控制</li>
<li>现场控制层（第1层）<br>生产过程控制（PLC、DCS、RTU）<br>提供过程、单元、生产线或DCS解决方案的自动化控制的设备和系统</li>
<li>现场设备层（第0层）<br>采集实际生产数据并相应操作（IED、IIOT、通信网关、现场仪表）<br>用于生产线、过程控制或DCS解决方案的传感器和执行器</li>
</ol>
<p><img src="/2023/05/20/%E5%B7%A5%E6%8E%A7%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/1.png"></p>
<h3 id="工业控制网络"><a href="#工业控制网络" class="headerlink" title="工业控制网络"></a>工业控制网络</h3><h4 id="工业控制系统："><a href="#工业控制系统：" class="headerlink" title="工业控制系统："></a>工业控制系统：</h4><p>由控制器、传感器、传送器、输入&#x2F;输出接口等部分组成，这些部分通过工业通信线路按照一定的通信协议进行链接，形成一个具有自动控制能力的工业生产制造或者加工系统。</p>
<h4 id="工业控制网络："><a href="#工业控制网络：" class="headerlink" title="工业控制网络："></a>工业控制网络：</h4><p>由传感器、执行器、测控仪表为节点，以现场总线或互联网等作为通信介质，互联并完成测量控制任务的网络。</p>
<h4 id="分层："><a href="#分层：" class="headerlink" title="分层："></a>分层：</h4><p>这里不太对，这里的分层没有明确表示是工业控制网络分层，第二章中有工业控制网络的三网四层</p>
<ol>
<li>信息层<br>通信数据量大、要求高速链路、不要求实时性<br>PC、操作员站</li>
<li>控制层<br>要求较高网络速率，实时性要求高，要求通信是确定的<br>可编程设备、控制器、人机终端</li>
<li>设备层<br>速度要求不高，有一定容错能力</li>
</ol>
<h4 id="工业互联网-IT-CT-OT"><a href="#工业互联网-IT-CT-OT" class="headerlink" title="工业互联网&#x3D;IT+CT+OT"></a>工业互联网&#x3D;IT+CT+OT</h4><p>包括工业控制系统信息安全、工业大数据安全、工业云安全、工业电子商务安全等</p>
<ul>
<li>IT<br>包括数据存储，各类软件，技术应用三个层面</li>
<li>OT<br>控制操作专员为自动化控制系统提供支持</li>
<li>CT<br>通信过程中的信息传输和信号处理技术</li>
</ul>
<p>工业控制系统信息安全涉及L0-L3，及各层的边界防护<br>L4-L5被归类为信息网络安全</p>
<h4 id="工业控制网络与传统IT信息网络的对比"><a href="#工业控制网络与传统IT信息网络的对比" class="headerlink" title="工业控制网络与传统IT信息网络的对比"></a>工业控制网络与传统IT信息网络的对比</h4><ul>
<li>网络边缘<br>工控系统在地域上分布广，边缘智能程度不高，在物理安全需求差异大</li>
<li>体系结构<br>工业控制网络结构纵向高度集成，主站与终端节点是主从关系，传统IT是对等关系</li>
<li>传输内容<br>工业控制网络传输的是工业设备的“四遥信息”</li>
</ul>
<p><img src="/2023/05/20/%E5%B7%A5%E6%8E%A7%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/2.png"></p>
<h3 id="工业控制网络安全趋势分析"><a href="#工业控制网络安全趋势分析" class="headerlink" title="工业控制网络安全趋势分析"></a>工业控制网络安全趋势分析</h3><h4 id="四级防护"><a href="#四级防护" class="headerlink" title="四级防护"></a>四级防护</h4><ol>
<li>工业互联网云平台安全</li>
<li>信息系统安全</li>
<li>IT和OT系网络互连安全</li>
<li>工业现场与控制安全</li>
</ol>
<h1 id="第二章-工业控制网络基础"><a href="#第二章-工业控制网络基础" class="headerlink" title="第二章 工业控制网络基础"></a>第二章 工业控制网络基础</h1><h2 id="工业4-0、工业互联网与中国制造2025"><a href="#工业4-0、工业互联网与中国制造2025" class="headerlink" title="工业4.0、工业互联网与中国制造2025"></a>工业4.0、工业互联网与中国制造2025</h2><h3 id="三次工业革命"><a href="#三次工业革命" class="headerlink" title="三次工业革命"></a>三次工业革命</h3><ol>
<li>蒸汽机——机械化</li>
<li>发电机——电气化</li>
<li>信息化</li>
</ol>
<h3 id="工业4-0"><a href="#工业4-0" class="headerlink" title="工业4.0"></a>工业4.0</h3><p>工业4.0包括 将信息物理系统（ Cyber Physical System, CPS）技术一体化应用于制造业和物流行业，以及在工业生产过程中使用物联网服务技术<br>目前还没有哪个国家或企业真正达到了工业4.0阶段，即使是首推工业4.0并为此建立全球仅有的高科技未来工厂的西门子公司，也只敢自称其未来工厂为“工业3.5“</p>
<h3 id="工业互联网"><a href="#工业互联网" class="headerlink" title="工业互联网"></a>工业互联网</h3><p>复杂物理机器和网络化传感器及软件的集成</p>
<p><img src="/2023/05/20/%E5%B7%A5%E6%8E%A7%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/3.png"></p>
<h3 id="中国制造2025"><a href="#中国制造2025" class="headerlink" title="中国制造2025"></a>中国制造2025</h3><p>以促进制造业创新发展为主题，以提质增效为中心，以加快新一代信息技术与制造业深度融合为主线，以推进智能制造为主攻方向，以满足经济社会发展和国防建设对重大技术装备的需求为目标，强化工业基础能力，提高综合集成水平，完善多层次多类型人才培养体系，促进产业转型升级，培育有中国特色的制造文化，实现制造业由大变强的历史跨越</p>
<h3 id="第四次工业革命"><a href="#第四次工业革命" class="headerlink" title="第四次工业革命"></a>第四次工业革命</h3><p>第四次工业革命是一场工业领域从嵌入式系统（Embedded System）到信息物理融合系统（Cyber Physical System）的技术变革<br>无论是工业互联网的愿景还是工业4.0的构想，我们都可以确定，这一场技术变革是构建在物联网的基础之上的</p>
<h2 id="工业控制网络的结构"><a href="#工业控制网络的结构" class="headerlink" title="工业控制网络的结构"></a>工业控制网络的结构</h2><h3 id="三网四层❗"><a href="#三网四层❗" class="headerlink" title="三网四层❗"></a><strong>三网四层</strong>❗</h3><ul>
<li>智能感知层<br>工业生产实体实现对自身状态、环境、其他实体的识别</li>
<li>网络互联层<br>多元联网对象组成</li>
<li>数据分析层<br>负责工业大数据的存储、处理、建模、挖掘、优化等</li>
<li>开放服务层<br>被生产部门调用和实施并进行反馈</li>
</ul>
<p>智能感知层向下对接复杂的工业生产实体，开放服务层向上对接工业综合应用</p>
<p>三重联网</p>
<ul>
<li>实体联网<br>不同工业生产实体彼此之间形成互联互通网络</li>
<li>数据联网<br>来自不同环境不同实体的数据可以汇聚并传输</li>
<li>服务联网<br>面向工业生产的服务可以被不同环节，部门，企业访问和请求</li>
</ul>
<p><img src="/2023/05/20/%E5%B7%A5%E6%8E%A7%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/4.png"></p>
<h3 id="智能工厂"><a href="#智能工厂" class="headerlink" title="智能工厂"></a>智能工厂</h3><h4 id="升级到工业4-0需要打通的三个互联"><a href="#升级到工业4-0需要打通的三个互联" class="headerlink" title="升级到工业4.0需要打通的三个互联"></a>升级到工业4.0需要打通的三个互联</h4><ol>
<li>生产制造设备之间的互联</li>
<li>生产制造系统和信息管理系统之间的互联</li>
<li>生产设备和生产物料之间的互联</li>
</ol>
<p>智能工厂是跨越不同生产环节，有效提升企业价值的网络，智能工厂力图使复杂的工业生产系统对于企业员工而言可管可控。互联使整个传统工业重新定义，将生产各环境互联，形成一个全新的网络化工业平台</p>
<h4 id="智能工厂面临的挑战"><a href="#智能工厂面临的挑战" class="headerlink" title="智能工厂面临的挑战"></a>智能工厂面临的挑战</h4><ol>
<li>智能工厂需要多种技术支持</li>
<li>需要新的系统模型支持</li>
<li>分布式系统的通信过程需要提升，使其支持自主管理和维护的高级自动化功能</li>
<li>HMI也需要变化升级</li>
</ol>
<h2 id="工业控制系统现场设备"><a href="#工业控制系统现场设备" class="headerlink" title="工业控制系统现场设备"></a><strong>工业控制系统现场设备</strong></h2><h3 id="智能电子设备（IED）"><a href="#智能电子设备（IED）" class="headerlink" title="智能电子设备（IED）"></a><strong>智能电子设备（IED）</strong></h3><p>由一个或多个处理器组成，具有从外部源接受和传送数据或控制外部源的任何设备。</p>
<p><img src="/2023/05/20/%E5%B7%A5%E6%8E%A7%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/5.png"></p>
<h3 id="人机界面-Human-Machine-Interface-HMI"><a href="#人机界面-Human-Machine-Interface-HMI" class="headerlink" title="人机界面(Human-Machine Interface,HMI)"></a><strong>人机界面(Human-Machine Interface,HMI)</strong></h3><p>人与机器处理信息交互或功能接触的人机接合面。链接可编程逻辑控制器、变频器、直流调速器、仪表等设备并用显示屏显示通过输入单元写入工作参数或输入操作命令。</p>
<p>两种类型</p>
<ol>
<li>操作员终端</li>
<li>上位机人机界面</li>
</ol>
<p>HMI核心单元为处理器，处理器的性能决定了HMI的性能高低</p>
<h3 id="变频器（VFD）"><a href="#变频器（VFD）" class="headerlink" title="变频器（VFD）"></a>变频器（VFD）</h3><p>过流、过压、过载保护</p>
<h3 id="智能仪表"><a href="#智能仪表" class="headerlink" title="智能仪表"></a>智能仪表</h3><p>优点：</p>
<ol>
<li>完成多种物理量的精确显示</li>
<li>提高仪表的可靠性</li>
<li>具有带变送输出、继电器控制输出等多种功能</li>
<li>能完成数据采集、数据处理、数据通讯</li>
</ol>
<h2 id="工业控制系统常用控制器概述"><a href="#工业控制系统常用控制器概述" class="headerlink" title="工业控制系统常用控制器概述"></a><strong>工业控制系统常用控制器概述</strong></h2><h3 id="可编程逻辑控制器（PLC）"><a href="#可编程逻辑控制器（PLC）" class="headerlink" title="可编程逻辑控制器（PLC）"></a><strong>可编程逻辑控制器（PLC）</strong></h3><p>是一种特殊的控制器，专为在工业环境应用而涉及的数字运算电子系统</p>
<p>特点：</p>
<ol>
<li>通信性和灵活性强，应用广泛</li>
<li>可靠性高，抗干扰能力强</li>
<li>产品系列化、规模化、功能完备、性能优良</li>
<li>编制程序简单、容易</li>
<li>涉及、安装、调试周期短、扩充容易</li>
<li>体积小、重量轻、维护方便</li>
</ol>
<p>按功能分类：</p>
<ol>
<li>低档PLC<br>具有基本逻辑运算等功能</li>
<li>中档PLC<br>具有较强的模拟量输入输出，还可增设中断控制、PLD等功能</li>
<li>高档PLC<br>增加符号算数运算，平方根运算及多种特殊函数的运算</li>
</ol>
<p>按I&#x2F;O点数分类</p>
<ol>
<li>小型PLC<br>256点以下</li>
<li>中型PLC<br>256-2048</li>
<li>大型PLC<br>2048以上</li>
</ol>
<h3 id="可编程自动化控制器（PAC）"><a href="#可编程自动化控制器（PAC）" class="headerlink" title="可编程自动化控制器（PAC）"></a>可编程自动化控制器（PAC）</h3><p>将PLC可靠、坚固、易用等特性与工业电脑强大的计算能力、通信处理、广泛的第三方软件结合的多功能工业用自动化控制器。</p>
<p>特征与性能：</p>
<ol>
<li>具有逻辑控制、运动控制、过程控制、人机界面等功能</li>
<li>是一个满足多领域自动化系统设计与集成的通用开发平台</li>
<li>允许OEM厂商和最终用户在统一平台上部署多个控制应用</li>
<li>有利于开放、模块化控制架构来适应高度分布性自动化工厂环境</li>
</ol>
<p>PAC与PLC区别：<br>PAC是一个多功能控制器平台，包含多种用户可自行组合的产品<br>PLC是一个仅具有制造商提前设置好的功能的产品，用户仅可以进行逻辑编程使用已有的功能。</p>
<h3 id="远程传输单元（RTU与DTU）"><a href="#远程传输单元（RTU与DTU）" class="headerlink" title="远程传输单元（RTU与DTU）"></a>远程传输单元（RTU与DTU）</h3><p>远程终端单元（RTU）安装在远程现场的电子设备，用于对远程现场的传感器和设备状态进行监视和控制</p>
<p>数据传输单元（DTU）专门用于将串口数据转换为IP数据或将IP数据转换为串口数据通过无线通信网络进行传送的无线终端设备</p>
<h2 id="数据采集与监视控制系统（SCADA）"><a href="#数据采集与监视控制系统（SCADA）" class="headerlink" title="数据采集与监视控制系统（SCADA）"></a><strong>数据采集与监视控制系统（SCADA）</strong></h2><h3 id="SCADA"><a href="#SCADA" class="headerlink" title="SCADA"></a>SCADA</h3><p>SCADA是由计算机设备、工业过程控制组件和网络组成的控制系统，对工业生产过程进行数据采集、检测和控制，保证工业生产过程正常，是关系国家命脉的基础产业的神经中枢。</p>
<p><img src="/2023/05/20/%E5%B7%A5%E6%8E%A7%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/6.png"></p>
<p>其通常由一个主站和多个子站组成</p>
<ul>
<li>主站<br>分为前置子系统和后台子系统，主站常设置在调度控制中心，以数据通信的方式接受从下级调度控制中心转发的信息，又向上级调度控制中心主站转发本站的信息</li>
<li>子站<br>设置在厂站端（SCADA）系统的实时数据源也是控制的目的地</li>
</ul>
<h3 id="SCADA中的组态软件"><a href="#SCADA中的组态软件" class="headerlink" title="SCADA中的组态软件"></a>SCADA中的组态软件</h3><p>Configuration software<br>使用软件工具对计算机及软件的各种资源进行配置，是计算机可以自动完成任务的软件<br>目前是开发SCADA系统上位机人机界面最主要的软件</p>
<h3 id="集散式控制系统"><a href="#集散式控制系统" class="headerlink" title="集散式控制系统"></a>集散式控制系统</h3><p>核心思想是集中管理、分散控制，即管理和控制相分离，上位机管理，下位机控制<br>实现地理上和功能上的分散控制，又将各个分散点的信息集中控制和操作，实现高级复杂的控制</p>
<h2 id="典型工业领域的工业控制网络"><a href="#典型工业领域的工业控制网络" class="headerlink" title="典型工业领域的工业控制网络"></a>典型工业领域的工业控制网络</h2><h3 id="两层三级"><a href="#两层三级" class="headerlink" title="两层三级"></a>两层三级</h3><p>两层：IT网络和OT网络<br>三级：现场级，车间级，企业级</p>
<p>**这里有一堆某某系统的举例，自己看吧</p>
<h2 id="物理传输介质"><a href="#物理传输介质" class="headerlink" title="物理传输介质"></a>物理传输介质</h2><ul>
<li>导向介质：固体媒介<br>通信质量取决于自身性质<br>传输容量可以用数据率（bps）或带宽（Hz）表示<br>双绞线、同轴电缆、光纤</li>
<li>非导向介质：无线传输<br>通信质量取决于发送天线生成的信号带宽</li>
</ul>
<p>设计因素：</p>
<ul>
<li>带宽</li>
<li>传输损伤</li>
<li>干扰</li>
<li>接收器数量</li>
</ul>
<h1 id="第三章-工业网络协议安全性分析"><a href="#第三章-工业网络协议安全性分析" class="headerlink" title="第三章 工业网络协议安全性分析"></a>第三章 工业网络协议安全性分析</h1><h2 id="Modbus协议❗"><a href="#Modbus协议❗" class="headerlink" title="Modbus协议❗"></a><strong>Modbus协议</strong>❗</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>使用端口<strong>502</strong><br>位于OSI第七层，是应用层协议，<br>可以使用TCP&#x2F;IP以太网链路<br>控制器必须知道网络中其他从设备的地址</p>
<p>Modbus协议采用主从模式工作</p>
<p><img src="/2023/05/20/%E5%B7%A5%E6%8E%A7%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/7.png"></p>
<p>应用数据单元（ADU）从左到右<br>附加-功能码-数据-错误检查</p>
<p>协议数据单元（PDU）从左到右（Modbus帧）<br>++++ - 功能码-数据 - ++++</p>
<p><img src="/2023/05/20/%E5%B7%A5%E6%8E%A7%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/8.png"></p>
<p><em>MODBUS寄存器种类举例</em></p>
<p><img src="/2023/05/20/%E5%B7%A5%E6%8E%A7%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/9.png"></p>
<p><em>MODBUS常用功能码</em></p>
<p><img src="/2023/05/20/%E5%B7%A5%E6%8E%A7%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/10.png"></p>
<h3 id="MODBUS通讯协议格式"><a href="#MODBUS通讯协议格式" class="headerlink" title="MODBUS通讯协议格式"></a>MODBUS通讯协议格式</h3><p>分为两种，TCP和RTU</p>
<p><img src="/2023/05/20/%E5%B7%A5%E6%8E%A7%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/11.png"></p>
<h4 id="RTU举例"><a href="#RTU举例" class="headerlink" title="RTU举例"></a>RTU举例</h4><p>设从机地址为01H，线圈寄存器的起始地址为0017H，读38个寄存器</p>
<p>主机发送地址格式</p>
<table>
<thead>
<tr>
<th align="center">从机地址</th>
<th align="center">功能码</th>
<th align="center">起始地址高位</th>
<th align="center">起始地址低位</th>
<th align="center">读取数量高位</th>
<th align="center">读取地址低位</th>
<th align="center">CRC高位</th>
<th align="center">CRC低位</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0x01</td>
<td align="center">0x01</td>
<td align="center">0x00</td>
<td align="center">0x17</td>
<td align="center">0x00</td>
<td align="center">0x26</td>
<td align="center">0D</td>
<td align="center">04</td>
</tr>
</tbody></table>
<p>主机返回读取格式</p>
<table>
<thead>
<tr>
<th align="center">从机地址</th>
<th align="center">功能码</th>
<th align="center">返回字节数</th>
<th align="center">数据1</th>
<th align="center">数据2</th>
<th align="center">数据3</th>
<th align="center">数据4</th>
<th align="center">数据5</th>
<th align="center">CRC高位</th>
<th align="center">CRC低位</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0x01</td>
<td align="center">0x01</td>
<td align="center">0x05</td>
<td align="center">CD</td>
<td align="center">6B</td>
<td align="center">B2</td>
<td align="center">0E</td>
<td align="center">1B</td>
<td align="center">44</td>
<td align="center">EA</td>
</tr>
</tbody></table>
<p>其中第一个字节CD标识0017号到001E号的状态，1是开，0是关<br>CRC是校验用</p>
<h4 id="ModbusTCP"><a href="#ModbusTCP" class="headerlink" title="ModbusTCP"></a>ModbusTCP</h4><p>如上图所示，TCP帧分为MBAP+PDU</p>
<p>|事务处理标识|协议标识|字节长度|单元表示符|功能码|起始地址H|起始地址L|数量H|数量L|<br>从功能码往后都是PDU</p>
<p>TCP与RTU基本一致，TCP将RTU的占地址和CRC校验<del>TCP本身就有校验功能</del></p>
<h3 id="协议固有问题❗"><a href="#协议固有问题❗" class="headerlink" title="协议固有问题❗"></a><strong>协议固有问题</strong>❗</h3><ol>
<li>缺乏认证<br>设备端只对地址进行了验证，协议端没有提供任何认证，也就是说攻击者只需要一个合法的地址就能控制设备。</li>
<li>缺乏授权<br>Modbus没有基于角色的访问控制，也没有对用户权限划分，也就是说任意用户可以执行任意权限。</li>
<li>缺乏加密<br>全部明文传输，可以很简单的捕获和解析</li>
</ol>
<h3 id="协议实现可能产生的问题❗"><a href="#协议实现可能产生的问题❗" class="headerlink" title="协议实现可能产生的问题❗"></a><strong>协议实现可能产生的问题</strong>❗</h3><ol>
<li>设计安全问题<br>安全问题在设计时常被忽略</li>
<li>缓冲区溢出漏洞<br>溢出的数据覆盖在合法数据上</li>
<li>功能码滥用<br>导致Modbus网络异常</li>
<li>ModbusTCP安全问题<br>TCP&#x2F;IP自身存在的安全问题</li>
</ol>
<h3 id="安全防护技术❗"><a href="#安全防护技术❗" class="headerlink" title="安全防护技术❗"></a><strong>安全防护技术</strong>❗</h3><ol>
<li>源头开始<br>在开发阶段融入安全设计，安全编码等安全技术</li>
<li>异常行为检测<br>开发针对Modbus系统的专用异常行为检测设备<br><img src="/2023/05/20/%E5%B7%A5%E6%8E%A7%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/12.png"></li>
<li>安全审计<br>Modbus系统的安全审计日志记录和审计功能</li>
<li>实用网络安全设备<br>禁止外部地址访问Modbus服务器</li>
</ol>
<h2 id="DNP3协议"><a href="#DNP3协议" class="headerlink" title="DNP3协议"></a>DNP3协议</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>端口<strong>20000</strong></p>
<p>最初用于遥控变电站和IED通信，后用于自动化组件间通信，遥测<br>可以通过TCP&#x2F;UDP封装<br>可靠：对CRC校验频繁使用，支持时间戳</p>
<p>两种模式：</p>
<ol>
<li>主站发起到子站</li>
<li>子站到主站自发响应</li>
</ol>
<p><img src="/2023/05/20/%E5%B7%A5%E6%8E%A7%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/12.png"></p>
<h3 id="固有问题"><a href="#固有问题" class="headerlink" title="固有问题"></a><em>固有问题</em></h3><ol>
<li>缺乏认证</li>
<li>缺乏授权</li>
<li>缺乏加密</li>
<li>协议复杂</li>
</ol>
<h3 id="实现产生问题"><a href="#实现产生问题" class="headerlink" title="实现产生问题"></a><em>实现产生问题</em></h3><ol>
<li>协议安全问题</li>
<li>功能码滥用问题</li>
<li>TCP&#x2F;IP层安全问题</li>
</ol>
<h3 id="安全防护技术"><a href="#安全防护技术" class="headerlink" title="安全防护技术"></a><em>安全防护技术</em></h3><ol>
<li>使用TLS</li>
<li>增设防火墙、IDS等</li>
</ol>
<h2 id="OPC协议"><a href="#OPC协议" class="headerlink" title="OPC协议"></a>OPC协议</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>不是严格工业类协议，开放和互操作接口标准，可以不依靠特定开发语言和开发环境，可以自由组合的过程控制软件。</p>
<h4 id="OPC-DA"><a href="#OPC-DA" class="headerlink" title="OPC DA"></a>OPC DA</h4><p>采用CS架构，需要按照OPC标准编写client和server，<strong>依赖windows，控件形式实现</strong></p>
<h4 id="OPC-UA"><a href="#OPC-UA" class="headerlink" title="OPC UA"></a>OPC UA</h4><p>不依赖于COM&#x2F;DCOM技术，具有跨平台性，在传输层上定义，接口简单一致只用一个地址空间就可以访问所有对象，<strong>浏览器实现</strong></p>
<h4 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a><em>安全问题</em></h4><ol>
<li>过时的授权服务<br>工业网络系统升级困难，许多不安全的授权机制仍在使用</li>
<li>RPC漏洞<br>可能受所有RPC相关漏洞影响</li>
<li>OPC服务器完整性<br>可以使用假冒OPC服务器进行攻击</li>
</ol>
<h4 id="安全防护技术-1"><a href="#安全防护技术-1" class="headerlink" title="安全防护技术"></a><em>安全防护技术</em></h4><ol>
<li>会话认证</li>
<li>审计</li>
<li>传输安全</li>
<li>冗余</li>
</ol>
<h2 id="其他协议"><a href="#其他协议" class="headerlink" title="其他协议"></a>其他协议</h2><h3 id="IEC"><a href="#IEC" class="headerlink" title="IEC"></a>IEC</h3><p>端口2404</p>
<p>电力行业主要工控协议</p>
<p>应用协议数据单元&#x3D;应用协议控制接口+应用数据单元</p>
<h4 id="固有问题-1"><a href="#固有问题-1" class="headerlink" title="固有问题"></a><em>固有问题</em></h4><ol>
<li>缺少认证机制</li>
<li>缺少授权机制</li>
<li>缺少加密机制</li>
<li>缓冲区溢出漏洞</li>
</ol>
<h4 id="产生问题"><a href="#产生问题" class="headerlink" title="产生问题"></a><em>产生问题</em></h4><ol>
<li>TCP&#x2F;IP层安全问题</li>
<li>功能码滥用</li>
</ol>
<h1 id="第四章-工控网络漏洞分析"><a href="#第四章-工控网络漏洞分析" class="headerlink" title="第四章 工控网络漏洞分析"></a>第四章 工控网络漏洞分析</h1><h2 id="工控网络漏洞概述"><a href="#工控网络漏洞概述" class="headerlink" title="工控网络漏洞概述"></a>工控网络漏洞概述</h2><h3 id="工控设备漏洞挖掘的可行性"><a href="#工控设备漏洞挖掘的可行性" class="headerlink" title="工控设备漏洞挖掘的可行性"></a>工控设备漏洞挖掘的可行性</h3><ol>
<li>工控设备自身局限性<br>工控设备系统自身封闭，数据接口多样，通信复杂不可改变。传统信息系统漏洞检测技术无法直接用于工业控制系统</li>
<li>漏洞挖掘的可行性<br>通过以太网和TCP&#x2F;IP链接到计算机网络的工业系统越来越多，为工控终端设备漏洞被挖掘和利用打开了通道。</li>
<li>漏洞挖掘的困难性<br>漏洞数目少，渗透测试的样例会使设备达到极限，难以挖掘。（<strong>测试需要在模拟平台上进行</strong>）</li>
</ol>
<h3 id="传统信息系统漏洞挖掘方法适用性分析"><a href="#传统信息系统漏洞挖掘方法适用性分析" class="headerlink" title="传统信息系统漏洞挖掘方法适用性分析"></a>传统信息系统漏洞挖掘方法适用性分析</h3><ol>
<li>白盒<br>有源代码，对目标完全了解然后进行漏洞挖掘</li>
<li>灰盒<br>有目标文件、对目标有部分了解</li>
<li>黑盒<br>对目标完全不了解——模糊测试</li>
</ol>
<p>由于无法获取工控系统的源代码和目标文件，因此白盒和灰盒无法使用，常用模糊测试</p>
<p><img src="/2023/05/20/%E5%B7%A5%E6%8E%A7%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/14.png"><br><del>不太明白为啥白盒误报率高</del></p>
<h3 id="工控安全漏洞分类"><a href="#工控安全漏洞分类" class="headerlink" title="工控安全漏洞分类"></a>工控安全漏洞分类</h3><ul>
<li>工控设备漏洞</li>
<li>工控网络协议漏洞</li>
<li>工控软件系统漏洞</li>
<li>工控安全防护设备漏洞</li>
</ul>
<h2 id="工控安全漏洞分析技术"><a href="#工控安全漏洞分析技术" class="headerlink" title="工控安全漏洞分析技术"></a>工控安全漏洞分析技术</h2><h3 id="构建工控系统漏洞库"><a href="#构建工控系统漏洞库" class="headerlink" title="构建工控系统漏洞库"></a>构建工控系统漏洞库</h3><p>传统漏洞库不适合工业控制系统漏洞测试，需构建工控系统专有漏洞库</p>
<h3 id="工业控制网络安全漏洞标准化工作"><a href="#工业控制网络安全漏洞标准化工作" class="headerlink" title="工业控制网络安全漏洞标准化工作"></a>工业控制网络安全漏洞标准化工作</h3><p>漏洞标准</p>
<ol>
<li>CVE<br>广泛认同</li>
<li>ICS-Cert<br>美国工控系统应急响应小组</li>
<li>CNVD<br>国家信息安全漏洞共享平台</li>
<li>CNNVD<br>国家信息安全漏洞库</li>
</ol>
<h3 id="已知漏洞检测技术"><a href="#已知漏洞检测技术" class="headerlink" title="已知漏洞检测技术"></a>已知漏洞检测技术</h3><p>基于工业漏洞库的检测技术<br>需要选用合适的检测规则，结合工控系统漏洞库，扫描系统中的关键目标系统和设备的脆弱性，还需支持工业通信协议，以及ICMP Ping扫描，端口扫描等</p>
<p><img src="/2023/05/20/%E5%B7%A5%E6%8E%A7%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/15.png"></p>
<p>漏洞扫描策略</p>
<ul>
<li>主机漏洞扫描<ul>
<li>操作员站</li>
<li>工程师站</li>
<li>服务器</li>
</ul>
</li>
<li>网络漏洞扫描<ul>
<li>目标系统</li>
<li>服务器</li>
<li>工业设备</li>
</ul>
</li>
</ul>
<p><strong>漏洞检测方法</strong></p>
<ul>
<li>直接测试<br>利用漏洞特点发现系统漏洞，通过直接观测或间接观测，一般为web服务漏洞测试和拒绝服务漏洞测试</li>
<li>推理测试<br>根据相关系统，应用版本判断是否存在某个漏洞，对系统影响小，较高的误报率</li>
<li>凭证测试<br>已有访问服务授权后进行测试</li>
</ul>
<h2 id="工控网络设备漏洞分析"><a href="#工控网络设备漏洞分析" class="headerlink" title="工控网络设备漏洞分析"></a>工控网络设备漏洞分析</h2><h3 id="工业控制系统与传统网络的区别"><a href="#工业控制系统与传统网络的区别" class="headerlink" title="工业控制系统与传统网络的区别"></a>工业控制系统与传统网络的区别</h3><p>功能需求：<br>工业控制系统与传统互联网之间的差异，导致传统的漏洞扫描技术无法直接移植到工业控制系统上。<br>非功能性需求：<br>需要避免干扰脆弱工控设备的正常运行</p>
<p>需考虑的点：</p>
<ol>
<li>系统架构</li>
<li>设备类型</li>
<li>安全机制</li>
<li>通信协议</li>
<li>安全后果</li>
</ol>
<p>主动扫描<br>通过直接互动发送网络流量探测受害者的基础设施。</p>
<p>被动扫描<br>不需要直接互动，通过从目标计算机上捕获的网络数据中收集信息的分析，仅限于查看现有的流量</p>
<p>SCADA主被动结合</p>
<p><img src="/2023/05/20/%E5%B7%A5%E6%8E%A7%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/17.png"></p>
<h3 id="Fuzzing❗"><a href="#Fuzzing❗" class="headerlink" title="Fuzzing❗"></a>Fuzzing❗</h3><p>通过构造能使如那件崩溃的畸形输入来挖掘系统中漏洞的方法<br>常被用来挖掘网络协议、文件、ActiveX控件中存在于输入验证和应用逻辑的漏洞</p>
<p><img src="/2023/05/20/%E5%B7%A5%E6%8E%A7%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/16.png"></p>
<p>三个阶段</p>
<ul>
<li>协议解析<br>通过公开资料或对网络数据流量的解析，理解待测协议的层次等信息</li>
<li>测试用例生成<br>依据分析出来的包字段结构，给待测对象发送生成的畸形测试用例</li>
<li>异常捕获和解析<br>通过多种探测手段发现由测试用例触发的异常，保存异常相关数据信息</li>
</ul>
<p>Fuzzing分类：</p>
<ol>
<li>基于生成的Fuzzing：<br> 基于与有效输入结构和协议状态的生成规则进行建模，构造模糊输入</li>
<li>基于突变的Fuzzing：<br> 通过在已有的数据样本中插入畸形字节以及变换字节来修改正常输入，制造模糊输入。<br> 更适合对私有协议测试</li>
</ol>
<p>Fuzzing难点——工控协议解析</p>
<ol>
<li>对于公开协议：<br>工控协议面向控制，高度结构化，控制字段数量较多，需要构造大量变异器，测试效率不高</li>
<li>对于私有协议：<br>协议资料不公开或半公开，要不对协议栈逆向分析，要不抓取协议数据包，依据历史来推断协议语义</li>
<li>对于嵌入式工控系统：<br>其大量使用私有协议，运行环境较为封闭，很难使用加载调试器的逆向分析，基于数据流量的分析更实际，但工控设备时间敏感，基于突变的传统Fuzzing测试工具不现实</li>
</ol>
<p>Fuzzing难点——工控协议异常捕捉和定位<br>主要异常检测手段有返回信息分析、调试器、日志跟踪</p>
<ol>
<li>返回信息分析<br> 分析请求发送后收到的信息判断<br> 如果请求收发频率不够高，将无法捕获发生的异常</li>
<li>调试器跟踪<br> 监视服务器进程，当其发生错误时捕捉异常<br> 无法用于PLC等设备，因其无法安装第三方工具</li>
<li>日志跟踪<br> 解析服务器日志<br> 但PLC等设备严格制约计算存储网络访问等</li>
</ol>
<p>Fuzzing设计准则</p>
<ol>
<li>对私有工控协议测试：<ol>
<li>基于离线分析<br> 梳理协议内容生成协议模型，将私有协议变为公有协议<br> 需要积累相当数量的历史数据，实时性差</li>
<li>基于在线分析<br> 在线使用人工智能实时对网络流量进行学习，目前还在初期，但在不断提升</li>
</ol>
</li>
<li>不依赖本地调试<br> PLC不能让他调试，选择使用网络探测，心跳机制</li>
<li>具有对网络协议进行双向测试的能力<br> 对工控协议的测试需要对CS双端的测试，且数据流量小，类型单一，几乎免疫传统Fuzzing工具<br> 可行的是采取内联方式，通过ARP欺骗，将Fuzzing插入CS之间，使用重放或中间人将数据突变</li>
</ol>
<h3 id="上位机漏洞分析："><a href="#上位机漏洞分析：" class="headerlink" title="上位机漏洞分析："></a><em>上位机漏洞分析：</em></h3><p>不重点</p>
<p>上位机：<br>操作员站，工程师站，HMI</p>
<p>常见漏洞：</p>
<ol>
<li>缓冲区溢出漏洞</li>
<li>字符串溢出漏洞</li>
<li>指针相关漏洞</li>
<li>内存管理相关漏洞</li>
<li>数据类溢出漏洞</li>
</ol>
<p>DLL劫持漏洞分析<br>使用DLL劫持检查工具，重启目标进程后检测标记代码</p>
<p>上位机ActiveX控件漏洞<br>ActiveX控件标注为SFS后，IE可以通过脚本语言调用控件并修改属性</p>
<ul>
<li>逻辑类漏洞<br>不该标记SFS的意外的标记了</li>
<li>溢出类漏洞<br>标记SFS的代码段存在溢出风险</li>
</ul>
<p>上位机服务类漏洞分析<br>上位机一般都需要安装很多服务，因此服务提权类漏洞比较普遍，且无法用Fuzzing工具进行挖掘<br>服务提权类漏洞挖掘：<br>安装模拟上位机系统，枚举上位机的服务并侦测该服务对各个用户组的权限，筛选用户组和权限，并循环枚举</p>
<h3 id="下位机漏洞分析❗"><a href="#下位机漏洞分析❗" class="headerlink" title="下位机漏洞分析❗"></a>下位机漏洞分析❗</h3><p>下位机：PLC，智能仪表，智能模块等</p>
<p>上位机发出命令下达下位机，下位机转化为时序信号控制相应设备，下位机周期的读取设备状态信息，转换成数字信号反馈给上位机</p>
<p>下位机漏洞</p>
<ol>
<li>未授权访问<br>非法用户进入网络或系统进行违法操作，合法用户已未授权方式操作<br>防止方法：访问控制<br>入网访问控制，网络权限控制，目录级安全控制，属性安全控制，网络服务器安全控制，网络检测和锁定控制，网络端口和节点的安全控制</li>
<li>通信协议脆弱性<br>当初为了追求实用性和实效性牺牲了安全性<br>明文密码传输漏洞，通信会话无复杂验证机制导致的伪造数据攻击漏洞，通信协议处理进程设计导致的溢出漏洞</li>
<li>Web用户接口漏洞<br>方便用户管理，下位机配备了web人机接口<br>命令注入，代码注入，任意文件上传，越权访问，跨站脚本</li>
<li>后门账号<br>开发者在系统开发时有意在工控系统代码中设计的隐藏账号或特殊命令</li>
</ol>
<h3 id="工控网络设备常见安全问题"><a href="#工控网络设备常见安全问题" class="headerlink" title="工控网络设备常见安全问题"></a>工控网络设备常见安全问题</h3><p>基本的工控网络设备<br>工控计算机（FTP服务器，Web服务器）、集线器、工控交换机、工控路由器、工控防火墙</p>
<p>常见web安全问题</p>
<ul>
<li>SQL注入</li>
<li>XSS</li>
<li>文件包含</li>
<li>命令执行</li>
<li>信息泄露</li>
</ul>
<p>XSS的检测</p>
<ul>
<li>可得知输出位置的XSS手动检测<br>输入敏感字符，提交后查看html源码，看这些字符是否被转义</li>
<li>不可知输出位置的XSS手动检测<br>Web程序源码不公开，测试时不能直接确定值的输出位置，通常采用输入”&#x2F;&gt;XSS Test测试</li>
<li>软件自动检测</li>
</ul>
<h1 id="工业控制网络安全威胁"><a href="#工业控制网络安全威胁" class="headerlink" title="工业控制网络安全威胁"></a>工业控制网络安全威胁</h1><h2 id="工业控制网络常见安全威胁"><a href="#工业控制网络常见安全威胁" class="headerlink" title="工业控制网络常见安全威胁"></a>工业控制网络常见安全威胁</h2><ol>
<li>工业控制网络病毒</li>
<li>工业控制网络协议安全漏洞</li>
<li>高级持续性威胁APT攻击<br>一种以商业和政治为目的的网络犯罪类别，通常使用先进的攻击手段对特定目标进行长期持续性的网络攻击<br> 五个阶段<ol>
<li>收集情报</li>
<li>突破防线</li>
<li>建立据点</li>
<li>隐秘横向渗透</li>
<li>完成任务</li>
</ol>
</li>
</ol>
<h2 id="工业控制网络常见攻击行为"><a href="#工业控制网络常见攻击行为" class="headerlink" title="工业控制网络常见攻击行为"></a>工业控制网络常见攻击行为</h2><p>看看就行</p>
<p><img src="/2023/05/20/%E5%B7%A5%E6%8E%A7%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/18.png"></p>
<h2 id="工业控制系统脆弱性分析❗"><a href="#工业控制系统脆弱性分析❗" class="headerlink" title="工业控制系统脆弱性分析❗"></a>工业控制系统脆弱性分析❗</h2><p>每个都要求能说几点</p>
<h3 id="现场总线控制网络"><a href="#现场总线控制网络" class="headerlink" title="现场总线控制网络"></a>现场总线控制网络</h3><p>此网络利用总线技术将传感器&#x2F;计数器等设备与PLC和其他控制中心相连</p>
<ul>
<li>脆弱性分析<ol>
<li>不安全的接入方式</li>
<li>不安全的串口链接，或缺乏有效的配置检查</li>
<li>包含了大量工控设备，设备本身存在工控安全漏洞</li>
<li>传输的工业控制系统数据无加密，存在被篡改和泄露的风险</li>
<li>缺少工控网络安全审计及入侵检测防御等措施，容易对该网络内的设备和系统数据造成破坏</li>
<li>物理隔离设备策略配置不当</li>
</ol>
</li>
</ul>
<h3 id="SCADA-1"><a href="#SCADA-1" class="headerlink" title="SCADA"></a>SCADA</h3><p>SCADA，实时数据库，人机界面</p>
<ul>
<li>脆弱性分析<ol>
<li>不安全的移动维护设备未授权接入</li>
<li>监控网络与RTU&#x2F;PLC之间不安全的无线通信</li>
<li>现场设备层和过程控制层主要使用现场总线协议和工业以太网协议<ul>
<li>总线缺少认证、授权、加密等安全因素</li>
<li>以太网协议总是对协议进行了简单封装，没有安全性，且存在处理有效&#x2F;无效格式化消息方面的缺陷</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="企业办公网络脆弱性"><a href="#企业办公网络脆弱性" class="headerlink" title="企业办公网络脆弱性"></a>企业办公网络脆弱性</h3><ol>
<li>IT资产转身漏洞的脆弱性</li>
<li>网络互联给系统带来的脆弱性</li>
<li>内部管理机制缺失带来的脆弱性</li>
<li>缺乏安全意识带来的脆弱性</li>
</ol>
<h2 id="工业控制网络安全威胁TOP10"><a href="#工业控制网络安全威胁TOP10" class="headerlink" title="工业控制网络安全威胁TOP10"></a>工业控制网络安全威胁TOP10</h2><p>这个大概不重点，老师总结的时候没提</p>
<ol>
<li>遗留软件（旧版本）<br>OT系统运行在传统软件，缺乏足够的用户和系统认证及完整性校验等功能</li>
<li>默认配置</li>
<li>缺乏加密</li>
<li>远程访问政策<br>连接到未经审计的线路或远程访问服务器的SCADA系统给攻击者溜了后门</li>
<li>政策和程序<br>当IT和OT在保护工业控制方法存在差异时会产生安全漏洞</li>
<li>缺少网络隔离<br>网络或防火墙配置错误</li>
<li>DDoS攻击</li>
<li>网络应用程序攻击<br>通过网络接口攻击HMI，PLC等</li>
<li>恶意软件</li>
<li>命令注入和参数操纵</li>
</ol>
<p>注：运营技术（Operational Technology）也称为 OT，是使用硬件和软件来控制工业设备的实践方法。 OT 包括了在制造业、能源、医药、建筑管理和其他行业内使用的专业系统。 OT 常被拿来与 IT（Information Technology，信息技术）对比，后者主要面向的是数据系统。 OT 系统主要用于跟现实世界交互，IT 则主要用来解决业务问题。</p>
<h2 id="工业控制系统面临的安全问题"><a href="#工业控制系统面临的安全问题" class="headerlink" title="工业控制系统面临的安全问题"></a>工业控制系统面临的安全问题</h2><p>这个大概也不重点，老师总结的时候没提</p>
<ol>
<li>普遍缺乏安全设计<br>工业控制系统牺牲安全性换取实时性</li>
<li>存在大量漏洞、后门<br>设备大都来自国外，被留了后门</li>
<li>设备联网混乱、缺乏安全防护<br>工业生产环境中的越来越多传感器等设备与办公网，互联网等第三方网络链接，且常把危险的个人计算机接入网络中。</li>
<li>工业主机”带洞“、”带病“运行</li>
<li>工业资产不清晰</li>
<li>缺少必要的检测预警手段，可视化、可读化差</li>
<li>工业数据存在风险<br>设备运行数据，工艺配方数据，生产操作数据等存在潜在的挖掘分析价值</li>
<li>工业企业安全管理问题<ul>
<li>管理制度不健全，不体系化</li>
<li>有一些工业企业的边界设备属于”三不管“地步</li>
</ul>
</li>
<li>安全运维管理不到位，应急响应不健全<br>大部分企业将资产交给设备厂商或系统集成商或第三方运维，导致误操作，违规操作，生产数据无监控无审计等</li>
<li>工业控制系统信息安全投入不足，人员意识差</li>
</ol>
<h3 id="工业主机存在的主要问题"><a href="#工业主机存在的主要问题" class="headerlink" title="工业主机存在的主要问题"></a>工业主机存在的主要问题</h3><ol>
<li>工业主机操作系统版本老旧，且补丁不宜更新，不敢更新，不想更新</li>
<li>安全配置基线无加固，存在弱口令，无关第三方软件等</li>
<li>恶意代码防范能力弱</li>
<li>移动储存介质管控，移动储存介质导致病毒，木马进入工业生产环境中</li>
</ol>
<h1 id="第六章-SCADA系统安全分析"><a href="#第六章-SCADA系统安全分析" class="headerlink" title="第六章 SCADA系统安全分析"></a>第六章 SCADA系统安全分析</h1><h2 id="现代SCADA系统"><a href="#现代SCADA系统" class="headerlink" title="现代SCADA系统"></a>现代SCADA系统</h2><ol>
<li>提高连通性，允许与外部企业网络通信</li>
<li>使用价格便宜的通用硬件</li>
<li>采用通用的网络协议进行通信</li>
</ol>
<h2 id="SCADA-安全目标-AIC"><a href="#SCADA-安全目标-AIC" class="headerlink" title="SCADA 安全目标 AIC"></a>SCADA 安全目标 AIC</h2><ul>
<li>A：高可用性要求安全防护手段不能中断正常业务</li>
<li>I：防止数据在传输过程中被非授权修改</li>
<li>C：对敏感性较低的采集数据和控制指令被长期探测采集，使攻击者可以分析SCADA的工作规律</li>
</ul>
<h2 id="SCADA脆弱性"><a href="#SCADA脆弱性" class="headerlink" title="SCADA脆弱性"></a>SCADA脆弱性</h2><ol>
<li>策略和程序脆弱性<br> <img src="/2023/05/20/%E5%B7%A5%E6%8E%A7%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/19.png"></li>
<li>架构和设计脆弱性<br> <img src="/2023/05/20/%E5%B7%A5%E6%8E%A7%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/20.png"></li>
<li>配置和管理脆弱性<br> <img src="/2023/05/20/%E5%B7%A5%E6%8E%A7%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/21.png"></li>
<li>物理脆弱性<br> <img src="/2023/05/20/%E5%B7%A5%E6%8E%A7%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/22.png"></li>
<li>软件开发脆弱性<br> <img src="/2023/05/20/%E5%B7%A5%E6%8E%A7%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/23.png"></li>
<li>通信网络脆弱性<br> <img src="/2023/05/20/%E5%B7%A5%E6%8E%A7%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/24.png"></li>
</ol>
<h2 id="SCADA安全关键技术"><a href="#SCADA安全关键技术" class="headerlink" title="SCADA安全关键技术"></a>SCADA安全关键技术</h2><h3 id="安全域划分"><a href="#安全域划分" class="headerlink" title="安全域划分"></a>安全域划分</h3><p>因SCADA的结构复杂，实施整体安全方案异常困难，因此实现纵深安全防御体系，在安全域边界部署安全防护装置，实现物理隔离或逻辑隔离</p>
<p>IEC-62443<br>四个类，七个基本需求<br>定义了系统的四个安全保障等级</p>
<ul>
<li>SAL1</li>
<li>SAL2</li>
<li>SAL3</li>
<li>SAL4</li>
</ul>
<p>IEC-62443建议通过横向分区，纵向分域，对控制系统的各个子系统进行分段管理，区域之间的通信通过专用通道执行，通过对管道的管理来阻挡区域之间的非法通信，保护网络区域和其中的设备</p>
<p>在安全域之间部署防火墙、路由器、入侵检测、隔离网闸等设备，实现网络隔离和边界安全防护<br>原则：</p>
<ol>
<li>尽可能综合使用网络层、传输层、应用层数据过滤技术</li>
<li>严格遵守最小权限原则</li>
<li>使用白名单设置防火墙过滤规则</li>
<li>需要认证评估对控制系统网络通信延迟的影响</li>
<li>需要经常审查过滤规则，并根据安全需求和安全威胁的变化动态调整规律规则</li>
</ol>
<p>防火墙部署方案：</p>
<ol>
<li>办公网络和控制网络间部署单防火墙<ul>
<li>历史数据库在控制网络然后允许管理员访问控制网络的历史数据库会引起SQL注入</li>
<li>如果设置在办公网络，必须设置防火墙规则允许历史数据库与控制设备之间的网络通信，办公网可以攻击控制设备</li>
</ul>
</li>
<li>办公网络和控制网络间部署带隔离区防火墙</li>
<li>办公网络和控制网络间部署成对防火墙<ul>
<li>一台防火墙阻断进入控制结构和公共区域</li>
<li>一台防止从被攻击的服务器链接控制网络</li>
</ul>
</li>
</ol>
<h3 id="SCADA系统入侵检测技术"><a href="#SCADA系统入侵检测技术" class="headerlink" title="SCADA系统入侵检测技术"></a>SCADA系统入侵检测技术</h3><ol>
<li>基于主机的入侵检测系统<br> 当有文件发生变化时，系统将新的记录条目与攻击标记相比较<br> 部署感应器，可能降低主机性能，影响可用性</li>
<li>基于网络的入侵检测系统<br> SCADA网络通信包括：现场网络内不通信数据，控制网络内部通信数据，现场网络和控制网络之间通信数据</li>
<li>基于误用&#x2F;知识的入侵检测系统<br> 误报少，不能检测未知攻击</li>
<li>异常入侵检测系统<br> 能检测未知，误报多</li>
</ol>
<h3 id="SCADA系统异常行为检测技术"><a href="#SCADA系统异常行为检测技术" class="headerlink" title="SCADA系统异常行为检测技术"></a>SCADA系统异常行为检测技术</h3><ol>
<li>基于主机的异常入侵检测<ol>
<li>PLC&#x2F;MTU的配置信息和报警信息，操作员的操作信息</li>
<li>数据归一化和融合</li>
<li>分析</li>
<li>挖掘得到极少发生的事件模板</li>
</ol>
</li>
<li>基于主机的误用入侵检测<br> QuickDraw是一种SCADA控制器安全事件日志采集及管理系统，记录MTU、PLC等控制器发送的安全事件类型和事件参数，并根据设定的规则检测安全攻击</li>
<li>基于网络的异常入侵检测<br> 基于网络流量，构建模型进行入侵检测判断，包括工控协议规范，网络流量层析信息，IP地址和包头个数等</li>
<li>基于网络的误用入侵检测<br> 通过分析实际环境采集的真实数据和模拟产生的仿真数据，建立攻击行为特征库</li>
</ol>
<h1 id="第七章-工控网络安全防护技术"><a href="#第七章-工控网络安全防护技术" class="headerlink" title="第七章 工控网络安全防护技术"></a>第七章 工控网络安全防护技术</h1><h2 id="滑动标尺模型"><a href="#滑动标尺模型" class="headerlink" title="滑动标尺模型"></a>滑动标尺模型</h2><p><img src="/2023/05/20/%E5%B7%A5%E6%8E%A7%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/25.png"></p>
<p><img src="/2023/05/20/%E5%B7%A5%E6%8E%A7%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/26.png"></p>
<h2 id="纵深防御策略"><a href="#纵深防御策略" class="headerlink" title="纵深防御策略"></a>纵深防御策略</h2><p>提高工业控制系统信息安全的最佳选择</p>
<p>两个目标</p>
<ul>
<li>即使某一点发生事故，也能保证整个系统正常运行</li>
<li>工厂操作人员能及时确认故障点并排除问题</li>
</ul>
<h2 id="IT网络安全体系变迁"><a href="#IT网络安全体系变迁" class="headerlink" title="IT网络安全体系变迁"></a>IT网络安全体系变迁</h2><p>P2DR-&gt;安全木桶理论-&gt;立体防御体系-&gt;云管端联动体系</p>
<p>PPDR<br>动态网络体系的代表模型也是动态安全模型的雏形</p>
<p>蜜罐&#x2F;蜜网<br>对攻击方进行欺骗</p>
<p>蜜罐：故意暴露的短板<br>基于木桶理论：吸引攻击者资源投入<br>基于P2DR模型：延迟攻击时间<br>高效鉴别恶意流量，与探针形成互补</p>
<h2 id="零信任"><a href="#零信任" class="headerlink" title="零信任"></a>零信任</h2><p>三个关键技术SIM</p>
<ol>
<li>软件定义边界SDP</li>
<li>身份与访问管理IAM</li>
<li>微隔离MSG</li>
</ol>
<p>零信任架构的设计和部署遵循以下基本原则：<br>1、所有的数据源和计算服务都被认为是资源。<br>2、所有的通信都是安全的，而且安全与网络位置无关。<br>3、对单个企业资源的访问的授权是对每次连接的授权。<br>4、对资源的访问是通过策略决定的，包括用户身份的状态和要求的系统，可能还包括其他行为属性。<br>5、企业要确保所有所属的和相关的系统都在尽可能最安全的状态，并对系统进行监控来确保系统仍然在最安全的状态。<br>6、用户认证是动态的，并且在允许访问前严格执行。</p>
<h2 id="工控网络安全设备引入和使用"><a href="#工控网络安全设备引入和使用" class="headerlink" title="工控网络安全设备引入和使用"></a>工控网络安全设备引入和使用</h2><p>(1)工控系统对可靠性和生存期的要求较高，所以其使用的系统与网络技术很容易被攻击者所超越。工业控制系统可能需要不间断地运行数月或者数年，其全部生命周期也可能长达数十年，而攻击者却可以在任何时候使用新的工具进行攻击<br>(2)工业网络的系统落后于现代网络基础设施，总是只能保证物理安全而非信息安全</p>
<ol>
<li>工控网络边界安全防护</li>
<li>区域边界安全防护<ol>
<li>工业防火墙</li>
<li>安全监测平台</li>
<li>安全审计平台</li>
<li>单向网关（闸）</li>
<li>入侵检测设备</li>
</ol>
</li>
<li>区域内部安全防护</li>
</ol>
<h2 id="ICS安全的特殊限制"><a href="#ICS安全的特殊限制" class="headerlink" title="ICS安全的特殊限制"></a>ICS安全的特殊限制</h2><ol>
<li>设备相关限制</li>
<li>网络相关限制</li>
<li>安全相关限制</li>
<li>运行时间和正常运行时间要求</li>
<li>缺乏足够的安全考虑</li>
</ol>
<h2 id="已知安全威胁的防护方法"><a href="#已知安全威胁的防护方法" class="headerlink" title="已知安全威胁的防护方法"></a>已知安全威胁的防护方法</h2><ol>
<li>结构安全<br>基础设施过程中网络拓扑结构，以及区域、层次的划分是否满足安全需求<ol>
<li>结构优化<br> 结构安全的核心，本质是分区隔离</li>
<li>访问控制<br> 控制如何访问目标资源</li>
<li>防火墙<br> 四种主要服务：服务控制，方向控制，用户控制，行为控制</li>
</ol>
</li>
<li>设备和主机安全<ol>
<li>漏洞发现和打补丁<ol>
<li>探测系统的存活性</li>
<li>对存活设备进行协议和端口扫描，确定开放的端口协议</li>
<li>根据协议指纹技术识别出主机的系统类型和版本</li>
<li>根据目标系统的操作系统和提供的网络服务调用漏洞库中已知的各种漏洞进行逐一扫描</li>
<li>通过对探测响应数据包的分析判断是否存在漏洞</li>
</ol>
</li>
<li>补偿性措施<br> 保护设备拦截特定数据包</li>
</ol>
</li>
<li>行为安全<ul>
<li>系统内部行为</li>
<li>系统外部行为</li>
</ul>
</li>
</ol>
<h2 id="未知安全威胁的防护方法"><a href="#未知安全威胁的防护方法" class="headerlink" title="未知安全威胁的防护方法"></a>未知安全威胁的防护方法</h2><ol>
<li>纵深防御技术<br>通过对安全设备生成的结论和日志信息进行评估，覆盖所有区域的通信状态、用户访问、运行控制管理等，借助 SIEM和日志分析管理类的工具，将信息进行基本的关联；在人工充分地理解和分析判断的情况下，可以确定异常行为和未知威胁</li>
<li>异常检测技术<ol>
<li>异常参量<br> 异常行为检测的最小分析单元<br> 每一个参量单元都是基于时间的</li>
<li>异常行为<br> 工业控制系统的规律性和稳定性更强，可以更好检测异常行为</li>
<li>白名单技术<br> 最准确的防御所有未知威胁<ol>
<li>应用白名单<br> 防止未认证的应用程序</li>
<li>用户白名单<br> 对一般的用户活动和管理员行为进行分析</li>
<li>资产白名单<br> 对未知设备进行行为进行干预</li>
<li>行为白名单<br> 需要区别正常那个行为和其他恶意行为</li>
</ol>
</li>
<li>关联分析技术<br> 识别工控系统中安全事件、攻击活动、潜在威胁之间的关联关系<ol>
<li>智能列表<br> 基于白名单和时间轴线动态的定义了黑名单的内容</li>
<li>事件关联<br> 通过大量离散的事件数据并把其作为一个整体<ol>
<li>多源关联<br> 将关联扩展到多个数据源</li>
<li>分层关联<br> 指的是一个关联规则关系中嵌套另一个关联规则，针对攻击溯源以及时间关联性</li>
<li>系统关联<br> 安全事件不会局限于一个系统中</li>
</ol>
</li>
</ol>
</li>
<li>蜜罐技术<br> 三部分：数据捕获技术，数据控制技术，数据分析技术<br> 两种系统日志：基于主机的信息收集方式，基于网络的信息收集方式</li>
</ol>
</li>
</ol>
<h1 id="第八章-综合案例"><a href="#第八章-综合案例" class="headerlink" title="第八章 综合案例"></a>第八章 综合案例</h1><p>这里推荐自己看，最后一个的蓝本，主要理解，明白怎么分析的</p>
<h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><p><img src="/2023/05/20/%E5%B7%A5%E6%8E%A7%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8_1.jpeg"><br><img src="/2023/05/20/%E5%B7%A5%E6%8E%A7%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8_2.jpeg"><br><img src="/2023/05/20/%E5%B7%A5%E6%8E%A7%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8_3.jpeg"><br><img src="/2023/05/20/%E5%B7%A5%E6%8E%A7%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8_4.jpeg"><br><img src="/2023/05/20/%E5%B7%A5%E6%8E%A7%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8_5.jpeg"><br><img src="/2023/05/20/%E5%B7%A5%E6%8E%A7%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8_6.jpeg"><br><img src="/2023/05/20/%E5%B7%A5%E6%8E%A7%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8_7.jpeg"><br><img src="/2023/05/20/%E5%B7%A5%E6%8E%A7%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8_8.jpeg"><br><img src="/2023/05/20/%E5%B7%A5%E6%8E%A7%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8_9.jpeg"><br><img src="/2023/05/20/%E5%B7%A5%E6%8E%A7%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8_10.jpeg"><br><img src="/2023/05/20/%E5%B7%A5%E6%8E%A7%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8_11.jpeg"></p>
]]></content>
      <categories>
        <category>学习资料</category>
      </categories>
  </entry>
  <entry>
    <title>计算机网络-自顶向下方法-复习</title>
    <url>/2023/05/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95-%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="计算机网络与因特网"><a href="#计算机网络与因特网" class="headerlink" title="计算机网络与因特网"></a>计算机网络与因特网</h1><p>分组交换优点</p>
<ul>
<li>提供更好的带宽共享</li>
<li>比电路交换更简单成本更低</li>
</ul>
<p>分组交换与电路交换对比两个情景</p>
<ul>
<li>当有10个或以下的活跃用户是，分组流几乎没有延迟，与电路交换一样</li>
<li>分组当仅有一个活跃用户时，该用户仅可以使用每帧中的一个时隙来传输数据</li>
</ul>
<p>时延类型</p>
<ul>
<li>节点处理时延</li>
<li>排队时延<br>  流量强度大于一，则延迟无限延长，设计时需要流量强度小于一</li>
<li>传输时延</li>
<li>传播时延</li>
</ul>
<p>OSI</p>
<ul>
<li>应用层</li>
<li>表示层</li>
<li>会话层</li>
<li>传输层</li>
<li>网络层</li>
<li>链路层</li>
<li>物理层</li>
</ul>
<p>五层</p>
<ul>
<li>应用层<br>  HTTP,SMTP,FTP<br>  网络地址转换借助DNS完成</li>
<li>传输层<br>  TCP,UDP</li>
<li>网络层<br>  IP</li>
<li>链路层<br>  以太网，wifi</li>
<li>物理层</li>
</ul>
]]></content>
      <categories>
        <category>学习资料</category>
      </categories>
  </entry>
  <entry>
    <title>震惊！某985网安专业学生竟被网络诈骗，金额高达1800元！</title>
    <url>/2023/04/15/%E9%9C%87%E6%83%8A%EF%BC%81%E6%9F%90985%E7%BD%91%E5%AE%89%E5%AD%A6%E7%94%9F%E7%AB%9F%E8%A2%AB%E7%BD%91%E7%BB%9C%E8%AF%88%E9%AA%97%EF%BC%8C%E9%87%91%E9%A2%9D%E9%AB%98%E8%BE%BE1000%E5%85%83%EF%BC%81/</url>
    <content><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>事情发生背景是这两天CS2快发布了，起源二引擎刚刚公布。</p>
<p>然而，CS2可以继承CSGO饰品，我的一个好兄弟合理推断饰品将会大幅涨价，于是趁这个时间开始入手。</p>
<p>于是我就以1200的价格入手了一款匕首</p>
<p><img src="/2023/04/15/%E9%9C%87%E6%83%8A%EF%BC%81%E6%9F%90985%E7%BD%91%E5%AE%89%E5%AD%A6%E7%94%9F%E7%AB%9F%E8%A2%AB%E7%BD%91%E7%BB%9C%E8%AF%88%E9%AA%97%EF%BC%8C%E9%87%91%E9%A2%9D%E9%AB%98%E8%BE%BE1000%E5%85%83%EF%BC%81/1.png"></p>
<p>这玩意就长这样，其实还是很好看的，买的久经沙场，刀面稍微有点污渍不过无伤大雅，性价比超高。</p>
<p>现在已经涨价到1800左右，涨了整整50%，投资大成功！</p>
<h1 id="诈骗过程"><a href="#诈骗过程" class="headerlink" title="诈骗过程"></a>诈骗过程</h1><p>我花一千多买了个饰品不能不拿在手里把玩啊，于是我就回坑CSGO</p>
<p><del>也不算是回坑，因为我本来没咋玩过CSGO，上一次接触CS还是小学时的CS1.6</del></p>
<p>鉴于我强大的FPS经验，打的还算可以<del>在60小时玩家里属于牛逼得了</del></p>
<p>突然有一天有个哥们加我好友，一直在刷让我给tyloo投票，说在打什么比赛啥的，还发了好多链接。</p>
<p>相信大伙已经能看出来这是怎么诈骗得了，纯纯的诈骗链接，但是我当时想法是</p>
<p>现在都2023年了，怎么还会有人用钓鱼链接诈骗呢？</p>
<p>现在都2023年了，怎么还会有人用钓鱼链接诈骗呢？</p>
<p>现在都2023年了，怎么还会有人用钓鱼链接诈骗呢？</p>
<p>现在想想我真的智障。</p>
<p>当我否定了钓鱼链接的可能性后，我认为是哥们水平太高了有人想拉我进组之类的</p>
<p>然后我就很高兴的打开了链接并登录了steam</p>
<p>但是我登上之后发现没法跳转，页面无响应，我当时就想从别的地方投票吧，在网上搜索“CSGO tyloo投票”，然后就发现很多人写类似的贴子防诈骗。</p>
<p>这时我才意识到，我被骗了。</p>
<p>不过还好，我的反应属于迅速的，并没有对我造成实质性的损害。<del>目前</del></p>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>对于这种诈骗，首先如果你点了链接，并输入了账号密码。</p>
<p>此时你需要及时重置你的API，并且更换密码，然后再次重置API</p>
<p>理论上到这一步就可以了，但是建议继续做更多的，重新获得交易链接，并开启家庭监护，这样就算有你的API也没法进行真正的转移。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>不要眼高手低，像钓鱼链接这种10年前就该淘汰的诈骗方法也不能忽视，虽然我不太懂为啥要用15年前的诈骗方法来搞我。可能现在大伙网安意识确实不高，这种诈骗方式很有效，<del>同时对于我这种B也很有效</del></p>
]]></content>
      <categories>
        <category>发癫产物~</category>
      </categories>
  </entry>
  <entry>
    <title>网络安全-复习</title>
    <url>/2023/05/15/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="标记类型"><a href="#标记类型" class="headerlink" title="标记类型"></a>标记类型</h2><ul>
<li>斜体：看看就行</li>
<li>正常：正常掌握</li>
<li>粗体&#x2F;emoji❗：重点掌握</li>
</ul>
<p>暂时没有完全标记，第一遍没法全部标记，第二遍会完整标记</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>我的疏忽从第一章到第三章ppt用的是往年的，这里可以看看你们亲爱的刘教官的总结，他用的是新ppt</p>
<h1 id="1-1-典型网络安全事件剖析"><a href="#1-1-典型网络安全事件剖析" class="headerlink" title="1-1 典型网络安全事件剖析"></a>1-1 典型网络安全事件剖析</h1><h2 id="事件分析"><a href="#事件分析" class="headerlink" title="事件分析"></a><em>事件分析</em></h2><ul>
<li>不知道是啥但也是事件，没有下面的重要<ul>
<li>某航空公司数据被境外间谍情报机关网络犯罪窃取案</li>
<li>疫情期间多个组织对我国政府部门发起攻击</li>
<li>蔓灵花组织对我国政府及教育科研机构发动钓鱼邮件攻击</li>
<li>多地高校数万学生隐私遭泄漏</li>
<li>疑似5.38亿条微博用户信息泄露</li>
<li>800万条公民个人信息被售卖</li>
<li>疑似超2亿国内个人信息在国外暗网论坛兜售</li>
<li>台积电生产工厂和营运总部中勒索病毒</li>
<li>多个行业感染incaseformat病毒</li>
<li>易到用车服务器遭攻击，黑客勒索巨额比特币</li>
<li>拼多多现优惠券漏洞，遭黑产团伙盗取数千万</li>
<li>SolarWinds遭攻击</li>
<li>美国医疗机构数据泄露造成130亿美元损失</li>
<li>Colonial Pipeline遭勒索软件攻击</li>
</ul>
</li>
<li>淘宝9900万账户信息遭窃<ul>
<li>不同的网站采用不同的用户名和密码</li>
</ul>
</li>
<li>OpenSSL水牢漏洞</li>
<li>国内部分网站存在Rammit恶意代码攻击<ul>
<li>禁止执行不明来源的ActiveX控件</li>
</ul>
</li>
<li>跨境冒充公检法1.17亿电信诈骗案<ul>
<li>诈骗分子重点在于掌握了被骗者的重要信息，再利用这些实信息实施精心策划的骗局，获取被骗者的充分信任</li>
</ul>
</li>
<li>2.7亿Gmail、雅虎和Hotmail账号遭泄露<ul>
<li>服务提供商没有很好的考虑用户数据安全问题</li>
</ul>
</li>
<li>全美互联网瘫痪<ul>
<li>DDoS攻击又称为分布式拒绝服务攻击。最基本的DDoS就是黑客利用合理的服务请求去占用尽可能多的服务资源，从而使得用户无法得到服务响应</li>
</ul>
</li>
<li>5家俄罗斯银行遭遇DDoS攻击<ul>
<li>今天，DDoS攻击已转化为一个完善的产业链，从攻击肉鸡的贩卖，到发动攻击，无论是敲诈勒索，还是雇凶攻打，背后都是利益的驱动</li>
</ul>
</li>
<li>希拉里邮件门影响美国大选<ul>
<li>希拉里在2009年至2013年担任国务卿的四年里，没有政府电子邮件账户，<br>只使用个人电子邮件账户来处理政府事务</li>
</ul>
</li>
<li>电信诈骗导致高中生徐玉玉身亡<ul>
<li>短信和电话是不安全的</li>
<li>电信诈骗分类<ol>
<li>电话诈骗</li>
<li>网络诈骗</li>
<li>短信诈骗</li>
<li>传统媒介诈骗</li>
</ol>
</li>
</ul>
</li>
<li>黑客利用恶意软件Mirai导致德国90万台路由器瘫痪<ul>
<li>由被恶意软件感染的路由器和网络摄像头发起</li>
</ul>
</li>
</ul>
<h2 id="网络安全趋势分析"><a href="#网络安全趋势分析" class="headerlink" title="网络安全趋势分析"></a><em>网络安全趋势分析</em></h2><ul>
<li>网络安全法律体系将加速形成<ul>
<li>《网络安全法》的出台</li>
</ul>
</li>
<li>关键信息基础设施面临的网络安全风险不断攀升<ul>
<li>针对关键信息基础设施的攻击频率将进一步增加，产生的后果将更加严重</li>
</ul>
</li>
<li>物联网智能终端引发的安全事件进一步升级<ul>
<li>2017年随着物联网智能设备的进一步应用，智能设备漏洞导致的网络威胁范围更广，后果也将更加严重</li>
</ul>
</li>
<li>精准化的网络诈骗现象将更加突出<ul>
<li>通过大数据和社会工程学分析用户购物数据、社交数据、位置数据、物流数据的精准网络诈骗逐渐成为趋势，传统“撒网”式电信诈骗逐渐退出舞台</li>
</ul>
</li>
<li>移动支付面临的安全形势更加严峻<ul>
<li>随着移动设备和移动支付用户的继续“爆炸式”增长，移动支付面临的安全问题也将更加凸显</li>
</ul>
</li>
<li>网络可信身份的互联互通加速实现<ul>
<li>我国势必会加强网络可信身份体系建设，积极推动已有的网络身份认证体系的互联互通，建立跨平台的网络可信身份体系</li>
</ul>
</li>
<li>安全可控信息产业将得到爆发式增长<ul>
<li>随着《网络安全法》的出台，党政军等重要部门网络安全审查力度将进一步加大</li>
</ul>
</li>
<li>优秀人才脱颖而出的环境将逐步具备<ul>
<li>建立灵活的网络安全人才激励机制，如技术入股、股权期权激励、分红奖励等</li>
</ul>
</li>
<li>网络战威胁风险显著增加<ul>
<li>网络空间“军备竞赛”持续升温</li>
<li>美国重大项目<ul>
<li>棱镜项目——监视互联网以收集海量个人信息</li>
<li>主干道项目——对亿兆计的通信数据进行存储和分析</li>
<li>核子项目——截获海量电话通话者对话内容及关键词</li>
<li>码头项目——截取电子邮件，获取民众互联网元数据</li>
</ul>
</li>
</ul>
</li>
<li>双边和多边网络安全合作将持续深化</li>
</ul>
<h2 id="网络空间安全形势"><a href="#网络空间安全形势" class="headerlink" title="网络空间安全形势"></a>网络空间安全形势</h2><p>威胁政治，经济，文化，社会安全</p>
<p>网络空间内容面与资源面、用户侧与行为侧的治理成为维护我国网络空间安全与主权的最重要工作之一</p>
<p>国际上：世界各国通过加大网络空间安全的财政投入、颁布网络空间安全相关法律法规、引导技术创新方向等举措，夯实网络安全产业基础。</p>
<h2 id="网络空间典型特点"><a href="#网络空间典型特点" class="headerlink" title="网络空间典型特点"></a>网络空间典型特点</h2><p>1-5有</p>
<h2 id="四大特征"><a href="#四大特征" class="headerlink" title="四大特征"></a>四大特征</h2><ul>
<li>复杂多元网络结构</li>
<li>海量动态互联网内容服务</li>
<li>形势多样的传播方式与入口</li>
<li>动态海量易变网络资源生态体系</li>
</ul>
<h2 id="四大问题"><a href="#四大问题" class="headerlink" title="四大问题"></a>四大问题</h2><ul>
<li>实体间物理、逻辑业务关联关系建立</li>
<li>数据获取的及时性、有效性、准确性</li>
<li>数据获取的全面性、实体追踪的有效性</li>
<li>实体运营内容面与资源面生态图谱建立的全面性、准确性</li>
</ul>
<h2 id="两大现状"><a href="#两大现状" class="headerlink" title="两大现状"></a>两大现状</h2><ul>
<li>难以建立网络空间治理的全局视图</li>
<li>无法改变治理被动的局面</li>
</ul>
<h1 id="1-2-网络与信息安全体系结构介绍"><a href="#1-2-网络与信息安全体系结构介绍" class="headerlink" title="1-2 网络与信息安全体系结构介绍"></a>1-2 网络与信息安全体系结构介绍</h1><h2 id="网络与信息安全概述"><a href="#网络与信息安全概述" class="headerlink" title="网络与信息安全概述"></a>网络与信息安全概述</h2><h3 id="安全技术"><a href="#安全技术" class="headerlink" title="安全技术"></a><em>安全技术</em></h3><ul>
<li>基于主机的入侵检测、弱点评估、风险评估、访问控制、配置日志、防病毒软件、防火墙、异常检测</li>
<li>黑洞路由、访问控制列表、负载均衡、数据分流、数据清洗、应急响应、预警通报</li>
<li>基于网络的入侵检测、数据流分析、异常检测、网络状态分析、性能测量、蜜网、抗D、恶意代码检测</li>
<li>网络风险评估、网络安全态势预测与分析、动态风险评估、网络安全态势感知、网络拓扑测量、大数据分析</li>
</ul>
<p><img src="/2023/05/15/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/1.png" alt="网络与信息安全模型"></p>
<h3 id="什么是信息安全"><a href="#什么是信息安全" class="headerlink" title="什么是信息安全"></a>什么是信息安全</h3><ul>
<li>国内<ul>
<li>沈昌祥<br>  实体安全，运行安全，数据安全，管理安全</li>
<li>教科书<br>  实体安全，软件安全，运行安全，数据安全</li>
<li>等级保护条例<br>  实体安全，运行安全，信息安全，人员安全维护</li>
</ul>
</li>
<li>国外<ul>
<li>BS7799<br>  机密性，完整性，可用性</li>
<li>教课书<br>  机密性，完整性，可用性</li>
<li>信息安全重点实验室<br>  信息的机密性，完整性，可用性，可控性，就是要保障电子信息的有效性</li>
</ul>
</li>
<li>两种主要论点<ul>
<li>国内<ul>
<li>内容安全，数据安全，运行安全，实体安全</li>
</ul>
</li>
<li>国外<ul>
<li>机密性，完整性，可用性</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="网络与信息安全涵盖范围❗"><a href="#网络与信息安全涵盖范围❗" class="headerlink" title="网络与信息安全涵盖范围❗"></a><strong>网络与信息安全涵盖范围</strong>❗</h3><ul>
<li>机密性<br>保证系统不已电磁等方式向外泄露信息</li>
<li>可用性<br>保证系统至少能提供基本的服务</li>
<li>可控性<br>保证系统的机密性，使系统任何时候不被非授权的人恶意使用</li>
<li>可用性<br>保障网络的正常运行，确保系统时刻能为授权人提供基本服务</li>
<li>真实性<br>保证数据的发送源头不被伪造<ul>
<li>来源伪造：路由欺骗，域名欺骗</li>
</ul>
</li>
<li>机密性<br>保证数据在传输，储存过程中不被获取并解析<ul>
<li>内容解析：对传递信息进行捕获和解析</li>
</ul>
</li>
<li>完整性<br>保证数据在传输、存储等过程中不被非法修改<ul>
<li>进行修改：删除局部内容或附加特定内容</li>
</ul>
</li>
<li>抗否认性<br>保证系统的可用性，使得发布者无法否认所发布的信息内容<ul>
<li>阻断传播：阻断信息传输系统，使得被传播的内容不能送达目的地</li>
</ul>
</li>
</ul>
<p><img src="/2023/05/15/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/2.png" alt="网络与信息安全涵盖范围"></p>
<p>左半边(真实性与完整性)具有相同性质，可以归并为真实性，完整性是真实性的子集<br><br>主要防范技术是校验与认证技术</p>
<p>右上角（机密性，可控性）都反映出机密性，其中可控性是机密性的子集<br>主要防范技术是密码技术</p>
<p>右下角（可用性，抗否认性）都反映出可用性的性质，抗否认性可以看作可用性的子集<br>主要防护措施是确保信息与信息系统处于一个可信的环境之下</p>
<p><img src="/2023/05/15/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/3.png" alt="金三角"></p>
<p><img src="/2023/05/15/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/4.png" alt="网络与信息安全框架"></p>
<h3 id="什么是信息安全技术❗"><a href="#什么是信息安全技术❗" class="headerlink" title="什么是信息安全技术❗"></a><strong>什么是信息安全技术</strong>❗</h3><p>信息安全技术是指在信息系统的<strong>物理层、运行层</strong>，以及对信息自身的保护（<strong>数据层</strong>）及攻击（<strong>内容层</strong>）的层面上，所反映出的对信息自身与信息系统在<strong>可用性、机密性与真实性</strong>方面的保护与攻击的技术。</p>
<h3 id="未来新技术"><a href="#未来新技术" class="headerlink" title="未来新技术"></a>未来新技术</h3><p>从总体角度来看，安全技术不会有大变化</p>
<ul>
<li>安全策略（Policy）<ul>
<li>风险分析、安全评估</li>
<li>漏洞扫描技术</li>
<li>网络拓扑结构的发现，尤其是Peer to Peer 网络拓扑结构的发现</li>
<li>态势预测与分析</li>
</ul>
</li>
<li>系统防护（Protection）<ul>
<li>病毒防护，侧重于网络制导、移动终端防护</li>
<li>隔离技术</li>
<li>拒绝服务攻击的防护</li>
<li>访问控制技术</li>
</ul>
</li>
<li>入侵检测（Detection）<ul>
<li>基于IPv6的入侵检测系统</li>
<li>向操作系统、应用系统中进行封装</li>
<li>分布式入侵检测</li>
<li>特洛伊木马检测技术</li>
<li>预警技术</li>
</ul>
</li>
<li>应急响应（Response）<ul>
<li>快速判定、事件隔离、证据保全</li>
<li>企业网内部的应急处理</li>
<li>蜜罐技术</li>
<li>僚机技术</li>
</ul>
</li>
<li>灾难恢复（Restore）<ul>
<li>基于structure-free的备份技术</li>
<li>容侵（intrusion-tolerant）技术</li>
<li>生存（容忍）技术</li>
</ul>
</li>
</ul>
<p><img src="/2023/05/15/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/5.png" alt="PPDRR"><br>记一下这个图叫PPDRR，20年考过这个图的大体结构和各小点具体项。</p>
<h1 id="1-3-大型网络应用剖析"><a href="#1-3-大型网络应用剖析" class="headerlink" title="1-3 大型网络应用剖析"></a>1-3 大型网络应用剖析</h1><h2 id="百度搜索引擎分析"><a href="#百度搜索引擎分析" class="headerlink" title="百度搜索引擎分析"></a>百度搜索引擎分析</h2><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ol>
<li>抓取建库<ul>
<li>抓取友好性<br> 要求抓取系统尽可能的高效利用带宽，在有限的硬件和带宽资源下尽可能多的抓取到有价值资源<br> 进行一定的抓取压力控制，达到既不影响网站的正常用户访问又能尽量多的抓取到有价值资源的目的<br> 对同一个站点的抓取速度控制一般分为两类：其一，一段时间内的抓取频率；其二，一段时间内的抓取流量。同一站点不同的时间抓取速度也会不同</li>
<li>常用抓取返回码示意<ul>
<li>404 网页失效</li>
<li>503 网页临时不可访问</li>
</ul>
</li>
<li>多种url重定向识别<ul>
<li>301 网页永久转移另一个地址</li>
<li>302 暂时跳转另一个网址</li>
<li>304 原来缓冲的文档还可以使用</li>
<li>305 文档应通过Location头指明的代理服务器获取</li>
<li>307 只能跟随GET的重定向</li>
<li>meta refresh重定向 使用content属性表示刷新或跳转的开始时间与跳转的网址</li>
<li>js重定向 replace直接将url替换 href为点击跳转</li>
</ul>
</li>
<li>抓取优先级调配<br>  互联网资源规模的巨大以及迅速的变化，对于搜索引擎来说全部抓取到并合理的更新保持一致性几乎是不可能的事情</li>
<li>重复URL过滤<br>  快速查找并对比</li>
<li>暗网数据获取<br>  通过开放平台采用数据提交的方式来解决</li>
<li>抓取反作弊</li>
<li>抓取频次原则及调整方法<br>  根据什么确定对一个网站的抓取频次<ul>
<li>网站更新频率</li>
<li>网站更新质量</li>
<li>联通度</li>
<li>站点评价</li>
</ul>
</li>
</ul>
</li>
<li>检索排序<br> emm，信息内容安全讲得更好</li>
<li>外部投票<br> 超链已经逐渐失去作为投票的重要意义，无论是谷歌还是百度，对超链数据的依赖程度都越来越低</li>
<li>结果展示<ul>
<li>结构化展现</li>
<li>摘要式展现</li>
</ul>
</li>
</ol>
<h2 id="大型网络应用技术发展历程"><a href="#大型网络应用技术发展历程" class="headerlink" title="大型网络应用技术发展历程"></a>大型网络应用技术发展历程</h2><ol>
<li>最开始的架构<br> 服务器+文件+数据库</li>
<li>应用、数据、文件分离</li>
<li>利用缓存改善网站性能</li>
<li>使用集群改善应用服务器性能——负载均衡</li>
<li>数据库读写分离和分库分表</li>
<li>使用CDN和反向代理提高网站性</li>
<li>使用分布式文件系统</li>
<li>使用NoSql和搜索引擎</li>
<li>将应用服务器进行业务拆分</li>
<li>搭建分布式服务</li>
</ol>
<p><img src="/2023/05/15/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/44.png"></p>
<h2 id="大型网络应用系统设计要点"><a href="#大型网络应用系统设计要点" class="headerlink" title="大型网络应用系统设计要点"></a>大型网络应用系统设计要点</h2><p>数据如何传输？传输的负载如何来衡量？<br>数据区域获取？区域分析？区域存储？整体整合？<br>数据分析加速<br>区域内部的存储空间分配方案？<br>计算与存储所用资源间的关系？<br>地址空间管理？Ip地址？平面地址？虚地址？<br>网络连接与管理？</p>
<p>虽然这道题没有直接这样问，但是可以照应着看一下<br><img src="/2023/05/15/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/45.png"></p>
<h2 id="分布式系统的网络问题"><a href="#分布式系统的网络问题" class="headerlink" title="分布式系统的网络问题"></a>分布式系统的网络问题</h2><p>性能：等待时间和点到点间的传输率</p>
<p>等待时间：<br>执行发送之后到数据到目标地的时间<br>可以用传输一个空消息的时间度量<br>软件开销＋路由延迟＋源于争夺传输信道的依赖负载的统计因素<br>分布式系统在进程之间传送的消息很多很小，因此等待时间在决定性能上与数据传输率有相同或更重要的意义</p>
<p>数据传输率：<br>数据在网络上两台计算机间的传输速度</p>
<p>消息传输时间＝等待时间＋length&#x2F;数据传输率</p>
<p>网络传输率：由网络的物理特性决定总量</p>
<p>系统总带宽：吞吐量的度量，在给定的时间内网络可以传输的数据总量</p>
<p>可扩展性：</p>
<ul>
<li>规模增长，结构变化</li>
<li>协议改变，寻址和路由机制的变化</li>
<li>移动性</li>
</ul>
<p>可靠性：</p>
<ul>
<li>大多数物理介质</li>
<li>错误，软件故障，缓冲区溢出</li>
<li>校验和纠错，重传</li>
</ul>
<p>安全性</p>
<ul>
<li>防火墙 VPN</li>
<li>端到端：认证，私密性，安全性</li>
</ul>
<h2 id="分布式系统通信协议"><a href="#分布式系统通信协议" class="headerlink" title="分布式系统通信协议"></a>分布式系统通信协议</h2><p>双方实体完成通信或服务所必须遵循的规则和约定，需要规定交流什么、怎样交流及何时交流</p>
<p>三要素：<br>“如何讲”，数据的格式、编码和信号等级<br>“讲什么”，数据内容、含义以及控制信息<br>定时规则（时序）：明确通信的顺序、速率匹配和排序。</p>
<p><img src="/2023/05/15/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/45.png"></p>
<h1 id="1-4-互联网发展热点剖析"><a href="#1-4-互联网发展热点剖析" class="headerlink" title="1-4 互联网发展热点剖析"></a>1-4 互联网发展热点剖析</h1><p>新ppt里没有可以不看</p>
<h2 id="互联网接下来的七个爆发点"><a href="#互联网接下来的七个爆发点" class="headerlink" title="互联网接下来的七个爆发点"></a>互联网接下来的七个爆发点</h2><p>20年最后一个大题可以写这个，但并不重点，因为可以写别的</p>
<ol>
<li>连接一切<br>人与设备，设备与设备，人与服务之间都有联系</li>
<li>互联网+创新涌现<br>传统行业+互联网，各行各业都产生变化，冲击很大</li>
<li>开放的协作</li>
<li>消费者参与决策</li>
<li>数据成为资源</li>
<li>顺应潮流的勇气</li>
<li>链接一切的风险</li>
</ol>
<h2 id="2018年中国互联网产业发展6个新趋势"><a href="#2018年中国互联网产业发展6个新趋势" class="headerlink" title="2018年中国互联网产业发展6个新趋势"></a><em>2018年中国互联网产业发展6个新趋势</em></h2><p>暂时没看出来会怎么考</p>
<ol>
<li>新技术<ol>
<li>下一代网络建设带动5G产业崛起</li>
<li>工业互联网促进制造业集成创新</li>
<li>大数据、人工智能将加速推进产业深度融合</li>
<li>技术创新推动金融信用体系趋于完善</li>
</ol>
</li>
<li>新动能<ol>
<li>产业互联网推动新旧动能加速转换</li>
<li>“互联网+先进制造业”成为振兴实体经济的重要途径</li>
<li>制造业与互联网融合的行业解决方案将继续突破</li>
<li>制造业与互联网融合的行业解决方案将继续突破智能制造的网络安全保障将成为关键一环</li>
<li>农业全产业链信息化升级将加速</li>
</ol>
</li>
<li>新场景<ol>
<li>数据与服务开辟消费新场景</li>
<li>共享服务更加智能化和全球化</li>
<li>智能化赋能更多平台场景</li>
</ol>
</li>
<li>新体验<ol>
<li>智能交互催生消费新体验</li>
<li>车联网、智能家电促进“住行”新体验</li>
<li>AR有望重新定义移动交互体验</li>
</ol>
</li>
<li>新挑战<ol>
<li>勒索病毒类攻击或将成为常态</li>
<li>个人信息保护将面临严峻挑战</li>
<li>关键信息基础设施的安全风险将不断攀升</li>
<li>网络空间安全防护能力将大幅加强</li>
<li>企业拓展国际化市场将面临激烈竞争</li>
</ol>
</li>
<li>新生态<ol>
<li>物联网和工业互联网安全生态建设将日益完善</li>
<li>平台经济创新与协同治理的需求将更加迫切</li>
<li>数据权属关系受到广泛关注</li>
<li>网络综合治理体系将加快完善</li>
<li>全球互联网治理体系将深度变革</li>
</ol>
</li>
</ol>
<h2 id="2020年中国互联网十大趋势预测"><a href="#2020年中国互联网十大趋势预测" class="headerlink" title="2020年中国互联网十大趋势预测"></a>2020年中国互联网十大趋势预测</h2><p>为啥是2020？</p>
<ol>
<li>一超多强局面将更加清晰</li>
<li>互联网公司做起硬件不手软<br>从软件到硬件，从做应用到做终端</li>
<li>视频社交的新创业风口到来</li>
<li>外卖行业遭受彻底整顿</li>
<li>金融科技公司迎来上市大潮</li>
<li>开放一家世界互联网巨头到中国运营</li>
<li>运营商的内容和应用重新崛起</li>
<li>旅游出行等领域面临一场大战</li>
<li>游戏市场变得更加均衡</li>
<li>越来越多的内容生产来自机器人</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本质：技术，设施，创新，数据的发展<br>产生的现象：安全意识提升，市场环境变化，引领市场需求<br>产生：环境，应用，数据变化的事件</p>
<p>环境由：网络，主机，基础服务组成<br>应用由：软件，需求，数据组成<br>两者相互作用产生数据变化发展</p>
<p>数据关键技术：汇聚，存储，分析，融合，共享</p>
<h1 id="1-5-负载均衡策略与算法剖析"><a href="#1-5-负载均衡策略与算法剖析" class="headerlink" title="1-5 负载均衡策略与算法剖析"></a>1-5 负载均衡策略与算法剖析</h1><h2 id="为什么要负载均衡"><a href="#为什么要负载均衡" class="headerlink" title="为什么要负载均衡"></a>为什么要负载均衡</h2><h3 id="关键点：怎样保持业务的连续性"><a href="#关键点：怎样保持业务的连续性" class="headerlink" title="关键点：怎样保持业务的连续性"></a>关键点：怎样保持业务的连续性</h3><h3 id="网络空间典型特点-1"><a href="#网络空间典型特点-1" class="headerlink" title="网络空间典型特点"></a>网络空间典型特点</h3><ul>
<li>内容复杂性<br>互联网信息广泛种类繁多</li>
<li>结构复杂性<br>目前互联网节奏十分复杂</li>
<li>服务复杂性<br>互联网存在关系复杂的服务链条</li>
</ul>
<p>三者存在互相继承关系</p>
<h3 id="需要原因分析"><a href="#需要原因分析" class="headerlink" title="需要原因分析"></a>需要原因分析</h3><p>应用背景：</p>
<ul>
<li>访问流量快速增长</li>
<li>业务量不点提高</li>
</ul>
<p>用户需求：</p>
<ul>
<li>希望不间断可用性及响应速度快</li>
</ul>
<p>存在问题的节点：</p>
<ul>
<li>服务器端</li>
<li>传输链路</li>
</ul>
<h3 id="本地负载均衡"><a href="#本地负载均衡" class="headerlink" title="本地负载均衡"></a>本地负载均衡</h3><p>有效解决数据流量过大、网络负荷过重的问题，不需购置性能卓越的服务器，充分利用现有设备</p>
<p>特点：</p>
<ul>
<li><p>不用买服务器</p>
</li>
<li><p>把数据流量合理地分配给服务器群内的服务器共同负担</p>
</li>
<li><p>扩充升级方便，不需改变现有网络结构</p>
</li>
<li><p>流量导向<br>Cyclic，Least Users，Least Traffic，SNMP，Hashing，Response Time</p>
</li>
<li><p>检测链接<br>Ping，TCP or UDP Port，HTTP Page，Page Content，Radius，RTSP</p>
</li>
<li><p>页面检测</p>
</li>
<li><p>健康检查</p>
</li>
</ul>
<h3 id="全局负载均衡"><a href="#全局负载均衡" class="headerlink" title="全局负载均衡"></a>全局负载均衡</h3><p>在一个多区域拥有自己服务器的站点，为了使全球用户只以一个IP地址或域名就能访问到离自己最近的服务器</p>
<p>特点：</p>
<ul>
<li>地理位置无关</li>
<li>避免单点失效出现整体问题</li>
<li>解决网络拥塞问题</li>
</ul>
<p>部署方式：</p>
<ul>
<li>路由方式<br>灵活<br>所有流量经过负载均衡，对网络改动小</li>
<li>桥接方式<br>不改变当前网络架构<br>负载均衡WAN和LAN链接上行设备和下行服务器，使其存在同一逻辑网络中<br>容错性差</li>
<li>服务直接返回<br>适合吞吐量大网络应用<br>客户端接WAN口，WAN口直接给服务器，服务器直接给客户端<br>返回流量不过均衡，使用流量大的网络应用</li>
</ul>
<h2 id="负载均衡主要策略"><a href="#负载均衡主要策略" class="headerlink" title="负载均衡主要策略"></a>负载均衡主要策略</h2><h3 id="基于DNS的负载均衡"><a href="#基于DNS的负载均衡" class="headerlink" title="基于DNS的负载均衡"></a>基于DNS的负载均衡</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>一个域名绑定多个IP，用DNS的转发（不知道为啥ppt里写的是随机域名，不过DNS基本原理就是转发重定向）来实现负载均衡</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>实现简单、实施容易、成本低、适用于大多数TCP应用</p>
<p><del>这里的成本低指的不是DNS服务器便宜，指的是你办TCP服务就得弄个DNS，既然你都弄了DNS了那就再配置一下就完了</del></p>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>一个服务器出现故障就需要等恢复</p>
<h4 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h4><p>DNS无法得知服务器间的差异，不能为性能较好的服务器分配更多请求（所以原理用的是随机域名转发，<del>这就是理解</del>）</p>
<h3 id="基于反向代理的负载均衡"><a href="#基于反向代理的负载均衡" class="headerlink" title="基于反向代理的负载均衡"></a>基于反向代理的负载均衡</h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>自带高速缓冲，减轻服务器负担</p>
<h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><p>并发链接请求非常多，代理负载巨大（一个代理需要开两个链接）</p>
<h4 id="缺陷-1"><a href="#缺陷-1" class="headerlink" title="缺陷"></a>缺陷</h4><p>必须要为每一种应用服务专门开发一个反向代理服务器</p>
<h3 id="基于特定服务器软件的负载均衡"><a href="#基于特定服务器软件的负载均衡" class="headerlink" title="基于特定服务器软件的负载均衡"></a>基于特定服务器软件的负载均衡</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>利用网络协议重定向实现<br>HTTP协议请求直接跳转别的url减轻服务器压力</p>
<h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><p>服务可定制</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>需要改服务器软件，成本高</p>
<h3 id="基于NAT的负载均衡❗"><a href="#基于NAT的负载均衡❗" class="headerlink" title="基于NAT的负载均衡❗"></a>基于NAT的负载均衡❗</h3><p>我记得上课这里讲的挺多的，那我就贴个图吧</p>
<p><img src="/2023/05/15/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/6.png"></p>
<h4 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h4><p>技术完善，算法灵活</p>
<h4 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h4><p>伸缩能力有限，若服务器节点数目过多，调度器本身会成为系统新瓶颈</p>
<h3 id="基于CDN的负载均衡"><a href="#基于CDN的负载均衡" class="headerlink" title="基于CDN的负载均衡"></a>基于CDN的负载均衡</h3><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p>网络架构中加一层定位，可以定位到用户最优CDN服务</p>
<h4 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h4><p>速度快</p>
<h2 id="负载均衡主要算法"><a href="#负载均衡主要算法" class="headerlink" title="负载均衡主要算法"></a>负载均衡主要算法</h2><h3 id="轮询算法"><a href="#轮询算法" class="headerlink" title="轮询算法"></a>轮询算法</h3><p>轮流分配用户请求</p>
<h4 id="优点-5"><a href="#优点-5" class="headerlink" title="优点"></a>优点</h4><p>简洁，无状态调度</p>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>不能很好的分配各个服务器的负载，容易导致服务器间负载不均衡</p>
<h4 id="适用"><a href="#适用" class="headerlink" title="适用"></a>适用</h4><p>适用于服务器组内配置相似且平均服务请求相对均衡</p>
<h3 id="Hash散列算法"><a href="#Hash散列算法" class="headerlink" title="Hash散列算法"></a>Hash散列算法</h3><p><img src="/2023/05/15/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/7.png"></p>
<h3 id="最少链接算法"><a href="#最少链接算法" class="headerlink" title="最少链接算法"></a>最少链接算法</h3><h4 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h4><p>将请求分配给当前链接最少的服务器</p>
<h4 id="优点-6"><a href="#优点-6" class="headerlink" title="优点"></a>优点</h4><p>简洁，大多数情况有效</p>
<h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><p>若各个服务器处理能力不同，该算法不理想</p>
<h4 id="适用-1"><a href="#适用-1" class="headerlink" title="适用"></a>适用</h4><p>使用需要长时间的处理请求</p>
<h3 id="最快链接算法"><a href="#最快链接算法" class="headerlink" title="最快链接算法"></a>最快链接算法</h3><h4 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h4><p>均衡器记录自身到每一个集群节点的响应，并将下一个链接请求分配给响应时间最短的节点</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>基于拓扑结构重定向的高级均衡策略<br><del>这句话我完全看不懂</del></p>
<h3 id="健康性检查算法"><a href="#健康性检查算法" class="headerlink" title="健康性检查算法"></a>健康性检查算法</h3><p>负载均衡产品中的关键指标</p>
<h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>检测服务器集群的健康程度，避免将流量转发给存在问题的服务器</p>
<h1 id="2-1-防火墙基础"><a href="#2-1-防火墙基础" class="headerlink" title="2-1 防火墙基础"></a>2-1 防火墙基础</h1><h2 id="下一代防火墙"><a href="#下一代防火墙" class="headerlink" title="下一代防火墙"></a><em>下一代防火墙</em></h2><ol>
<li>拥塞、允许<br>基于应用的黑白名单</li>
<li>多种条件的限制</li>
<li>安全扫描</li>
<li>威胁的主动防御<br>特征识别，用户行为分析等</li>
<li>流量整形</li>
</ol>
<h2 id="防火墙概论"><a href="#防火墙概论" class="headerlink" title="防火墙概论"></a>防火墙概论</h2><h3 id="防火墙定义"><a href="#防火墙定义" class="headerlink" title="防火墙定义"></a>防火墙定义</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>设置在不同网络或网络公共域之间的一系列部件的组合<br>是不同网络或网络安全域之间信息的唯一出入口<br>提供信息安全服务，实现网络与信息安全的基础设施</p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul>
<li>隔离风险区域与安全区域且不妨碍用户对风险区域的访问</li>
<li>监控通信</li>
<li>抵制对安全区域构成威胁的数据</li>
</ul>
<p>防止不希望的和未授权的信息进出被保护的网络</p>
<p>逻辑上，防火墙为</p>
<ul>
<li>分离器<br>分离两个不同网络</li>
<li>限制器<br>限制非法访问</li>
<li>分析器<br>数据分析</li>
</ul>
<h4 id="三大要素"><a href="#三大要素" class="headerlink" title="三大要素"></a>三大要素</h4><p>安全、管理、速度</p>
<h4 id="优点-7"><a href="#优点-7" class="headerlink" title="优点"></a><strong>优点</strong></h4><ol>
<li>防火墙是网络安全的屏障</li>
<li>控制对主机系统的访问</li>
<li>监控和审计网络访问</li>
<li>防止内部信息外泄</li>
<li>部署网络地址翻译机制（NAT）</li>
</ol>
<h4 id="弱点"><a href="#弱点" class="headerlink" title="弱点"></a><strong>弱点</strong></h4><ol>
<li>防火墙不能防范来自内部网络的攻击</li>
<li>防火墙不能防范不经由防火墙的攻击</li>
<li>防火墙不能防范感染病毒的软件或文件的传输</li>
<li>防火墙不能防范数据驱动式攻击</li>
<li>防火墙不能防范利用标准网络协议中的缺陷进行的攻击</li>
<li>防火墙不能防范利用服务器漏洞进行的攻击</li>
<li>防火墙不能防范新的网络安全问题</li>
<li>防火墙可能限制有用的网络服务</li>
</ol>
<h2 id="防火墙基本结构"><a href="#防火墙基本结构" class="headerlink" title="防火墙基本结构"></a><strong>防火墙基本结构</strong></h2><h3 id="屏蔽路由器"><a href="#屏蔽路由器" class="headerlink" title="屏蔽路由器"></a>屏蔽路由器</h3><p>屏蔽路由器作为内外连接的唯一通道，要求所有的报文都必须在此通过检查<br>路由器上可以安装基于IP层的报文过滤软件，实现报文过滤功能</p>
<p>危险区域包括路由器本身及路由器允许访问的主机</p>
<p>缺点是，路由器一旦被控制后很难发现，而且不能识别不同的用户</p>
<p><img src="/2023/05/15/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/8.png"></p>
<h3 id="双重宿主主机防火墙"><a href="#双重宿主主机防火墙" class="headerlink" title="双重宿主主机防火墙"></a>双重宿主主机防火墙</h3><p>用一台装有两块网卡的堡垒主机做防火墙<br>两块网卡分别与内部网和外部网相连，<strong>内部网和外部网之间的直接通信被完全阻止</strong></p>
<p>双宿主机防火墙优于屏蔽路由器的方面</p>
<ul>
<li>堡垒主机的系统软件可用于维护系统日志、硬件复制日志或远程日志</li>
<li>日志对于日后的检查很有用，但不能帮助网络管理者确认内网中哪些主机可能已被黑客人侵</li>
</ul>
<p>致命弱点<br>入侵者控制壁垒机会造成网上用户任意访问内网</p>
<p><img src="/2023/05/15/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/9.png"></p>
<h3 id="屏蔽主机防火墙"><a href="#屏蔽主机防火墙" class="headerlink" title="屏蔽主机防火墙"></a>屏蔽主机防火墙</h3><p>容易实现且安全，应用广泛<br>路由器链接外网，内网放一个壁垒主机，壁垒主机是外网唯一可以直接到达的机器。</p>
<p><img src="/2023/05/15/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/10.png"></p>
<h3 id="屏蔽子网防火墙"><a href="#屏蔽子网防火墙" class="headerlink" title="屏蔽子网防火墙"></a>屏蔽子网防火墙</h3><p>外网内网间建立一个被隔离的子网，两台路由器在外网和子网及子网和内网间隔开<br>危险区域：壁垒主机，子网主机，所有连接内网、外网和屏蔽子网的路由器</p>
<p>若尝试破坏屏蔽子网防火墙，则需要重新配置三个网的路由器</p>
<p><img src="/2023/05/15/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/11.png"></p>
<h3 id="其他防火墙结构"><a href="#其他防火墙结构" class="headerlink" title="其他防火墙结构"></a>其他防火墙结构</h3><ul>
<li>一个堡垒主机和一个非军事区</li>
<li>两个堡垒主机和两个非军事区</li>
<li>两个堡垒主机和一个非军事区</li>
</ul>
<h2 id="防火墙的模型与分类"><a href="#防火墙的模型与分类" class="headerlink" title="防火墙的模型与分类"></a>防火墙的模型与分类</h2><h3 id="防火墙模型"><a href="#防火墙模型" class="headerlink" title="防火墙模型"></a>防火墙模型</h3><p>可以在OSI&#x2F;RM模型总的五层设置</p>
<p><img src="/2023/05/15/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/12.png"></p>
<h3 id="防火墙分类"><a href="#防火墙分类" class="headerlink" title="防火墙分类"></a>防火墙分类</h3><h4 id="包过滤防火墙"><a href="#包过滤防火墙" class="headerlink" title="包过滤防火墙"></a>包过滤防火墙</h4><p>检查每一个通过的网络包</p>
<h4 id="状态-动态检测防火墙"><a href="#状态-动态检测防火墙" class="headerlink" title="状态&#x2F;动态检测防火墙"></a>状态&#x2F;动态检测防火墙</h4><p>为了跟踪包的状态，防火墙还记录有用的信息以帮助识别包，例如已有的网络连接、数据的传出请求等</p>
<h4 id="应用程序代理防火墙"><a href="#应用程序代理防火墙" class="headerlink" title="应用程序代理防火墙"></a>应用程序代理防火墙</h4><p>接受来自内部网络特定用户应用程序的通信（基于代理），然后建立与公共网络服务器单独的连接</p>
<h4 id="个人防火墙"><a href="#个人防火墙" class="headerlink" title="个人防火墙"></a>个人防火墙</h4><p>通常是应用程序级的，个人防火墙安装在计算机网络接口的较低级别上，使其可以监视传入传出网卡的所有网络通信</p>
<h2 id="攻击方式与防火墙防御"><a href="#攻击方式与防火墙防御" class="headerlink" title="攻击方式与防火墙防御"></a>攻击方式与防火墙防御</h2><h3 id="认识黑客"><a href="#认识黑客" class="headerlink" title="认识黑客"></a>认识黑客</h3><p>踩点-&gt;扫描-&gt;攻击</p>
<p>踩点收集信息，如DNS，SNMP等</p>
<p>扫描进行漏洞侦测，SATAN</p>
<p>攻击这没啥说的</p>
<h3 id="网络攻击的基本手段"><a href="#网络攻击的基本手段" class="headerlink" title="网络攻击的基本手段"></a>网络攻击的基本手段</h3><h4 id="非法权限类"><a href="#非法权限类" class="headerlink" title="非法权限类"></a>非法权限类</h4><ul>
<li>特洛伊木马<br>合法程序包含恶意行为<ul>
<li>陷阱入口类</li>
<li>信息窃取类</li>
<li>功能欺骗类</li>
<li>逻辑炸弹类</li>
</ul>
</li>
<li>系统欺骗（提权）<ul>
<li>外部欺骗类</li>
<li>本机欺骗类</li>
</ul>
</li>
<li>拒绝服务<br>利用计算机协议处理的漏洞来攻击网上计算机使之死机为目的的网络程序</li>
<li>入侵<br>扫描器是常规入侵工具，法律上禁止使用</li>
<li>窃取<br>搭线窃听</li>
</ul>
<h4 id="传染类"><a href="#传染类" class="headerlink" title="传染类"></a>传染类</h4><ul>
<li>源码类<br>宏命令，通过应用程序留下的接口达到目的</li>
<li>目标码类</li>
</ul>
<h4 id="侵占资源类"><a href="#侵占资源类" class="headerlink" title="侵占资源类"></a>侵占资源类</h4><ul>
<li>一对一式攻击<br>大量的链接请求阻碍信道</li>
<li>兑变式攻击<br>让对方接收并运行</li>
</ul>
<h2 id="防火墙发展"><a href="#防火墙发展" class="headerlink" title="防火墙发展"></a><em>防火墙发展</em></h2><ul>
<li><p>第一代防火墙<br>只有分组过滤功能</p>
</li>
<li><p>第二代防火墙<br>代理服务器，可提供应用服务级的控制，起到外部网络向被保护的内部网申请服务时中间转接作用<br>可以实现代理转发</p>
</li>
<li><p>第三代防火墙<br>建立在通用操作系统上的商用防火墙产品</p>
</li>
<li><p>第四代防火墙<br>安全操作系统+动态网络安全技术</p>
</li>
</ul>
<h1 id="2-2-防火墙技术"><a href="#2-2-防火墙技术" class="headerlink" title="2-2 防火墙技术"></a>2-2 防火墙技术</h1><h2 id="包过滤技术"><a href="#包过滤技术" class="headerlink" title="包过滤技术"></a>包过滤技术</h2><h3 id="包过滤原理"><a href="#包过滤原理" class="headerlink" title="包过滤原理"></a>包过滤原理</h3><p>通过检测网络数据包的信息头决定是否将数据包发往目的地址<br>大多数过滤型防火墙只针对性分析最有用的数据域</p>
<p>核心：包检查模块<br>包过滤检查模块深入到系统的传输层（TCP）和网络层（IP）之间，在操作系统或路由器的TCP层对IP包处理以前对IP包进行处理</p>
<p>防火墙检查模块验证每个包是否符合过滤规则，不管是否符合过滤规则，防火墙一般都要记录数据包情况</p>
<ul>
<li>不符合规则的包要进行报警或通知管理员</li>
<li>被过滤或丢弃的数据包看自己配置的策略</li>
</ul>
<p>包过滤规则（访问控制列表）<br>只有满足访问控制列表的数据才会被转发<br>为了保证所有流入和流出的网络的数据包都被监控和检测，包过滤器必须被放在网络单点访问的位置</p>
<h4 id="配置访问控制列表"><a href="#配置访问控制列表" class="headerlink" title="配置访问控制列表"></a>配置访问控制列表</h4><p>包过滤防火墙由</p>
<ul>
<li>一个脏端口</li>
<li>一个净端口</li>
<li>一组访问控制规则</li>
</ul>
<p>两种访问控制列表方式</p>
<ul>
<li>限制策略<br>接受受信任的IP包（白名单）</li>
<li>宽松策略<br>拒绝不受信任的IP包（黑名单）<br><strong>列表顺序很重要，可以看2-3的具体配置方法</strong></li>
</ul>
<h4 id="动态访问控制列表"><a href="#动态访问控制列表" class="headerlink" title="动态访问控制列表"></a>动态访问控制列表</h4><p>实现指定用户的IP数据流临时通过防火墙，进行会话连接，从而实现对数据包的动态过滤，在会话结束后，将接口配置恢复到原来的状态<br>一般结合身份认证机制实现<br>如果用户通过身份验证，则激活动态访问控制列表，在防火墙开放一个数据通道，此时，用户可以暂时通过防火墙访问内部网络目标主机</p>
<h4 id="状态包检查（反射访问控制列表）"><a href="#状态包检查（反射访问控制列表）" class="headerlink" title="状态包检查（反射访问控制列表）"></a>状态包检查（反射访问控制列表）</h4><p>动态建立访问控制列表条目，包含必要的包过滤信息，还包含了网络会话的状态信息，这些临时条目在新会话开始（如内部主机向外部主机发起连接请求）时创建，并在会话结束时被删除</p>
<p>防火墙检查每一个通过的数据包，看这些数据包是否属于一个已经建立的通过防火墙的会话的延续，或者能否通过预设定包过滤规则集的检查</p>
<p>会话结束的判定和临时条目的删除</p>
<ul>
<li>两组FIN</li>
<li>RST</li>
<li>超时</li>
<li>UDP只有超时</li>
</ul>
<h3 id="包过滤技术优缺点"><a href="#包过滤技术优缺点" class="headerlink" title="包过滤技术优缺点"></a>包过滤技术优缺点</h3><h4 id="优点-8"><a href="#优点-8" class="headerlink" title="优点"></a>优点</h4><ul>
<li>包过滤防火墙是两个网络之间访问的惟一途径，防火墙可对每个传入和传出网络的数据包实行低水平控制</li>
<li>每个IP包的字段都被检查，如源地址、目的地址、协议、端口等。防火墙将基于这些信息应用过滤规则</li>
<li>防火墙可以识别、丢弃带欺骗性源IP地址的包</li>
<li>包过滤通常被包含在路由器中，不需要额外的系统来处理</li>
</ul>
<h4 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>访问控制列表配置和维护困难</li>
<li>包过滤防火墙难以详细了解主机之间的会话关系，容易受到欺骗</li>
<li>基于网络层和传输层实现的包过滤防火墙难以实现对应用层服务的过滤</li>
</ul>
<h2 id="网络地址翻译技术"><a href="#网络地址翻译技术" class="headerlink" title="网络地址翻译技术"></a><strong>网络地址翻译技术</strong></h2><p>IANA规定了私有IP地址空间<br>NAT用来增加私有组织的可用地址空间和解决将现有的私有TCP&#x2F;IP网络连接到互联网上的IP地址编号问题</p>
<h3 id="NAT技术原理"><a href="#NAT技术原理" class="headerlink" title="NAT技术原理"></a>NAT技术原理</h3><p>NAT把内部IP转换为外部IP<br>通信通常由内部网络发起<br>NAT具有一些性质可以为防火墙提供支持</p>
<h3 id="NAT相关术语"><a href="#NAT相关术语" class="headerlink" title="NAT相关术语"></a>NAT相关术语</h3><ul>
<li>内部局部地址（Inside Local Address）<br>内部网络中标识主机，内部网络私有IP</li>
<li>内部全局地址（Inside Global Address）<br>在外部网络中使用，标识内部网络主机，是互联网中一个虚拟的主机<br>内部主机与外部主机通信地址，通常为公有地址</li>
<li>外部全局地址（Outside Global Address）<br>在外部网络中使用，是从全球统可寻址空间中分配的</li>
<li>外部局部地址（Outside Local Address）<br>外部网络表现在内部网络中的地址，从私有IP中分配的<br>能够被内部主机识别的外部主机的地址，对内部主机可见的地址</li>
</ul>
<h3 id="静态网络地址翻译技术"><a href="#静态网络地址翻译技术" class="headerlink" title="静态网络地址翻译技术"></a>静态网络地址翻译技术</h3><p>网络地址翻译技术完全依赖于人工指定内部局部地址和内部全局地址之间的映射关系来运行</p>
<p><img src="/2023/05/15/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/13.png"></p>
<p>如果NAT映射表中存在匹配项，则使用内部局部地址替换数据包的目的IP地址，并将数据包转发到内部网络主机。防火墙使用10.1.1.1替换202.168.2.2并进行转发；如果NAT映射表中不存在匹配项，则拒绝数据包。</p>
<h3 id="动态网络地址翻译技术"><a href="#动态网络地址翻译技术" class="headerlink" title="动态网络地址翻译技术"></a>动态网络地址翻译技术</h3><p>NAT映射表由防火墙动态建立，对网络管理员和用户透明</p>
<p><img src="/2023/05/15/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/14.png"></p>
<p>对于内部数据包若没有对应NAT表项则创建新表项<br>对于外部数据包若没有对应NAT表项则丢弃不进行转发</p>
<h3 id="网络地址翻译技术实现负载均衡"><a href="#网络地址翻译技术实现负载均衡" class="headerlink" title="网络地址翻译技术实现负载均衡"></a>网络地址翻译技术实现负载均衡</h3><p>这种地址转换是以连接为单位按循环方式(round-robin)进行，只有当建立一个由外部发起到内部的新连接时才执行</p>
<p>外部访问时给不同的内部局部地址对应主机进行响应</p>
<h3 id="网络地址翻译技术处理网络地址交迭"><a href="#网络地址翻译技术处理网络地址交迭" class="headerlink" title="网络地址翻译技术处理网络地址交迭"></a>网络地址翻译技术处理网络地址交迭</h3><p>NAT可用于解决内部网络地址与外部网络地址交迭的情况</p>
<h3 id="网络地址翻译技术优缺点"><a href="#网络地址翻译技术优缺点" class="headerlink" title="网络地址翻译技术优缺点"></a>网络地址翻译技术优缺点</h3><p>然而最新的PPT并没有优点，只有缺点</p>
<h4 id="问题-3"><a href="#问题-3" class="headerlink" title="问题"></a>问题</h4><ol>
<li>一些应用层协议的特点导致他们无法使用网络地址翻译技术<br>数据包的数据域部分很有源，目的IP地址的数据流不支持</li>
<li>静态和动态网络地址映射安全问题<br>静态NAT屏蔽了内部网络的拓扑结构，但并未提供额外的保护功能，动态NAT在内部主机主动建立链接之前完全安全，但建立连接后NAT没有任何保护</li>
<li>对内部主机的引诱和特洛伊木马攻击<br>内部用户主动连接黑客主机</li>
<li>状态表超时问题<br>动态NAT映射表超时或链接关闭会删除</li>
</ol>
<h2 id="网络代理技术"><a href="#网络代理技术" class="headerlink" title="网络代理技术"></a>网络代理技术</h2><p>具有访问因特网能力的主机才可以作为那些无权访问因特网的主机的代理，使其可以完成因特网访问工作</p>
<h3 id="应用层代理"><a href="#应用层代理" class="headerlink" title="应用层代理"></a>应用层代理</h3><h4 id="应用层代理简介"><a href="#应用层代理简介" class="headerlink" title="应用层代理简介"></a>应用层代理简介</h4><p>针对特定应用实现，外部网络主机通过应用层代理访问内部网络主机，内部网络主机只接受应用层代理提出的服务请求，拒绝外部网络节点的直接请求</p>
<p>外部网只能见到代理服务器，应用层代理会对用户身份进行验证，验证合法可以转发请求。且时刻监视用户，拒绝非法用户访问，拒绝用户非法操作。</p>
<h4 id="应用层代理的实现"><a href="#应用层代理的实现" class="headerlink" title="应用层代理的实现"></a>应用层代理的实现</h4><p>通过双宿主机或堡垒主机实现，且为防止威胁，禁止用户在代理主机上注册。<br>应用层代理一般只向单个或部分主机提供网络服务，具有访问能力的主机可作为那些没有访问权限的主机的代理而形成多层代理模式<br>代理服务器起到外部网络与内部网络进行通信时的中间转接、监控、限制和审计等作用</p>
<h4 id="代理服务程序"><a href="#代理服务程序" class="headerlink" title="代理服务程序"></a>代理服务程序</h4><p>要求有合适的代理服务器软件，需要针对不同服务的代理功能开发不同的代理服务程序</p>
<h4 id="应用层代理技术的优缺点分析"><a href="#应用层代理技术的优缺点分析" class="headerlink" title="应用层代理技术的优缺点分析"></a>应用层代理技术的优缺点分析</h4><h5 id="优点-9"><a href="#优点-9" class="headerlink" title="优点"></a>优点</h5><ol>
<li>有能力支持可靠的用户认证并提供详细的注册信息</li>
<li>用于应用层的过滤规则，相对于包过滤路由器来说更容易配置和测试</li>
<li>应用层代理工作在客户机和真实服务器之间可以完全控制网络会话，可提供详细的日志和安全审计功能</li>
<li>提供代理服务的防火墙可以被配置成惟一的可被外部看见的主机，这样可以隐藏内部网的IP地址</li>
<li>解决合法的IP地址不够的问题</li>
</ol>
<h5 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h5><ol>
<li>有限的连接性<br>解释应用层命令，这种代理服务器只能用于某一种服务</li>
<li>技术有限</li>
<li>造成明显性能下降</li>
<li>维护相对复杂</li>
<li>应用层代理要求用户改变自己的行为，或在访问代理服务器的每个系统上安装特殊的软件</li>
</ol>
<p>应用层代理对操作系统和应用层的漏洞是脆弱的</p>
<h3 id="电路级代理"><a href="#电路级代理" class="headerlink" title="电路级代理"></a>电路级代理</h3><h4 id="电路级代理概述"><a href="#电路级代理概述" class="headerlink" title="电路级代理概述"></a>电路级代理概述</h4><p>电路级代理（通常也称为电路级网关或回路级代理）也是一种代理，但只是建立起一个回路，对数据包只起转发的作用</p>
<p>工作于TCP层</p>
<h4 id="电路级网关的工作原理"><a href="#电路级网关的工作原理" class="headerlink" title="电路级网关的工作原理"></a>电路级网关的工作原理</h4><p>优点：<br>可以针对不同协议提供服务</p>
<p>电路级网关依赖于TCP连接，并不进行任何附加的包处理或过滤</p>
<h4 id="SOCKS代理技术"><a href="#SOCKS代理技术" class="headerlink" title="SOCKS代理技术"></a>SOCKS代理技术</h4><p>客户请求建立一个链接，将应用服务器地址、端口号和认证信息给SOCKS代理服务器，代理通过安全策略验证目标合法性和有效性并建立链接，这一步对用户完全透明。</p>
<p>SOCKS代理可以使那些运行在防火墙后面的主机充分地访问Internet而无须直接与外部主机建立连接</p>
<p>可以实现管理员明确地控制一个组织内部如何与Internet通信</p>
<p>由两部分组成：</p>
<ul>
<li>SOCKS服务端程序<br>同Internet和内部网络通信的程序</li>
<li>SOCKS客户端程序<br>使运行客户程序的主机同运行服务程序的主机通信，而不是直接与Internet通信</li>
</ul>
<h4 id="SOCKS代理的实现"><a href="#SOCKS代理的实现" class="headerlink" title="SOCKS代理的实现"></a><em>SOCKS代理的实现</em></h4><p>SOCKS客户程序替换了UNIX中的一些套接字函数<br>当一个经SOCKS修改的客户程序连接到Internet上时，SOCKS<br>库中的子程序就截获这个连接，并连接到运行SOCKS代理服务器的主机上，而不是的Internet<br>SOCKS代理服务进程将检查访问控制表，判断应该接受还是拒绝这个连接</p>
<h1 id="2-3-防火墙安全策略及其配置"><a href="#2-3-防火墙安全策略及其配置" class="headerlink" title="2-3 防火墙安全策略及其配置"></a>2-3 防火墙安全策略及其配置</h1><h2 id="防火墙如何开发安全策略"><a href="#防火墙如何开发安全策略" class="headerlink" title="防火墙如何开发安全策略"></a>防火墙如何开发安全策略</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>安全策略： 一个列出必须满足的特定需求或规则的文档</p>
<p>防火墙的设计依赖于安全策略，设计安全系统应先考虑安全策略后考虑防火墙</p>
<p>这里的审计是指专门的机构和人员对企事业组织的财政、财务收支等真实性、合法性、效益性进行审查<br><del>我觉得这个别看，容易误导</del></p>
<p>信息系统由于复杂度变高，自身策略的系统脆弱性隐患越发严重<br>对信息系统的错误操作，滥用，不正当使用等</p>
<p>任何技术都是双刃剑，应引入一种新的管理机制来对信息系统的安全性、投资效果、实施进程和实施效果进行评估指导和改进——IT审计</p>
<p>为什么进行网络审计</p>
<ul>
<li>了解网络中发生的事件</li>
<li>事后追踪</li>
<li>监控网络</li>
<li>改进安全策略</li>
</ul>
<p>网络审计技术内容<br>网络连接审计，协议审计，端口审计，拨号连接审计，个人账户审计，文件访问审计，数据审计，流量统计审计， 数据库审计，WEB服务器审计，安全事件再现审计，键盘审计，屏幕审计，系统统计分析审计</p>
<h3 id="审计产品部署"><a href="#审计产品部署" class="headerlink" title="审计产品部署"></a>审计产品部署</h3><p>优势</p>
<ol>
<li>网络应用识别全</li>
<li>审计粒度记得细</li>
<li>敏感文件检测准</li>
<li>加密流量看的透</li>
</ol>
<p>旁路部署<br>最常见，不影响原网络结构<br>解决的问题</p>
<ul>
<li>安全稳定可靠运行</li>
<li>使用中小网络环境，不改变网络结构</li>
<li>审计内容精细，时候追根溯源</li>
</ul>
<p>级联部署<br>每台审计系统都是一台独立运行的设备，上级设备可下发策略，也可查看下级设备的结果<br>解决的问题</p>
<ul>
<li>保证总部和各分支机构策略的统一性</li>
<li>解决客户分级控制和审计的需求</li>
<li>威胁分析系统联动响应</li>
</ul>
<p>分布式部署<br>管理中心进行策略下发<br>解决的问题<br>适应用户网络结构<br>联动预警响应机制<br>解决客户分级控制和审计需求</p>
<h3 id="确定有效的安全策略所需要达到的目标"><a href="#确定有效的安全策略所需要达到的目标" class="headerlink" title="确定有效的安全策略所需要达到的目标"></a>确定有效的安全策略所需要达到的目标</h3><ol>
<li>清楚描述一个安全的网络计算环境</li>
<li>灵活适应公司结构的任何改动</li>
<li>保证在整个公司中一致的交流和执行</li>
<li>要明确雇员对网络的使用权限</li>
<li>要对雇员和管理人员关于隐私和安全的合理和不合理的表现进行明确定义</li>
</ol>
<h3 id="构建安全策略的7步"><a href="#构建安全策略的7步" class="headerlink" title="构建安全策略的7步"></a>构建安全策略的7步</h3><ol>
<li>组建一个团队</li>
<li>执行公司的整体安全策略</li>
<li>确定被保护的资产</li>
<li>决定安全策略审核的内容</li>
<li>确定安全风险</li>
<li>定义可接受的使用范围</li>
<li>提供远程访问</li>
</ol>
<h3 id="考虑防火墙的不足"><a href="#考虑防火墙的不足" class="headerlink" title="考虑防火墙的不足"></a>考虑防火墙的不足</h3><ol>
<li>超出防火墙所能处理的过多的网络访问量，及其防火墙崩溃的蛮力攻击</li>
<li>在网络中将一个加密的带有病毒的电子邮件消息发送给某人，加密的消息将会通过防火墙，这样病毒就会传染给系统</li>
<li>若雇员将远程访问号码泄漏，则未经授权的用户就能够访问公司网络</li>
<li>雇员将密码泄露</li>
<li>防火墙属于静态防护</li>
<li>防火墙难于防内</li>
<li>防火墙难于管理和配置，易造成安全漏洞</li>
<li>防火墙的安全控制主要是基于IP地址的，难于为用户在防火墙内提供一致的安全策略</li>
<li>防火墙实现了粗粒度的访问控制</li>
<li>任何一个系统（尤其是底层系统和应用系统）中可能存在安全漏洞，造成绕过防火墙的攻击</li>
</ol>
<p>其实这里写的跟其他几科对防火墙的描述是一样的，稍微联系一下就能记住，其他科也能用上</p>
<h3 id="违反安全规则响应方式"><a href="#违反安全规则响应方式" class="headerlink" title="违反安全规则响应方式"></a>违反安全规则响应方式</h3><ol>
<li>记录数据</li>
<li>响应处理联系人</li>
<li>响应策略</li>
</ol>
<h2 id="Cisco-IOS-防火墙特征集"><a href="#Cisco-IOS-防火墙特征集" class="headerlink" title="Cisco IOS 防火墙特征集"></a>Cisco IOS 防火墙特征集</h2><p>接口类型、端口密度、性能以及形态元素（即大小、形式和容量）方面巨大的灵活性</p>
<p>基于上下文的访问控制</p>
<h2 id="配置Cisco-IOS防火墙包过滤功能"><a href="#配置Cisco-IOS防火墙包过滤功能" class="headerlink" title="配置Cisco IOS防火墙包过滤功能"></a>配置Cisco IOS防火墙包过滤功能</h2><p>两类访问控制列表</p>
<ul>
<li>标准访问控制列表</li>
<li>拓展访问控制列表</li>
</ul>
<p>功能和特点分类</p>
<ul>
<li>静态访问控制列表</li>
<li>动态访问控制列表</li>
<li>反射访问控制列表</li>
</ul>
<p>配置步骤</p>
<ol>
<li>创建访问控制列表</li>
<li>访问控制列表绑定某个端口</li>
</ol>
<p>需要给一个唯一的编号<br><img src="/2023/05/15/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/15.png"></p>
<p>创建访问控制列表<br>Router(config)#access-list access-list-number [permit|deny] 测试条件</p>
<p>删除访问控制列表<br>Router(config)#no access-list access-list-number</p>
<p>注意：<br>可以向同一个访问控制列表写入多条语句<br>删除访问控制列表时，在标准和扩展访问控制列表中只能删除一整个表</p>
<p>绑定到网络接口命令<br>Router(config-if)# protocol access-group access-list-number [in|out]</p>
<p>反转掩码<br>子网掩码反过来</p>
<h3 id="配置标准访问控制列表"><a href="#配置标准访问控制列表" class="headerlink" title="配置标准访问控制列表"></a>配置标准访问控制列表</h3><p>创建标准访问控制列表<br>Router(config)#access-list [access-list-number] [permit|deny]source-ip wildmask</p>
<p>访问控制列表绑定端口<br>Router(config-if)#ip access-group [access-list-number] [in|out]</p>
<p>查看访问控制列表<br>Router#show access-list [access-list-number]</p>
<p>查看某个接口是否绑定了访问控制列表<br>Router#show ip interface [interface]</p>
<p><img src="/2023/05/15/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/16.png"><br>Router(config)#access-list 1 peimit 172.16.0.0 0.0.255.255<br>Router(config)#interface E0<br>Router(config-if)#ip access-group 1 out<br>Router(config)#interface E1<br>Router(config-if)#ip access-group 1 out</p>
<p><img src="/2023/05/15/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/17.png"><br>Router(config)#access-list 1 deny 172.16.4.13 0.0.0.0<br>Router(config)#access-list 1 permit any<br>Router(config)#interface E0<br>Router(config-if)#ip access-group 1 out</p>
<p><img src="/2023/05/15/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/18.png"><br>Router(config)#access-list 1 deny 172.16.4.0 0.0.0.255<br>Router(config)#access-list 1 permit any<br>Router(config)#interface E0<br>Router(config-if)#ip access-group 1 out</p>
<h3 id="配置拓展访问控制列表"><a href="#配置拓展访问控制列表" class="headerlink" title="配置拓展访问控制列表"></a>配置拓展访问控制列表</h3><p>扩展访问控制列表对数据包的控制比标准访问控制列表粒度更细，因而运用更广<br>扩展访问控制列表可以检查源地址和目标地址、特定的协议、端口号，以及其他的参数</p>
<p>创建一个扩展访问控制列表<br>Router(config)#access-list access-list-number [permit | deny] protocol source source-mask [operator port] destination destination-mask [operator port]</p>
<p>绑定访问控制列表到某个网络接口上<br>Router(config-if)#ip access-group access-list-number [in | out]</p>
<p>显示访问控制列表包含的命令语句<br>Router#show access-list [access-list-number]</p>
<p>查看是否为某个接口绑定了访问控制列表<br>Router#show ip interface [interface]</p>
<p><img src="/2023/05/15/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/19.png"></p>
<p><img src="/2023/05/15/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/20.png"><br>Router(config)#access-list 101 permit TCP 172.16.1.1 0.0.0.0 192.168.1.0 0.0.0.255 ep 20<br>Router(config)#interface E2<br>Router(config-if)#ip access-group 101 out</p>
<p><img src="/2023/05/15/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/21.png"><br>Router(config)#access-list 101 deny TCP 172.16.0.0 0.0.255.255 any eq 23<br>Router(config)#access-list 101 permit IP any any<br>Router(config)#interface E1<br>Router(config-if)#ip access-group in</p>
<p><img src="/2023/05/15/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/22.png"><br>Router(config)#access-list 101 deny icmp 192.168.1.0 0.0.0.255 172.16.0.0 0.0.255.255<br>Router(config)#access-list 101 permit IP any any<br>Router(config)#interface E2<br>Router(config-if)#ip access-group 101 in</p>
<p>Ping程序使用的是ICMP协议，ICMP不像http，FTP应用层有传输层的端口号。 ICMP直接封装在IP包内。不需要指定端口号</p>
<h3 id="配置标识访问控制列表"><a href="#配置标识访问控制列表" class="headerlink" title="配置标识访问控制列表"></a><em>配置标识访问控制列表</em></h3><p>对于配置号码，若超过了99个标准列表或100个扩展列表则使用命名访问控制列表</p>
<p>优点</p>
<ul>
<li>可以用有含义的字符串直观标识一个访问控制列表</li>
<li>修改访问控制列表中的某一条语句时，可以在不删除整个访问控制列表的情况下修改它</li>
</ul>
<p>注意事项</p>
<ul>
<li>版本不兼容</li>
<li>命名访问控制列表可包含标准和扩展访问控制列表</li>
<li>名字不能重复</li>
</ul>
<p>命令<br>创建一个命名访问控制列表<br>Router(config)#ip access-list [standard |extended] name</p>
<p>向命名访问控制列表中写入命令语句<br>Router(config-[std|ext]-nacl)# [permit | deny]</p>
<p>删除命名访问控制列表中的某一条语句<br>Router(config-[std|ext]-nacl)#no [permit | deny]<br>注意：该访问控制列表仍然存在，这与用数字标识的访问控制列表不同</p>
<p>绑定命名访问控制列表<br>Router(config-if)#ip access-group name [in|out]</p>
<h3 id="配置动态访问控制列表"><a href="#配置动态访问控制列表" class="headerlink" title="配置动态访问控制列表"></a><em>配置动态访问控制列表</em></h3><p>可以实现访问控制列表的动态改变</p>
<p>命令<br>配置动态访问控制列表，作为临时访问控制列表条目的模板和占位符<br>access-list access-list-number [dynamic dynamic-name[timeout minutes]] {permit | deny} telnet source source-wildcard destination destination-wildcard [precedenceprecedence] [tos tos] [established] [log]</p>
<p>配置接口<br>interface type number</p>
<p>在接口配置模式下，将访问控制列表用于接口<br>ip access-group access-list-number [in | out]</p>
<p>在全局模式下，定义一个或多个虚拟终端（VTY）端口<br>line VTY line-number [ending- line-number]</p>
<p>配置用户身份验证<br>username name password secret<br>login trcacs<br>password password login local</p>
<p>启用创建临时访问列表条目功能<br>autocommand access-enable [host] [timeout minutes]</p>
<h3 id="访问控制列表配置要点❗"><a href="#访问控制列表配置要点❗" class="headerlink" title="访问控制列表配置要点❗"></a><strong>访问控制列表配置要点</strong>❗</h3><p>对于某个协议，可能有多个访问控制列表。通常，一个端口的一个协议，只能够指定一个访问控制列表<br>对于某些协议，一个端口可以指定两个访问控制列表：一个负责收到的数据，一个负责发出的数据。而某些协议，需要把这两个访问控制列表组合成一个负责进出该端口的数据</p>
<p>尽量将扩展访问控制列表放置在靠近被拒绝的数据源。标准访问控制列表不能指定目标地址，故需要把标准访问控制列表放置在尽量靠近目标的地方。</p>
<h1 id="3-1-入侵检测技术概述"><a href="#3-1-入侵检测技术概述" class="headerlink" title="3-1 入侵检测技术概述"></a>3-1 入侵检测技术概述</h1><p>基于主机的入侵检测技术：审计数据的获取、用于入侵检测的统计模型、入侵检测的专家系统等<br>基于网络的入侵检测技术：分层协议模型与TCP&#x2F;IP协议、网络数据包的截获等</p>
<p>IDS存在必然性</p>
<ul>
<li>网络攻击造成的破坏性和损失日益严重</li>
<li>网络安全威胁日益增长</li>
<li>单纯的防火墙无法防范复杂多变的攻击</li>
</ul>
<p><img src="/2023/05/15/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/23.png"></p>
<h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>这个愿意看看看吧，不总了，我直接赌不会出这里的题</p>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p>定义<br>CIA：机密性完整性可用性<br>安全策略用于将抽象的安全目标和概念映射为现实世界中的具体安全规则，通常定义为一组用于保护系统计算资源和信息资源的目标、过程和管理规则的集合</p>
<p>威胁来源：</p>
<ul>
<li>外部入侵者</li>
<li>内部入侵者</li>
<li>违法者</li>
</ul>
<p>入侵：表示系统内部发生的任何违反安全策略的事件<br>入侵是对信息系统的非授权访问以及（或者）未经许可在信息系统内进行的操作</p>
<h3 id="IDS基本结构"><a href="#IDS基本结构" class="headerlink" title="IDS基本结构"></a>IDS基本结构</h3><p><img src="/2023/05/15/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/24.png"></p>
<p>数据收集器（探测器）：主要负责收集数据<br>检测器（分析器&#x2F;检测引擎）：负责分析和检测入侵的任务，并发出报警信号<br>知识库：提供必要的数据信息支持<br>控制器：根据报警信号，人工或自动做出反应动作<br>用户接口组件</p>
<p>三个功能部件</p>
<ol>
<li>信息收集<br>收集内容包括系统、网络、数据及用户活动的状态和行为<br>在计算机网络系统中的若干不同关键点收集信息，尽可能扩大检测范围<br>入侵检测的效果很大程度上依赖于收集信息的可靠性和正确性，保证用来检测网络系统的软件的完整性，入侵检测系统软件本身应具有相当强的坚固性，防止被篡改而收集到错误的信息<br> <strong>来源</strong><ul>
<li>系统或网络的日志文件</li>
<li>网络流量</li>
<li>系统目录和文件的异常变化</li>
<li>程序执行中的异常行为</li>
</ul>
</li>
<li>分析引擎<ul>
<li>模式匹配<br> 将收集到的信息与已知的网络入侵和系统误用模式数据库进行比较，从而发现违背安全策略的行为</li>
<li>统计分析<br> 统计正常使用时的一些测量属性，当观察值在正常值以外时，就认为有入侵发生</li>
<li>完整性分析，常用于事后分析<br> 关注某个文件或对象是否被更改</li>
</ul>
</li>
<li>响应部件<ul>
<li>简单报警</li>
<li>切断连接</li>
<li>封锁用户</li>
<li>改变文件属性</li>
<li>最强烈反应：回击攻击者</li>
</ul>
</li>
</ol>
<h3 id="PPDR模型"><a href="#PPDR模型" class="headerlink" title="PPDR模型"></a>PPDR模型</h3><p>特点是动态性和时效性<br><img src="/2023/05/15/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/25.png"><br>狠狠的记！这个在第一章也出现过，这里是就着入侵检测给赋予了新含义<br>其实现在再想想好像当年那个题是让写这里的内容，不是第一章那些技术</p>
<ul>
<li>Policy（策略）<br>PPDR的核心。规定系统所要达到的安全目标和为达到安全目标所采取的各种具体安全措施及实施强度</li>
<li>Protection（防护）<br>具体包括制定安全管理规则、进行系统安全配置工作以及安装各种安全防护设备</li>
<li>Detection（检测）<br>采用各种安全措施后，根据系统运行情况的变化，对系统安全状态进行实时的动态监控</li>
<li>Response（响应）<br>当发现入侵活动或入侵结果后，需要系统做出及时的反应并采取措施</li>
<li>结论<br>安全的目标实际上就是尽可能的增大保护时间，尽量减少检测时间和响应时间</li>
</ul>
<h2 id="入侵检测的信息源"><a href="#入侵检测的信息源" class="headerlink" title="入侵检测的信息源"></a>入侵检测的信息源</h2><p>这里感觉是把上面的信息收集的信息来源内容扩展来说了</p>
<p>入侵检测不同类型需要不同的数据，同时输出结果很大程度取决于输入数据的质量</p>
<p>几种数据类型</p>
<ul>
<li>操作系统审计记录</li>
<li>操作系统日志</li>
<li>应用程序日志</li>
<li>基于网络数据的信息源</li>
<li>其他数据来源<br>就上面的来源来说这里应该指的是文件访问删除记录，系统调用对象和发起人这样的，但是这些又能包含在操作系统审计记录里面，有点难说</li>
</ul>
<p>操作系统审计记录<br>最早的入侵检测输入数据，且是首选数据，因为其审计数据规整且附有保护措施，并且可以提供系统底层的相关信息</p>
<p>操作系统日志<br>是操作系统生成的日志文件的总称，此质量相对上一个质量较差，因为产生日志的软件位于用户级，易受攻击，且日志文件不受保护</p>
<p>应用程序日志<br>用户及的系统活动抽象信息，且因网络化计算环境普及，入侵攻击目标越来越集中于提供网络服务的各种特定应用程序<br>但是这个日志更容易被攻击，对于审计没有提供详细信息，且一些软件是否可以相信也是问题</p>
<p>基于网络数据的信息源<br>优势</p>
<ul>
<li>对目标监控系统的运行性能几乎没有任何影响</li>
<li>可以对用户透明，降低了本身遭到入侵的概率</li>
<li>可以发现许多基于主机无法发现的攻击手段</li>
<li>网络数据包的标准化程度高</li>
</ul>
<p>信息源的选择问题</p>
<ul>
<li>根据检测目标选择输入数据源</li>
<li>在不影响目标系统运行性能情况下最少需要多少信息</li>
</ul>
<h2 id="入侵检测技术分类"><a href="#入侵检测技术分类" class="headerlink" title="入侵检测技术分类"></a>入侵检测技术分类</h2><h3 id="按照信息源分类"><a href="#按照信息源分类" class="headerlink" title="按照信息源分类"></a>按照信息源分类</h3><ol>
<li>基于主机的入侵检测</li>
<li>基于网络的入侵检测</li>
</ol>
<p>基于主机入侵检测<br>优点：能较准确的检测到发生在主机系统高层的复杂攻击行为<br>缺点：无法移植，影响主机性能，无法反应网络攻击</p>
<p>基于网络入侵检测<br>优点：实时监控网络流量，对潜在攻击做出迅速响应，可移植，不影响主机性能<br>缺点：准确率低，不能完成发生在应用进程级别的侦测</p>
<h3 id="按照检测方法分类"><a href="#按照检测方法分类" class="headerlink" title="按照检测方法分类"></a>按照检测方法分类</h3><ol>
<li>滥用入侵检测</li>
<li>异常入侵检测</li>
</ol>
<p>滥用有更好的确定解释能力，较高的检测率和较低的虚警率，但只能用已知的攻击模式<br>异常可以检测未知的攻击行为</p>
<h1 id="3-2-基于主机的入侵检测技术"><a href="#3-2-基于主机的入侵检测技术" class="headerlink" title="3-2 基于主机的入侵检测技术"></a>3-2 基于主机的入侵检测技术</h1><h2 id="审计数据的获取"><a href="#审计数据的获取" class="headerlink" title="审计数据的获取"></a>审计数据的获取</h2><ol>
<li>确定审计数据的来源和类型</li>
<li>审计数据的预处理工作，其中包括记录标准格式的设计、过滤和映射操作等</li>
<li>审计数据的获取方式，包括审计数据获取模块的结构设计和传输协议等</li>
</ol>
<h3 id="审计数据类型和来源"><a href="#审计数据类型和来源" class="headerlink" title="审计数据类型和来源"></a>审计数据类型和来源</h3><p>主机类型不同和审计的不同要求，审计数据收集的类型也不相同</p>
<p>审计数据：</p>
<ul>
<li>文件访问</li>
<li>系统访问</li>
<li>资源消耗</li>
<li>进程创建命令的调用</li>
</ul>
<h3 id="审计数据的预处理"><a href="#审计数据的预处理" class="headerlink" title="审计数据的预处理"></a>审计数据的预处理</h3><p>映射、过滤、格式转化</p>
<p>映射过滤消除无用审计记录<br>格式转化将审计记录转换为单一格式</p>
<p>审计记录格式设计<br>通用程度足够高<br>对于机器最有效的格式<br>考虑系统通用性，从不同机器都可以接收输入<br>一个审计记录中应尽可能提供更多信息</p>
<h3 id="审计数据获取模块设计"><a href="#审计数据获取模块设计" class="headerlink" title="审计数据获取模块设计"></a>审计数据获取模块设计</h3><ul>
<li>处理负荷的平衡问题</li>
<li>传输协议</li>
<li>多路复用成为一条单一审计记录数据流的问题</li>
<li>延时、遗漏等问题</li>
</ul>
<h2 id="用于入侵检测的统计模型"><a href="#用于入侵检测的统计模型" class="headerlink" title="用于入侵检测的统计模型"></a>用于入侵检测的统计模型</h2><p>1 .操作模型<br>系统中所发生事件的计数度量情况，将所关心的特定事件计数值与某个阈值进行比较，如果超过，则指示发生了异常情况<br>2. 均值和标准偏差模型<br>采用数据的均值和标准偏差，当前用户行为超出了可信任的区间范围，则表示为异常行为<br>3. 多元模型<br>在多个参数度量之间进行相关分析<br>4. 马尔可夫过程模型<br>将每个审计记录中不同类型事件的出现视为随机变量的不同取值，采用状态转移矩阵来表示不同事件序列出现的概率值，如果当前审计事件按照正常的状态转移矩阵所计算出的发生概率小于某个阈值，则指示为异常行为</p>
<p>IDES策略<br>当前系统的活动状态采用一组测量值参数变量来表示，称为“入侵检测向量”<br>IDES定义了3种不同类型的测量值，分别针对用户主体、目标系统主体和远程主机主体</p>
<p>不同类型的单独测量值分为以下4个类别<br>活动强度测量值<br>审计记录分布测量值<br>类别测量值<br>序数测量值</p>
<h2 id="入侵检测的专家系统"><a href="#入侵检测的专家系统" class="headerlink" title="入侵检测的专家系统"></a>入侵检测的专家系统</h2><p>专家系统在知识库的基础上，根据所获得的事实和已知的规则进行推导<br>对于超出已有规则范围的事实，它无法得出有用的结论<br>每个规则具有“IF条件THEN 动作”的形式<br>专家系统可以自动地解释系统的审计记录<br>专家系统规则表示一系列的活动不具有直观性<br>专家系统规则很难检测出对系统的协同攻击</p>
<h2 id="基于状态转移分析的入侵检测技术"><a href="#基于状态转移分析的入侵检测技术" class="headerlink" title="基于状态转移分析的入侵检测技术"></a>基于状态转移分析的入侵检测技术</h2><p>特点：<br>脱离了单纯进行主机入侵检测的结构，实现了分布式的入侵检测框架、</p>
<p>原理：<br>基于状态分析的检测模型，将攻击者的入侵行为描绘为一系列的特征操作及其引起的一系列系统状态转换过程</p>
<p>优点：</p>
<ol>
<li>采用状态转移法标识攻击过程，使攻击行为直观可见</li>
<li>STAT可以很好的分别不同的审计记录序列</li>
<li>可以检测协同攻击和跨进程的攻击行为</li>
<li>在攻击行为未造成危害时及时检测并采取响应措施</li>
<li>可以较好处理已知攻击的变种行为</li>
</ol>
<p>状态转移图：<br><img src="/2023/05/15/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/26.png"></p>
<p>构建状态转移图步骤</p>
<ol>
<li>分析具体攻击</li>
<li>抽象攻击行为关键行为点</li>
<li>确定初始状态和最终状态</li>
<li>从最终状态出发逐步确定中间各个状态及其满足的状态断言组</li>
</ol>
<p><strong>STAT推理原理</strong><br>一行对一个攻击实例，一列对一个步骤<br>推理引擎工作时先找到对应的状态转移图，找到后复制一个新行到现有的推理引擎表中，因为原来的表象仍可以代表某次部分完成的具体攻击实例<br><img src="/2023/05/15/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/27.png"><br><img src="/2023/05/15/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/28.png"></p>
<p>推理引擎的最重要的功能就是判断状态断言的真假</p>
<h2 id="文件完整性检查"><a href="#文件完整性检查" class="headerlink" title="文件完整性检查"></a>文件完整性检查</h2><p>目的：发现潜在的针对文件系统的有意或无意的修改</p>
<p>必要性：</p>
<ol>
<li>攻击者入侵后常安装后门程序</li>
<li>可能安装非授权的程序替换系统程序</li>
<li>可能删除审计记录</li>
<li>修改配置文件或数据库数据等</li>
</ol>
<p>思想：<br>目标文件生成唯一标识符，检查时生成新的标识符与旧的标识符比较，确定文件是否更改</p>
<h3 id="检查列表技术"><a href="#检查列表技术" class="headerlink" title="检查列表技术"></a>检查列表技术</h3><p>特点：<br>用一个列表储存文件标识信息<br>方法：<br>检查时系统取得文件的属性信息并于列表中储存的比较<br>优点：<br>快<br>缺点：<br>无法保证文件内容，仅能保证文件属性</p>
<h3 id="TripWire"><a href="#TripWire" class="headerlink" title="TripWire"></a>TripWire</h3><p>最著名完整性检查工具</p>
<p>基本思想：<br>单项消息摘要，将文件校验和信息存储到可靠的安全存储介质上，系统定时验证</p>
<p>完整性检查为什么是主机入侵检测的技术？：<br>因为许多针对主机系统的攻击会体现在文件上，针对文件的完整性，属于事后入侵检测技术</p>
<h2 id="系统配置分析技术"><a href="#系统配置分析技术" class="headerlink" title="系统配置分析技术"></a>系统配置分析技术</h2><p>目标是检查系统是否已经受到入侵活动的侵害，或者存在有可能被入侵的危险<br>之所以称为“静态”，是因为该技术只检查系统的静态特征，并不分析系统的活动情况</p>
<p>此技术可以在入侵发生之前用，也可以在潜在的攻击活动之后用。针对入侵产生的痕迹以及人员初始对系统的错误配置从而导致的入侵风险<br>所以可以纳入入侵检测范围</p>
<p><em>COPS系统</em></p>
<ul>
<li>检查文件、目录和设备的访问权限模式</li>
<li>脆弱的口令设置</li>
<li>检查口令文件和组用户文件的安全性、格式、内容</li>
<li>检查在&#x2F;etc&#x2F;rc*目录和cron中指定运行的文件和程序</li>
<li>具有root SUID属性的文件，检查它们是否可写，以及是否脚本程序</li>
<li>对重要的二进制文件和其他文件计算CRC校验和，检查是否发生更改</li>
<li>检查用户主目录下文件是否可写</li>
<li>是否具有匿名FTP登录服务账户</li>
<li>是否存在TFTP服务，Sendmail中别名情况以及在inetd conf文件中隐藏的启动脚本程序等</li>
<li>各种类型的根权限检查</li>
<li>按照CERT安全报告的发布日期，检查关键文件是否已经及时进行了升级或打上补丁</li>
</ul>
<h1 id="3-3-基于网络的入侵检测技术"><a href="#3-3-基于网络的入侵检测技术" class="headerlink" title="3-3 基于网络的入侵检测技术"></a>3-3 基于网络的入侵检测技术</h1><h2 id="协议分层模型与TCP-IP协议"><a href="#协议分层模型与TCP-IP协议" class="headerlink" title="协议分层模型与TCP&#x2F;IP协议"></a>协议分层模型与TCP&#x2F;IP协议</h2><p>我记得她当时说这里不咋考，因为你们计网都学过</p>
<p>协议采用分层方式，低层对高层采用透明服务，相邻层之间采用原语交互<br>同层协议在不同机器上实现可能不同，但要保证：</p>
<ul>
<li>正确实现上下层交互原语</li>
<li>提供一致的服务</li>
</ul>
<p><img src="/2023/05/15/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/29.png"></p>
<p>IP层<br>为IP数据报分配一个全网唯一的IP地址</p>
<p>传输层<br>传输层作为应用程序提供端到端通信功能，保证通信连接的可靠性</p>
<p>应用层：<br>位于传输层之上的应用层包含所有的高层协议</p>
<p>网络接口层<br>TCP&#x2F;IP协议并不包括物理层和数据链路层协议</p>
<p>ARP&#x2F;RARP<br>为了使TCP&#x2F;IP协议与具体的物理网络无关，将物理地址隐藏而统一使用IP地址进行网际通信，就必须提供一种在IP地址和物理地址之间进行映射的机制</p>
<p>IP<br>IP协议是TCP&#x2F;IP协议族的核心协议之一，它提供了无连接数据包传输和网际路由服务，不可靠<br>IP协议首先要根据物理网络所允许的最大报文长度对上层协议的数据进行长度检查，必要时将数据报分成若干段后再发送</p>
<p>ICMP<br>差错报告，为所有控制报文和信息报文提供了一个统一的机制，采用路由器向源主机报告模式</p>
<p>TCP<br>建立可靠的端对端连接，并提供虚电路服务和面向数据流的传输服务</p>
<p>UDP<br>UDP主要用于直接使用数据报服务的应用程序，这些应用程序自己提供误码校验以及拥塞控制机制</p>
<h2 id="网络数据包截获❗"><a href="#网络数据包截获❗" class="headerlink" title="网络数据包截获❗"></a>网络数据包截获❗</h2><p>网络数据包的截获是基于网络的入侵检测技术的工作基石</p>
<p>截获方法；</p>
<ul>
<li>利用以太网广播特性</li>
<li>设置路由器监听口或镜像口</li>
<li>分光器复制</li>
<li>光交换机</li>
</ul>
<p>以太网环境下数据包截获方法；<br>将网卡工作模式置于混杂模式，直接访问数据链路层截获相关数据，有响应应用程序解析TCP&#x2F;IP，截获所有流经网卡的数据</p>
<p>伯克利抓包过滤器</p>
<ul>
<li>能够尽早丢弃不需要的数据包</li>
<li>避免必须将所有的数据包从内核中复制到用户空间再进行处理这种重复的复制（无效工作）</li>
<li>节约了大量的CPU时间</li>
</ul>
<p>交换网络环境下的数据包截获方法<br>利用交换机或路由器上设置监听口或镜像口<br>问题：</p>
<ul>
<li>交换带宽增长导致并非所有网络流量都会反映在镜像口上</li>
<li>不是所有设备都有镜像口</li>
</ul>
<p>Libpcap<br>不同操作系统提供接口功能不同，所以提出了libpcap<br>作用</p>
<ul>
<li>捕获</li>
<li>过滤</li>
<li>分析</li>
<li>存储</li>
</ul>
<p>又一个重复的知识点，狠狠的背吧，内容安全也能用上</p>
<h2 id="检测引擎设计❗"><a href="#检测引擎设计❗" class="headerlink" title="检测引擎设计❗"></a>检测引擎设计❗</h2><p>两大类</p>
<ul>
<li>嵌入式规则检测引擎<br>代码实现对于终端用户隐藏不可见，用户可以从既定规则中选择子集</li>
<li>可编程检测引擎<br>允许用户采用特定的编程语言或脚本语言，来实现具体的检测模块，灵活</li>
</ul>
<h3 id="嵌入式规则检测引擎❗Snort"><a href="#嵌入式规则检测引擎❗Snort" class="headerlink" title="嵌入式规则检测引擎❗Snort"></a>嵌入式规则检测引擎❗Snort</h3><p>规则的两个逻辑部分</p>
<ul>
<li>规则头<br>IP地址，端口号，方向操作符</li>
<li>规则选项<br>警报信息，用于确定是否触发规则响应动作而需检查的数据包区域位置信息</li>
</ul>
<p>这里有一堆规则代码啥的，但她自己说不考编程</p>
<p>系统结构</p>
<ul>
<li>协议解析器</li>
<li>规则检测引擎</li>
<li>日志&#x2F;警报系统</li>
</ul>
<p><img src="/2023/05/15/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/30.png"></p>
<p>协议解析器<br>解析Packet<br>Packet数据结构主要分为三类</p>
<ul>
<li>指示原始数据包截获信息的字段</li>
<li>用于存放当前数据包进行协议解析后所得信息的字段</li>
<li>各种标识字段</li>
</ul>
<p>规则检测引擎</p>
<ul>
<li>规则链表构造模块<br>是读入配置文件，逐条解析检测规则，并最终形成内存中的二维规则链表结构<br>同一个规则链表头的下面可以链接多个规则链表选项结点<ul>
<li>链表头</li>
<li>链表选项<br><img src="/2023/05/15/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/31.png"></li>
</ul>
</li>
<li>预处理器模块<ul>
<li>数据包分片重组及数据流重组功能</li>
<li>协议规范化&#x2F;解码功能</li>
</ul>
</li>
<li>规则匹配模块<br>对于每一个当前数据包，遍历整个规则链表结构，并调用对应的插件模块进行各种处理。一旦规则匹配模块搜索到一个与解析后的数据包匹配的则，则触发定义好的规则动作并返回</li>
</ul>
<p>日志&#x2F;警报系统<br>规则匹配模块所触发的规则动作，具体功能实现由日志&#x2F;警报系统完成，可通过各种插件模块来实现<br>三种日志模式：</p>
<ul>
<li>关闭：获取更好的运行性能</li>
<li>以可读格式记录数据包：有利于快速分析</li>
<li>以Tcpdump二进制形式记录数据包：提高系统运行性能</li>
</ul>
<h3 id="可编程的检测引擎"><a href="#可编程的检测引擎" class="headerlink" title="可编程的检测引擎"></a>可编程的检测引擎</h3><p>要点就在于用于实现入侵检测功能的脚本语言的定义及其与引擎架构的接口设计</p>
<h3 id="特征分析与协议分析❗"><a href="#特征分析与协议分析❗" class="headerlink" title="特征分析与协议分析❗"></a>特征分析与协议分析❗</h3><p>特征分析<br>在最初的特征分析技术工作过程中，每次输入检测引擎的数据包，将会与单个特征进行逐个字符的匹配操作<br>将输入数据包视为一个无序无结构的随机数据流，仅依靠简单的字符串匹配操作完成所有的检测任务</p>
<p>协议分析<br>将输入数据包视为具有严格定义格式的数据流，并将输入数据包按照各层协议报文封装的反向顺序，层层解析出来。<br>协议分析技术利用预先定义好的关于协议字段的期望值或合理值的详细信息，来判断是否出现了恶意的网络流量。</p>
<p>特征分析优点：</p>
<ul>
<li>在小规则集合情况下工作速度快</li>
<li>检测规则易于编写、理解并且容易进行定制</li>
<li>对新出现的攻击手段具备快速升级支持能力</li>
<li>对底层的简单脚本攻击，具备良好的检测性能</li>
<li>对所发生的攻击类型，具备确定性的解释能力<br>特征分析缺点：</li>
<li>随着规则集合规模的扩大，检测速度迅速下降</li>
<li>各种变种的攻击行为，易于造成过度膨胀的规则集合</li>
<li>较易产生虚警信息</li>
<li>仅能检测到已知的攻击类型</li>
</ul>
<p>协议分析优点：</p>
<ul>
<li>具备良好的性能可扩展性</li>
<li>具备发现最新的未知安全漏洞的能力</li>
<li>较少出现虚警信息</li>
</ul>
<p><del>我比较不理解的是发现新漏洞和虚警率低真的可以共存吗？</del></p>
<p>协议分析缺点：</p>
<ul>
<li>在小规模集合情况下，初始的检测速度相对较慢</li>
<li>检测规则比较复杂，难以编写和理解并且通常是由特定厂商实现</li>
<li>协议复杂性的扩展以及实际实现的多样性，容易导致规则扩展的困难</li>
<li>对发现的攻击行为类型，缺乏明确的解释信息</li>
</ul>
<p>怎么快速记？</p>
<ul>
<li>小规则情况</li>
<li>编写难度</li>
<li>增加规则难度，扩展性</li>
<li>解释能力</li>
<li>虚警率</li>
<li>检测未知攻击</li>
</ul>
<h1 id="4-互联网基础设施安全"><a href="#4-互联网基础设施安全" class="headerlink" title="4 互联网基础设施安全"></a>4 互联网基础设施安全</h1><p>十分建议这里看ppt，很多东西都是图，完事我上课也没咋听，没有思路，就记着个DNS的威胁探测</p>
<p>我觉得这一章怎么考，我觉得会让你说几个DNS评估的算法名字，不会考具体的点，要不谁能说上来</p>
<p>前言？<br>可以通过公开渠道获得信息，但属于事中和事后<br>通过对关基提前监测和分析，对网络资源画像，可以实现提前预警</p>
<h2 id="研究的目的与意义"><a href="#研究的目的与意义" class="headerlink" title="研究的目的与意义"></a>研究的目的与意义</h2><p>关键信息基础设施是指公共通信和信息服务、能源、交通、水利、金融、公共服务、电子政务等重要行业和领域，以及其他一旦遭到破坏、丧失功能或者数据泄露，可能严重危害国家安全、国计民生、公共利益的信息设施</p>
<p>国外现状：<br>美国全面领先<br>俄罗斯自成一体<br>欧盟跟随创新</p>
<p>研究思路：<br>实现事前、事中、事后的全链条、全过程的识别、监测、分析、预警与处置，保障重点目标防护的及时性、全面性和准确性<br>静动结合，知己知彼，实现目标</p>
<h2 id="DNS安全与域名安全"><a href="#DNS安全与域名安全" class="headerlink" title="DNS安全与域名安全"></a>DNS安全与域名安全</h2><p>域名系统已成为互联网重要的基础设施，是保障互联网稳定运行的“基石“</p>
<p>研究背景与意义</p>
<p><img src="/2023/05/15/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/32.png"></p>
<p>域名解析器作为用户与域名服务器间数据传输的“桥梁”，决定广大互联网用户最终的网络访问体验</p>
<p>域名系统：<br>域名空间与资源记录<br>名称服务器（域名服务器）<br>解析器（域名解析器）</p>
<ul>
<li>国家层面<br>发布网络安全法及关基安全保护条例</li>
<li>行业层面<br>开放域名服务器对互联网可用性的消极影响已成共识</li>
<li>用户层面<br>意识到域名解析器对于网络访问的重要性</li>
</ul>
<p>DNS科学研究体系<br><img src="/2023/05/15/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/33.png"></p>
<h3 id="测绘"><a href="#测绘" class="headerlink" title="测绘"></a>测绘</h3><p><img src="/2023/05/15/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/34.png"></p>
<p>这图看着多少有点恐怖了</p>
<h4 id="全球根和顶级域服务器测量及异常解析分析"><a href="#全球根和顶级域服务器测量及异常解析分析" class="headerlink" title="全球根和顶级域服务器测量及异常解析分析"></a>全球根和顶级域服务器测量及异常解析分析</h4><ul>
<li>停服异常<br>  观测时间内域名在DNS服务器上因DNS服务器原因无法获取解析结果</li>
<li>断服异常<br>  观测时间内域名在DNS服务器上因DNS服务器原因时断时续的获取解析结果</li>
<li>篡改异常<br>  域名在DNS服务器上的解析记录被篡改</li>
</ul>
<p>国内外研究存在的问题</p>
<ol>
<li>停服和断服：<br>针对具体情况缺乏具体分析，对未返回解析结果没有细化分析，依据单节点解析判断是否在线</li>
<li>篡改异常和可信资源记录维护：<br>缺乏可信资源记录的动态更新</li>
<li>域名解析主动检测<br>检测DNS服务器全面性不足，数据采集和简单统计，未进一步分析解析结果</li>
</ol>
<h4 id="停服异常评估模型"><a href="#停服异常评估模型" class="headerlink" title="停服异常评估模型"></a>停服异常评估模型</h4><p><img src="/2023/05/15/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/35.png"></p>
<p>基于决策树的停服异常判断模型构建</p>
<ul>
<li>无解析结果分析<ol>
<li>请求超时<br>  网络拥塞，政策限制，DNS服务器不可达</li>
<li>返回非NoError<br>  请求格式你，内容，IP地址出错，DNS服务器原因</li>
<li>返回NoError<br>  未配置某资源记录，DNS服务器原因</li>
</ol>
</li>
<li>可疑DNS原因导致的无解析结果情况</li>
</ul>
<h4 id="断服异常评估模型"><a href="#断服异常评估模型" class="headerlink" title="断服异常评估模型"></a>断服异常评估模型</h4><p>在停服异常评估之后对感知重点域名在不同层级DNS服务器上的解析结果分析，判断是否发生断服异常。</p>
<p><img src="/2023/05/15/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/36.png"></p>
<p>层次分析法：<br>根据返回的不同结果一层一层找原因</p>
<ol>
<li>请求超时，同时网络良好</li>
<li>返回五类RFV码</li>
</ol>
<h4 id="篡改异常评估方法"><a href="#篡改异常评估方法" class="headerlink" title="篡改异常评估方法"></a>篡改异常评估方法</h4><p>篡改异常评估是基于可信资源记录维护</p>
<p><img src="/2023/05/15/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/37.png"></p>
<p>pre_rr：可信资源记录中未出现在某探测结果中的资源记录<br>new_rr：某次探测结果中新增加的资源记录</p>
<p>基于判别模型的可信资源记录维护——数据采集（可信中A集合）<br>一个样本&#x3D;域名+需要判断的A记录+相关A记录集合+样本标签</p>
<h4 id="全球根和顶级域服务器的测量及异常解析分析"><a href="#全球根和顶级域服务器的测量及异常解析分析" class="headerlink" title="全球根和顶级域服务器的测量及异常解析分析"></a>全球根和顶级域服务器的测量及异常解析分析</h4><ul>
<li>技术方案<ol>
<li>多级任务分布式系统：测绘需求、测绘点、测绘目标等</li>
<li>消除网络阻塞造成的噪声数据的技术：数据清洗</li>
<li>全层级关联融合的重点域名解析异常评估技术：异常分析</li>
</ol>
</li>
</ul>
<h3 id="开放DNS服务器发现、分类与可用性评估"><a href="#开放DNS服务器发现、分类与可用性评估" class="headerlink" title="开放DNS服务器发现、分类与可用性评估"></a>开放DNS服务器发现、分类与可用性评估</h3><p>研究背景<br><img src="/2023/05/15/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/38.png"></p>
<ul>
<li><p>特点：</p>
<ol>
<li>用用户直接交互</li>
<li>规模庞大</li>
<li>向公众用户开放</li>
</ol>
</li>
<li><p>开放域名解析器对互联网影响远超另外两类</p>
</li>
<li><p>国内外研究现状</p>
<ol>
<li>发现不完全，分类不准确，探测效益比低</li>
<li>对开放DNS评估的研究较少，评估指标孤立、未揭露互联网中开放DNS健康现状</li>
<li>忽略提供服务本身的用户的接受度、服务满意度，测量和评估结果易受探测点影响，未揭露互联网中开放DNS服务质量现状</li>
<li>忽略资源消耗成本，未有大规模实验验证可用性</li>
</ol>
</li>
</ul>
<p><img src="/2023/05/15/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/39.png"></p>
<h4 id="基于地址空间约减的开放DNS发现与分类"><a href="#基于地址空间约减的开放DNS发现与分类" class="headerlink" title="基于地址空间约减的开放DNS发现与分类"></a>基于地址空间约减的开放DNS发现与分类</h4><ul>
<li>对开放DNS数据的要求<ol>
<li>时效性</li>
<li>数量和分布</li>
<li>准确性</li>
<li>信息量</li>
</ol>
</li>
<li>三种获取方式<ol>
<li>主动获取</li>
<li>被动获取</li>
<li>第三方获取</li>
</ol>
</li>
</ul>
<p>解决</p>
<ul>
<li>高容忍度发现<br>  实现对开放DNS的更完全发现</li>
<li>在用户侧和权威域名服务器侧均收集DNS数据包<br>  实现对开放DNS的更准确分类</li>
<li>分析发现获得的开放DNS的IP地址分布规律<br>  提高开放DNS发现与分类的效益比</li>
</ul>
<p>高容忍度发现<br>过程：</p>
<ul>
<li>DNS数据包发送</li>
<li>DNS数据包收集</li>
<li>开放DNS判定</li>
</ul>
<p>开放DNS发现与分类的结果</p>
<ul>
<li>发现足够多的开放DNS</li>
<li>高容忍度的判定标准能更完全地发现</li>
<li>高容忍度的数据包发送方式有助于更完全地发现</li>
<li>高容忍度的数据包收集方式有助于更完全地发现</li>
</ul>
<p>基于解析路径的开放DNS分类方法<br>方法：</p>
<ol>
<li>分析域名解析器间一致性</li>
<li>描绘域名解析路径</li>
<li>判定DNS类型</li>
<li>对开放DNS分类</li>
</ol>
<p>基于地址不均匀分布的探测地址空间约减方法<br>关键问题：<br>开放DNSIP地址变动频繁<br>开放DNS占所有IP地址量级小</p>
<h3 id="基于多自身属性协同的开放DNS健康状况测量与评估"><a href="#基于多自身属性协同的开放DNS健康状况测量与评估" class="headerlink" title="基于多自身属性协同的开放DNS健康状况测量与评估"></a>基于多自身属性协同的开放DNS健康状况测量与评估</h3><p>评估指标：<br>运行稳定性<br>解析安全性<br>数据完整性<br>一致性：关注的是域名系统中同一DNS区的权威域名服务器间<br>速度和可用性：被归类为体现域名解析服务效果的指标<br>可恢复性：涉及故障恢复能力因而通常被认为无法进行主动测量获得</p>
<h4 id="基于影响力对抗的解析安全性评估方法"><a href="#基于影响力对抗的解析安全性评估方法" class="headerlink" title="基于影响力对抗的解析安全性评估方法"></a>基于影响力对抗的解析安全性评估方法</h4><p>分析加密协议的正向影响力与DNS软件漏洞的反向影响力，基于两者对抗结果评估解析安全性</p>
<h4 id="基于双传输协议的数据完整性评估方法"><a href="#基于双传输协议的数据完整性评估方法" class="headerlink" title="基于双传输协议的数据完整性评估方法"></a>基于双传输协议的数据完整性评估方法</h4><p>从UDP与TCP两个传输协议评估开放DNS的数据完整性</p>
<h4 id="基于多自身属性协同的开放DNS健康状况评估方法"><a href="#基于多自身属性协同的开放DNS健康状况评估方法" class="headerlink" title="基于多自身属性协同的开放DNS健康状况评估方法"></a>基于多自身属性协同的开放DNS健康状况评估方法</h4><ol>
<li>采用层次分析法确定权数【适用于绝对评价】</li>
<li>合成模型的确定</li>
<li>健康状况的评估</li>
</ol>
<h3 id="基于服务置信度的开放DNS服务质量测量与评估"><a href="#基于服务置信度的开放DNS服务质量测量与评估" class="headerlink" title="基于服务置信度的开放DNS服务质量测量与评估"></a>基于服务置信度的开放DNS服务质量测量与评估</h3><p>评估指标</p>
<ul>
<li>服务有效性</li>
<li>服务准确定</li>
<li>服务及时性</li>
</ul>
<h4 id="异常DNS响应的识别与分类方法"><a href="#异常DNS响应的识别与分类方法" class="headerlink" title="异常DNS响应的识别与分类方法"></a>异常DNS响应的识别与分类方法</h4><h4 id="服务有效性评估方法、服务准确性评估方法"><a href="#服务有效性评估方法、服务准确性评估方法" class="headerlink" title="服务有效性评估方法、服务准确性评估方法"></a>服务有效性评估方法、服务准确性评估方法</h4><h4 id="基于查询时延的服务及时性评估方法"><a href="#基于查询时延的服务及时性评估方法" class="headerlink" title="基于查询时延的服务及时性评估方法"></a>基于查询时延的服务及时性评估方法</h4><p>提出开放DNS与根&#x2F;顶级域名服务器间查询时延的测量方法，实现了服务及时性的评估</p>
<h4 id="基于服务置信度的开放DNS服务质量评估方法"><a href="#基于服务置信度的开放DNS服务质量评估方法" class="headerlink" title="基于服务置信度的开放DNS服务质量评估方法"></a>基于服务置信度的开放DNS服务质量评估方法</h4><p>根据服务有效性、服务准确性、服务及时性对开放DNS服务质量进行综合评价</p>
<ol>
<li>采用层次分析法确定权数【适用于绝对评价】</li>
<li>合成模型的确定</li>
<li>健康状况的评估</li>
</ol>
<h3 id="基于效益比的开放DNS可用性测量与评估"><a href="#基于效益比的开放DNS可用性测量与评估" class="headerlink" title="基于效益比的开放DNS可用性测量与评估"></a>基于效益比的开放DNS可用性测量与评估</h3><p><img src="/2023/05/15/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/40.png"></p>
<h4 id="基于数据包浪费分析的开放DNS节能程度评估方法"><a href="#基于数据包浪费分析的开放DNS节能程度评估方法" class="headerlink" title="基于数据包浪费分析的开放DNS节能程度评估方法"></a>基于数据包浪费分析的开放DNS节能程度评估方法</h4><p>依据其在域名解析路径中、DNS响应引起的数据包浪费行为，计算数据包浪费比例，实现节能程度评估</p>
<h4 id="基于效益比的开放DNS可用性评估方法"><a href="#基于效益比的开放DNS可用性评估方法" class="headerlink" title="基于效益比的开放DNS可用性评估方法"></a>基于效益比的开放DNS可用性评估方法</h4><p>根据体现运行“收益”的健康状况、体现服务 “收益”的服务质量、体现资源“成本”的节能程度，对开放DNS的可用性进行综合评价</p>
<h4 id="开放DNS可用性测量与评估系统"><a href="#开放DNS可用性测量与评估系统" class="headerlink" title="开放DNS可用性测量与评估系统"></a>开放DNS可用性测量与评估系统</h4><p><img src="/2023/05/15/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/41.png"></p>
<h2 id="重点域名DNS劫持发现与分析"><a href="#重点域名DNS劫持发现与分析" class="headerlink" title="重点域名DNS劫持发现与分析"></a>重点域名DNS劫持发现与分析</h2><p>DNS劫持：通过攻击DNS服务器，或伪造DNS服务器的方法，把目标网站域名解析到错误的IP地址从而实现用户无法访问目标网站的目的，或者恶意要求用户访问指定IP地址（假网站）的目的。</p>
<p>DNS劫持：造成经济损失，造成政治威胁</p>
<p>开放DNS：可以接收公众用户的请求，直接与用户进行报文交互，负责接收用户的查询请求，进行查询并且返回给用户查询结果</p>
<h3 id="研究目的："><a href="#研究目的：" class="headerlink" title="研究目的："></a>研究目的：</h3><p>及时全面的重点域名DNS劫持发现<br>意义：</p>
<ul>
<li>国家角度<br>  为国家网络安全应急响应提供依据</li>
<li>行业角度<br>  为运营商等其他DNS服务器管理着运维、管理提供指导</li>
<li>用户角度<br>  保障用户的安全访问</li>
</ul>
<h3 id="研究现状；"><a href="#研究现状；" class="headerlink" title="研究现状；"></a>研究现状；</h3><ol>
<li>全球DNS发现<br> 针对全球节点发现，但全球节点巨多，所以时间长效率低对互联网空间污染大</li>
<li>DNS劫持相关研究<br> 较多使用被动方式，DNS劫持发现不及时<br> 主动较少，常基于&lt;域名、IP&gt;解析对变化，方式单一容易误判<br> 整体来看，DNS劫持检测的方法研究少且不深入，应对DNS劫持的理论研究，防护措施，新技术</li>
<li>改进<ul>
<li>及时性——主动测量</li>
<li>全面性——选取全球多地区探测点</li>
<li>准确性——增加基于网页内容的DNS劫持检测方式</li>
</ul>
</li>
</ol>
<p><img src="/2023/05/15/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/42.png"></p>
<p>研究方案：</p>
<ul>
<li>方式：主动测量</li>
<li>报文：DNS请求报文</li>
<li>探测点：云服务</li>
<li>输入：全球开放DNS</li>
</ul>
<p>DNS劫持检测模块——重点域名解析IP地址检测</p>
<ul>
<li>是否错误</li>
<li>是否可访问</li>
</ul>
<h3 id="基于网页内容的DNS劫持检测"><a href="#基于网页内容的DNS劫持检测" class="headerlink" title="基于网页内容的DNS劫持检测"></a>基于网页内容的DNS劫持检测</h3><p>提前网页标签特征和文本向量特征，特征融合后进行匹配，多不匹配则认为被劫持，或匹配后外链不对也判断为劫持<br>获取网页内外链，使用百度和腾讯提供的第三方API进行检测</p>
<h3 id="基于网页证书的DNS劫持检测"><a href="#基于网页证书的DNS劫持检测" class="headerlink" title="基于网页证书的DNS劫持检测"></a>基于网页证书的DNS劫持检测</h3><p>链接网页后获取证书进行校验</p>
<h3 id="基于网页快照文字识别的DNS劫持检测"><a href="#基于网页快照文字识别的DNS劫持检测" class="headerlink" title="基于网页快照文字识别的DNS劫持检测"></a>基于网页快照文字识别的DNS劫持检测</h3><p>图片文字识别</p>
<h3 id="DNS劫持定位与分析"><a href="#DNS劫持定位与分析" class="headerlink" title="DNS劫持定位与分析"></a>DNS劫持定位与分析</h3><h4 id="研究方案"><a href="#研究方案" class="headerlink" title="研究方案"></a>研究方案</h4><p><img src="/2023/05/15/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/43.png"></p>
<ol>
<li>域名管理出错<br> 所有的DNS均判定为DNS劫持，说明域名权威出问题，测量域名其他维度属性如证书信息，备案信息等，之后辅助域名管理者修复</li>
<li>DNS管理出错<br> 部分DNS判定为发生劫持，其他DNS出现异常，读取DNS劫持定位模块的DNS信息，辅助DNS管理者管理</li>
<li>中间路径攻击<br> 部分DNS判定为发生DNS劫持，其他域名测试正常</li>
</ol>
<h2 id="网络不良实体发现"><a href="#网络不良实体发现" class="headerlink" title="网络不良实体发现"></a>网络不良实体发现</h2><p>现状</p>
<ul>
<li>发现不容易</li>
<li>感知不准确</li>
<li>处置不完整</li>
<li>溯源不通畅</li>
<li>取证不全面</li>
</ul>
<p>域名：</p>
<ul>
<li>基本信息<ul>
<li>域名基本信息</li>
<li>Whois&#x2F;WhoWas信息</li>
</ul>
</li>
<li>站点信息<ul>
<li>服务IP信息</li>
<li>站点内容</li>
<li>站点链接</li>
<li>子域名信息</li>
<li>证书信息</li>
<li>ICP备案信息</li>
</ul>
</li>
<li>关联分析<ul>
<li>域名地理位置分析</li>
<li>域名关联信息分析</li>
<li>域名关联注册组织分析</li>
</ul>
</li>
<li>域名检测信息<ul>
<li>互联网公司</li>
<li>安全公司</li>
<li>域名检测平台</li>
</ul>
</li>
</ul>
<p>背景：</p>
<ol>
<li>不良站点信息多维（注册&#x2F;备案&#x2F;认证&#x2F;服务）</li>
<li>不良站点内容复杂</li>
<li>不良站点形式多样、传播渠道广</li>
<li>不良站点信息动态易变</li>
</ol>
<p>挑战：</p>
<ol>
<li>全面、高效、高质量的异常域名信息获取</li>
<li>高效、有效、准确的异常域名及其组织关系挖掘</li>
<li>准确、及时的异常域名活性测绘和变化趋势分析</li>
<li>准确、及时的异常域名治理效果评估</li>
</ol>
<p>然后这里有很多的技术，我觉的这里可能会让你例举几个技术，太多了我就不列了，大伙看着看就行</p>
<h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><p><img src="/2023/05/15/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8_1.jpeg"><br><img src="/2023/05/15/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E5%A4%8D%E4%B9%A0/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8_2.png"></p>
]]></content>
      <categories>
        <category>学习资料</category>
      </categories>
  </entry>
</search>
